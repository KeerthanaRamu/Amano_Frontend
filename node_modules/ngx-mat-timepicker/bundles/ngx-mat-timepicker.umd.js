(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/forms'), require('rxjs'), require('ts-luxon'), require('rxjs/operators'), require('@angular/cdk/overlay'), require('@angular/material/dialog'), require('smp-core-utils'), require('@angular/material/form-field'), require('@angular/cdk/portal'), require('@angular/common'), require('@angular/cdk/a11y'), require('@angular/material/button'), require('@angular/material/icon'), require('@angular/material/input'), require('@angular/material/select'), require('@angular/material/toolbar'), require('@angular/animations')) :
    typeof define === 'function' && define.amd ? define('ngx-mat-timepicker', ['exports', '@angular/core', '@angular/forms', 'rxjs', 'ts-luxon', 'rxjs/operators', '@angular/cdk/overlay', '@angular/material/dialog', 'smp-core-utils', '@angular/material/form-field', '@angular/cdk/portal', '@angular/common', '@angular/cdk/a11y', '@angular/material/button', '@angular/material/icon', '@angular/material/input', '@angular/material/select', '@angular/material/toolbar', '@angular/animations'], factory) :
    (global = global || self, factory(global['ngx-mat-timepicker'] = {}, global.ng.core, global.ng.forms, global.rxjs, global.tsLuxon, global.rxjs.operators, global.ng.cdk.overlay, global.ng.material.dialog, global.smpCoreUtils, global.ng.material['form-field'], global.ng.cdk.portal, global.ng.common, global.ng.cdk.a11y, global.ng.material.button, global.ng.material.icon, global.ng.material.input, global.ng.material.select, global.ng.material.toolbar, global.ng.animations));
}(this, (function (exports, core, forms, rxjs, tsLuxon, operators, overlay, dialog, smpCoreUtils, formField, portal, common, a11y, button, icon, input, select, toolbar, animations) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/models/ngx-mat-timepicker-periods.enum.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @enum {string} */
    var NgxMatTimepickerPeriods = {
        AM: "AM",
        PM: "PM",
    };

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/models/ngx-mat-timepicker-format.enum.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @enum {string} */
    var NgxMatTimepickerFormat = {
        TWELVE: "hh:mm a",
        TWELVE_SHORT: "h:m a",
        TWENTY_FOUR: "HH:mm",
        TWENTY_FOUR_SHORT: "H:m",
    };

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/services/ngx-mat-timepicker-adapter.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    // @dynamic
    var NgxMatTimepickerAdapter = /** @class */ (function () {
        function NgxMatTimepickerAdapter() {
        }
        /***
         *  Format hour according to time format (12 or 24)
         */
        /**
         *
         *  Format hour according to time format (12 or 24)
         * @param {?} currentHour
         * @param {?} format
         * @param {?} period
         * @return {?}
         */
        NgxMatTimepickerAdapter.formatHour = /**
         *
         *  Format hour according to time format (12 or 24)
         * @param {?} currentHour
         * @param {?} format
         * @param {?} period
         * @return {?}
         */
        function (currentHour, format, period) {
            if (format === 24) {
                return currentHour;
            }
            /** @type {?} */
            var hour = period === NgxMatTimepickerPeriods.AM ? currentHour : currentHour + 12;
            if (period === NgxMatTimepickerPeriods.AM && hour === 12) {
                return 0;
            }
            else if (period === NgxMatTimepickerPeriods.PM && hour === 24) {
                return 12;
            }
            return hour;
        };
        /**
         * @param {?} time
         * @param {?} opts
         * @return {?}
         */
        NgxMatTimepickerAdapter.formatTime = /**
         * @param {?} time
         * @param {?} opts
         * @return {?}
         */
        function (time, opts) {
            if (!time) {
                return "Invalid Time";
            }
            var format = opts.format;
            /** @type {?} */
            var parsedTime = NgxMatTimepickerAdapter.parseTime(time, opts).setLocale(NgxMatTimepickerAdapter.defaultLocale);
            if (format !== 24) {
                return parsedTime.toLocaleString(__assign(__assign({}, tsLuxon.DateTime.TIME_SIMPLE), { hour12: format !== 24 })).replace(/\u200E/g, "");
            }
            return parsedTime.toISOTime({
                includeOffset: false,
                suppressMilliseconds: true,
                suppressSeconds: true
            }).replace(/\u200E/g, "");
        };
        /**
         * @param {?} time
         * @param {?} format
         * @return {?}
         */
        NgxMatTimepickerAdapter.fromDateTimeToString = /**
         * @param {?} time
         * @param {?} format
         * @return {?}
         */
        function (time, format) {
            /** @type {?} */
            var timeFormat = format === 24 ? NgxMatTimepickerFormat.TWENTY_FOUR : NgxMatTimepickerFormat.TWELVE;
            return time.reconfigure({
                numberingSystem: NgxMatTimepickerAdapter.defaultNumberingSistem,
                locale: NgxMatTimepickerAdapter.defaultLocale
            }).toFormat(timeFormat);
        };
        /**
         * @param {?} time
         * @param {?} before
         * @param {?} after
         * @param {?=} unit
         * @return {?}
         */
        NgxMatTimepickerAdapter.isBetween = /**
         * @param {?} time
         * @param {?} before
         * @param {?} after
         * @param {?=} unit
         * @return {?}
         */
        function (time, before, after, unit) {
            if (unit === void 0) { unit = "minutes"; }
            if (unit === "hours") {
                return this.isSameOrBefore(time, after, unit) && this.isSameOrAfter(time, before, unit);
            }
            if (unit === "minutes") {
                return this.isSameOrBefore(time, after) && this.isSameOrAfter(time, before);
            }
        };
        /**
         * @param {?} time
         * @param {?} compareWith
         * @param {?=} unit
         * @return {?}
         */
        NgxMatTimepickerAdapter.isSameOrAfter = /**
         * @param {?} time
         * @param {?} compareWith
         * @param {?=} unit
         * @return {?}
         */
        function (time, compareWith, unit) {
            if (unit === void 0) { unit = "minutes"; }
            if (unit === "hours") {
                return time.hour >= compareWith.hour;
            }
            if (unit === "minutes") {
                return time.hasSame(compareWith, unit) || time.valueOf() > compareWith.valueOf();
            }
        };
        /**
         * @param {?} time
         * @param {?} compareWith
         * @param {?=} unit
         * @return {?}
         */
        NgxMatTimepickerAdapter.isSameOrBefore = /**
         * @param {?} time
         * @param {?} compareWith
         * @param {?=} unit
         * @return {?}
         */
        function (time, compareWith, unit) {
            if (unit === void 0) { unit = "minutes"; }
            if (unit === "hours") {
                return time.hour <= compareWith.hour;
            }
            if (unit === "minutes") {
                return time.hasSame(compareWith, unit) || time.valueOf() <= compareWith.valueOf();
            }
        };
        /**
         * @param {?} time
         * @param {?=} min
         * @param {?=} max
         * @param {?=} granularity
         * @param {?=} minutesGap
         * @param {?=} format
         * @return {?}
         */
        NgxMatTimepickerAdapter.isTimeAvailable = /**
         * @param {?} time
         * @param {?=} min
         * @param {?=} max
         * @param {?=} granularity
         * @param {?=} minutesGap
         * @param {?=} format
         * @return {?}
         */
        function (time, min, max, granularity, minutesGap, format) {
            if (!time) {
                return;
            }
            /** @type {?} */
            var convertedTime = this.parseTime(time, { format: format });
            /** @type {?} */
            var minutes = convertedTime.minute;
            if (minutesGap && minutes === minutes && minutes % minutesGap !== 0) {
                throw new Error("Your minutes - " + minutes + " doesn't match your minutesGap - " + minutesGap);
            }
            /** @type {?} */
            var isAfter = (min && !max)
                && this.isSameOrAfter(convertedTime, min, granularity);
            /** @type {?} */
            var isBefore = (max && !min)
                && this.isSameOrBefore(convertedTime, max, granularity);
            /** @type {?} */
            var between = (min && max)
                && this.isBetween(convertedTime, min, max, granularity);
            /** @type {?} */
            var isAvailable = !min && !max;
            return isAfter || isBefore || between || isAvailable;
        };
        /**
         * @param {?} time
         * @param {?} opts
         * @return {?}
         */
        NgxMatTimepickerAdapter.parseTime = /**
         * @param {?} time
         * @param {?} opts
         * @return {?}
         */
        function (time, opts) {
            var _a = NgxMatTimepickerAdapter._getLocaleOptionsByTime(time, opts), numberingSystem = _a.numberingSystem, locale = _a.locale;
            /** @type {?} */
            var isPeriodExist = time.split(" ").length === 2;
            /** @type {?} */
            var timeMask = isPeriodExist ? NgxMatTimepickerFormat.TWELVE_SHORT : NgxMatTimepickerFormat.TWENTY_FOUR_SHORT;
            return tsLuxon.DateTime.fromFormat(time, timeMask, { numberingSystem: numberingSystem, locale: locale });
        };
        /**
         * @param {?} time
         * @param {?=} opts
         * @return {?}
         */
        NgxMatTimepickerAdapter.toLocaleTimeString = /**
         * @param {?} time
         * @param {?=} opts
         * @return {?}
         */
        function (time, opts) {
            if (opts === void 0) { opts = {}; }
            var _a = opts.format, format = _a === void 0 ? NgxMatTimepickerAdapter.defaultFormat : _a, _b = opts.locale, locale = _b === void 0 ? NgxMatTimepickerAdapter.defaultLocale : _b;
            /** @type {?} */
            var hourCycle = format === 24 ? "h23" : "h12";
            /** @type {?} */
            var timeFormat = __assign(__assign({}, tsLuxon.DateTime.TIME_SIMPLE), { hourCycle: hourCycle });
            /** @type {?} */
            var timeMask = (format === 24) ? NgxMatTimepickerFormat.TWENTY_FOUR_SHORT : NgxMatTimepickerFormat.TWELVE_SHORT;
            return tsLuxon.DateTime.fromFormat(time, timeMask).setLocale(locale).toLocaleString(timeFormat);
        };
        /**
         * @private
         * @param {?} time
         * @param {?} opts
         * @return {?}
         */
        NgxMatTimepickerAdapter._getLocaleOptionsByTime = /**
         * @private
         * @param {?} time
         * @param {?} opts
         * @return {?}
         */
        function (time, opts) {
            var _a = tsLuxon.DateTime.local().setLocale(opts.locale).resolvedLocaleOpts(), numberingSystem = _a.numberingSystem, locale = _a.locale;
            /** @type {?} */
            var localeConfig = {
                numberingSystem: (/** @type {?} */ (numberingSystem)),
                locale: locale
            };
            /** @type {?} */
            var defaultConfig = {
                numberingSystem: NgxMatTimepickerAdapter.defaultNumberingSistem,
                locale: NgxMatTimepickerAdapter.defaultLocale
            };
            return isNaN(parseInt(time, 10)) ? localeConfig : defaultConfig;
        };
        NgxMatTimepickerAdapter.defaultFormat = 12;
        NgxMatTimepickerAdapter.defaultLocale = "en-US";
        NgxMatTimepickerAdapter.defaultNumberingSistem = "latn";
        return NgxMatTimepickerAdapter;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/services/ngx-mat-timepicker.service.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DEFAULT_HOUR = {
        time: 12,
        angle: 360
    };
    /** @type {?} */
    var DEFAULT_MINUTE = {
        time: 0,
        angle: 360
    };
    var NgxMatTimepickerService = /** @class */ (function () {
        function NgxMatTimepickerService() {
            this._hour$ = new rxjs.BehaviorSubject(DEFAULT_HOUR);
            this._minute$ = new rxjs.BehaviorSubject(DEFAULT_MINUTE);
            this._period$ = new rxjs.BehaviorSubject(NgxMatTimepickerPeriods.AM);
        }
        Object.defineProperty(NgxMatTimepickerService.prototype, "hour", {
            set: /**
             * @param {?} hour
             * @return {?}
             */
            function (hour) {
                this._hour$.next(hour);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxMatTimepickerService.prototype, "minute", {
            set: /**
             * @param {?} minute
             * @return {?}
             */
            function (minute) {
                this._minute$.next(minute);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxMatTimepickerService.prototype, "period", {
            set: /**
             * @param {?} period
             * @return {?}
             */
            function (period) {
                /** @type {?} */
                var isPeriodValid = (period === NgxMatTimepickerPeriods.AM) || (period === NgxMatTimepickerPeriods.PM);
                if (isPeriodValid) {
                    this._period$.next(period);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxMatTimepickerService.prototype, "selectedHour", {
            get: /**
             * @return {?}
             */
            function () {
                return this._hour$.asObservable();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxMatTimepickerService.prototype, "selectedMinute", {
            get: /**
             * @return {?}
             */
            function () {
                return this._minute$.asObservable();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxMatTimepickerService.prototype, "selectedPeriod", {
            get: /**
             * @return {?}
             */
            function () {
                return this._period$.asObservable();
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @param {?} format
         * @return {?}
         */
        NgxMatTimepickerService.prototype.getFullTime = /**
         * @param {?} format
         * @return {?}
         */
        function (format) {
            /** @type {?} */
            var selectedHour = this._hour$.getValue().time;
            /** @type {?} */
            var selectedMinute = this._minute$.getValue().time;
            /** @type {?} */
            var hour = selectedHour != null ? selectedHour : DEFAULT_HOUR.time;
            /** @type {?} */
            var minute = selectedMinute != null ? selectedMinute : DEFAULT_MINUTE.time;
            /** @type {?} */
            var period = format === 12 ? this._period$.getValue() : "";
            /** @type {?} */
            var time = (hour + ":" + minute + " " + period).trim();
            return NgxMatTimepickerAdapter.formatTime(time, { format: format });
        };
        /**
         * @param {?} time
         * @param {?} min
         * @param {?} max
         * @param {?} format
         * @param {?=} minutesGap
         * @return {?}
         */
        NgxMatTimepickerService.prototype.setDefaultTimeIfAvailable = /**
         * @param {?} time
         * @param {?} min
         * @param {?} max
         * @param {?} format
         * @param {?=} minutesGap
         * @return {?}
         */
        function (time, min, max, format, minutesGap) {
            /* Workaround to double error message*/
            try {
                if (NgxMatTimepickerAdapter.isTimeAvailable(time, min, max, "minutes", minutesGap)) {
                    this._setDefaultTime(time, format);
                }
            }
            catch (e) {
                console.error(e);
            }
        };
        /**
         * @private
         * @return {?}
         */
        NgxMatTimepickerService.prototype._resetTime = /**
         * @private
         * @return {?}
         */
        function () {
            this.hour = __assign({}, DEFAULT_HOUR);
            this.minute = __assign({}, DEFAULT_MINUTE);
            this.period = NgxMatTimepickerPeriods.AM;
        };
        /**
         * @private
         * @param {?} time
         * @param {?} format
         * @return {?}
         */
        NgxMatTimepickerService.prototype._setDefaultTime = /**
         * @private
         * @param {?} time
         * @param {?} format
         * @return {?}
         */
        function (time, format) {
            /** @type {?} */
            var defaultTime = NgxMatTimepickerAdapter.parseTime(time, { format: format }).toJSDate();
            // Check on null, because invalid date will be null
            if (tsLuxon.DateTime.fromJSDate(defaultTime) !== null) {
                /** @type {?} */
                var period = time.substr(time.length - 2).toUpperCase();
                /** @type {?} */
                var hour = defaultTime.getHours();
                this.hour = __assign(__assign({}, DEFAULT_HOUR), { time: formatHourByPeriod(hour, (/** @type {?} */ (period))) });
                this.minute = __assign(__assign({}, DEFAULT_MINUTE), { time: defaultTime.getMinutes() });
                this.period = (/** @type {?} */ (period));
            }
            else {
                this._resetTime();
            }
        };
        NgxMatTimepickerService.decorators = [
            { type: core.Injectable, args: [{
                        providedIn: "root"
                    },] }
        ];
        /** @nocollapse */ NgxMatTimepickerService.ɵprov = core["ɵɵdefineInjectable"]({ factory: function NgxMatTimepickerService_Factory() { return new NgxMatTimepickerService(); }, token: NgxMatTimepickerService, providedIn: "root" });
        return NgxMatTimepickerService;
    }());
    /**
     *
     *  Format hour in 24hours format to meridian (AM or PM) format
     * @param {?} hour
     * @param {?} period
     * @return {?}
     */
    function formatHourByPeriod(hour, period) {
        switch (period) {
            case NgxMatTimepickerPeriods.AM:
                return hour === 0 ? 12 : hour;
            case NgxMatTimepickerPeriods.PM:
                return hour === 12 ? 12 : hour - 12;
            default:
                return hour;
        }
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/models/ngx-mat-timepicker-units.enum.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @enum {number} */
    var NgxMatTimepickerUnits = {
        HOUR: 0,
        MINUTE: 1,
    };
    NgxMatTimepickerUnits[NgxMatTimepickerUnits.HOUR] = 'HOUR';
    NgxMatTimepickerUnits[NgxMatTimepickerUnits.MINUTE] = 'MINUTE';

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/tokens/ngx-mat-timepicker-time-locale.token.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var NGX_MAT_TIMEPICKER_LOCALE = new core.InjectionToken("TimeLocale", {
        providedIn: "root",
        factory: (/**
         * @return {?}
         */
        function () { return NgxMatTimepickerAdapter.defaultLocale; })
    });

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/utils/ngx-mat-timepicker.utils.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    // @dynamic
    var 
    // @dynamic
    NgxMatTimepickerUtils = /** @class */ (function () {
        function NgxMatTimepickerUtils() {
        }
        /**
         * @param {?} hours
         * @param {?} config
         * @return {?}
         */
        NgxMatTimepickerUtils.disableHours = /**
         * @param {?} hours
         * @param {?} config
         * @return {?}
         */
        function (hours, config) {
            if (config.min || config.max) {
                return hours.map((/**
                 * @param {?} value
                 * @return {?}
                 */
                function (value) {
                    /** @type {?} */
                    var hour = config.format === 24 ? value.time : NgxMatTimepickerAdapter.formatHour(value.time, config.format, config.period);
                    /** @type {?} */
                    var currentTime = tsLuxon.DateTime.fromObject({ hour: hour }).toFormat(NgxMatTimepickerFormat.TWELVE);
                    return __assign(__assign({}, value), { disabled: !NgxMatTimepickerAdapter.isTimeAvailable(currentTime, config.min, config.max, "hours") });
                }));
            }
            return hours;
        };
        /**
         * @param {?} minutes
         * @param {?} selectedHour
         * @param {?} config
         * @return {?}
         */
        NgxMatTimepickerUtils.disableMinutes = /**
         * @param {?} minutes
         * @param {?} selectedHour
         * @param {?} config
         * @return {?}
         */
        function (minutes, selectedHour, config) {
            if (config.min || config.max) {
                /** @type {?} */
                var hour_1 = NgxMatTimepickerAdapter.formatHour(selectedHour, config.format, config.period);
                return minutes.map((/**
                 * @param {?} value
                 * @return {?}
                 */
                function (value) {
                    /** @type {?} */
                    var currentTime = tsLuxon.DateTime.fromObject({
                        hour: hour_1,
                        minute: value.time
                    }).toFormat(NgxMatTimepickerFormat.TWELVE);
                    return __assign(__assign({}, value), { disabled: !NgxMatTimepickerAdapter.isTimeAvailable(currentTime, config.min, config.max, "minutes") });
                }));
            }
            return minutes;
        };
        /**
         * @param {?} format
         * @return {?}
         */
        NgxMatTimepickerUtils.getHours = /**
         * @param {?} format
         * @return {?}
         */
        function (format) {
            return Array(format).fill(1).map((/**
             * @param {?} v
             * @param {?} i
             * @return {?}
             */
            function (v, i) {
                /** @type {?} */
                var angleStep = 30;
                /** @type {?} */
                var time = v + i;
                /** @type {?} */
                var angle = angleStep * time;
                return { time: time === 24 ? 0 : time, angle: angle };
            }));
        };
        /**
         * @param {?=} gap
         * @return {?}
         */
        NgxMatTimepickerUtils.getMinutes = /**
         * @param {?=} gap
         * @return {?}
         */
        function (gap) {
            if (gap === void 0) { gap = 1; }
            /** @type {?} */
            var minutesCount = 60;
            /** @type {?} */
            var angleStep = 360 / minutesCount;
            /** @type {?} */
            var minutes = [];
            for (var i = 0; i < minutesCount; i++) {
                /** @type {?} */
                var angle = angleStep * i;
                if (i % gap === 0) {
                    minutes.push({ time: i, angle: angle !== 0 ? angle : 360 });
                }
            }
            return minutes;
        };
        /**
         * @param {?} e
         * @return {?}
         */
        NgxMatTimepickerUtils.isDigit = /**
         * @param {?} e
         * @return {?}
         */
        function (e) {
            // Allow: backspace, delete, tab, escape, enter
            if ([46, 8, 9, 27, 13].some((/**
             * @param {?} n
             * @return {?}
             */
            function (n) { return n === e.keyCode; })) ||
                // Allow: Ctrl/cmd+A
                (e.keyCode == 65 && (e.ctrlKey === true || e.metaKey === true)) ||
                // Allow: Ctrl/cmd+C
                (e.keyCode == 67 && (e.ctrlKey === true || e.metaKey === true)) ||
                // Allow: Ctrl/cmd+X
                (e.keyCode == 88 && (e.ctrlKey === true || e.metaKey === true)) ||
                // Allow: home, end, left, right, up, down
                (e.keyCode >= 35 && e.keyCode <= 40)) {
                return true;
            }
            return !((e.keyCode < 48 || e.keyCode > 57) && (e.keyCode < 96 || e.keyCode > 105));
        };
        return NgxMatTimepickerUtils;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/components/ngx-mat-timepicker-field/ngx-mat-timepicker-field.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NgxMatTimepickerFieldComponent = /** @class */ (function () {
        function NgxMatTimepickerFieldComponent(_timepickerService, _locale) {
            this._timepickerService = _timepickerService;
            this._locale = _locale;
            this.maxHour = 12;
            this.minHour = 1;
            this.period = NgxMatTimepickerPeriods.AM;
            this.periods = [
                NgxMatTimepickerPeriods.AM,
                NgxMatTimepickerPeriods.PM
            ];
            this.timeChanged = new core.EventEmitter();
            this.timeUnit = NgxMatTimepickerUnits;
            this._color = "primary";
            this._floatLabel = "never";
            this._format = 12;
            this._isFirstTimeChange = true;
            this._subsCtrl$ = new rxjs.Subject();
            this._onChange = (/**
             * @return {?}
             */
            function () {
            });
        }
        Object.defineProperty(NgxMatTimepickerFieldComponent.prototype, "color", {
            get: /**
             * @return {?}
             */
            function () {
                return this._color;
            },
            set: /**
             * @param {?} newValue
             * @return {?}
             */
            function (newValue) {
                this._color = newValue;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxMatTimepickerFieldComponent.prototype, "defaultTime", {
            get: /**
             * @return {?}
             */
            function () {
                return this._defaultTime;
            },
            set: /**
             * @param {?} val
             * @return {?}
             */
            function (val) {
                this._defaultTime = val;
                this._isDefaultTime = !!val;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxMatTimepickerFieldComponent.prototype, "floatLabel", {
            get: /**
             * @return {?}
             */
            function () {
                return this._floatLabel;
            },
            set: /**
             * @param {?} newValue
             * @return {?}
             */
            function (newValue) {
                this._floatLabel = newValue;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxMatTimepickerFieldComponent.prototype, "format", {
            get: /**
             * @return {?}
             */
            function () {
                return this._format;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._format = value === 24 ? 24 : 12;
                this.minHour = this._format === 12 ? 1 : 0;
                this.maxHour = this._format === 12 ? 12 : 23;
                this.hoursList = NgxMatTimepickerUtils.getHours(this._format);
                /** @type {?} */
                var isDynamicallyChanged = value && (this._previousFormat && this._previousFormat !== this._format);
                if (isDynamicallyChanged) {
                    this._updateTime(this.timepickerTime);
                }
                this._previousFormat = this._format;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxMatTimepickerFieldComponent.prototype, "max", {
            get: /**
             * @return {?}
             */
            function () {
                return this._max;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (typeof value === "string") {
                    this._max = NgxMatTimepickerAdapter.parseTime(value, { locale: this._locale, format: this.format });
                    return;
                }
                this._max = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxMatTimepickerFieldComponent.prototype, "min", {
            get: /**
             * @return {?}
             */
            function () {
                return this._min;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (typeof value === "string") {
                    this._min = NgxMatTimepickerAdapter.parseTime(value, { locale: this._locale, format: this.format });
                    return;
                }
                this._min = value;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @param {?} hour
         * @return {?}
         */
        NgxMatTimepickerFieldComponent.prototype.changeHour = /**
         * @param {?} hour
         * @return {?}
         */
        function (hour) {
            this._timepickerService.hour = this.hoursList.find((/**
             * @param {?} h
             * @return {?}
             */
            function (h) { return h.time === hour; }));
            this._changeTime();
        };
        /**
         * @param {?} minute
         * @return {?}
         */
        NgxMatTimepickerFieldComponent.prototype.changeMinute = /**
         * @param {?} minute
         * @return {?}
         */
        function (minute) {
            this._timepickerService.minute = this.minutesList.find((/**
             * @param {?} m
             * @return {?}
             */
            function (m) { return m.time === minute; }));
            this._changeTime();
        };
        /**
         * @param {?} event
         * @return {?}
         */
        NgxMatTimepickerFieldComponent.prototype.changePeriod = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            this._timepickerService.period = (/** @type {?} */ (event.value));
            this._changeTime();
        };
        /**
         * @return {?}
         */
        NgxMatTimepickerFieldComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._subsCtrl$.next();
            this._subsCtrl$.complete();
        };
        /**
         * @return {?}
         */
        NgxMatTimepickerFieldComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this._initTime(this.defaultTime);
            this.hoursList = NgxMatTimepickerUtils.getHours(this._format);
            this.minutesList = NgxMatTimepickerUtils.getMinutes();
            this.isTimeRangeSet = !!(this.min || this.max);
            this.hour$ = (/** @type {?} */ (this._timepickerService.selectedHour.pipe(operators.tap((/**
             * @param {?} clockTime
             * @return {?}
             */
            function (clockTime) { return _this._selectedHour = clockTime.time; })), operators.map(this._changeDefaultTimeValue.bind(this)), operators.tap((/**
             * @return {?}
             */
            function () { return _this.isTimeRangeSet && _this._updateAvailableMinutes(); })))));
            this.minute$ = (/** @type {?} */ (this._timepickerService.selectedMinute.pipe(operators.map(this._changeDefaultTimeValue.bind(this)), operators.tap((/**
             * @return {?}
             */
            function () { return _this._isFirstTimeChange = false; })))));
            if (this.format === 12) {
                this._timepickerService.selectedPeriod.pipe(operators.distinctUntilChanged(), operators.tap((/**
                 * @param {?} period
                 * @return {?}
                 */
                function (period) { return _this.period = period; })), operators.tap((/**
                 * @param {?} period
                 * @return {?}
                 */
                function (period) { return _this.isChangePeriodDisabled = _this._isPeriodDisabled(period); })), operators.takeUntil(this._subsCtrl$)).subscribe((/**
                 * @return {?}
                 */
                function () { return _this.isTimeRangeSet && _this._updateAvailableTime(); }));
            }
        };
        /**
         * @param {?} time
         * @return {?}
         */
        NgxMatTimepickerFieldComponent.prototype.onTimeSet = /**
         * @param {?} time
         * @return {?}
         */
        function (time) {
            this._updateTime(time);
            this._emitLocalTimeChange(time);
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        NgxMatTimepickerFieldComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this._onChange = fn;
        };
        /**
         * @param {?} _fn_
         * @return {?}
         */
        NgxMatTimepickerFieldComponent.prototype.registerOnTouched = /**
         * @param {?} _fn_
         * @return {?}
         */
        function (_fn_) {
        };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        NgxMatTimepickerFieldComponent.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
        function (isDisabled) {
            this.disabled = isDisabled;
        };
        /**
         * @param {?} val
         * @return {?}
         */
        NgxMatTimepickerFieldComponent.prototype.writeValue = /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            if (val) {
                this._initTime(val);
            }
            else {
                this._resetTime();
            }
        };
        /**
         * @private
         * @param {?} clockFaceTime
         * @return {?}
         */
        NgxMatTimepickerFieldComponent.prototype._changeDefaultTimeValue = /**
         * @private
         * @param {?} clockFaceTime
         * @return {?}
         */
        function (clockFaceTime) {
            if (!this._isDefaultTime && this._isFirstTimeChange) {
                return __assign(__assign({}, clockFaceTime), { time: null });
            }
            return clockFaceTime;
        };
        /**
         * @private
         * @return {?}
         */
        NgxMatTimepickerFieldComponent.prototype._changeTime = /**
         * @private
         * @return {?}
         */
        function () {
            /** @type {?} */
            var time = this._timepickerService.getFullTime(this.format);
            this.timepickerTime = time;
            this._emitLocalTimeChange(time);
        };
        /**
         * @private
         * @param {?} time
         * @return {?}
         */
        NgxMatTimepickerFieldComponent.prototype._emitLocalTimeChange = /**
         * @private
         * @param {?} time
         * @return {?}
         */
        function (time) {
            /** @type {?} */
            var localTime = NgxMatTimepickerAdapter.toLocaleTimeString(time, { format: this.format, locale: this._locale });
            this._onChange(localTime);
            this.timeChanged.emit(localTime);
        };
        /**
         * @private
         * @param {?} time
         * @return {?}
         */
        NgxMatTimepickerFieldComponent.prototype._initTime = /**
         * @private
         * @param {?} time
         * @return {?}
         */
        function (time) {
            /** @type {?} */
            var isDefaultTimeAvailable = NgxMatTimepickerAdapter
                .isTimeAvailable(time, (/** @type {?} */ (this.min)), (/** @type {?} */ (this.max)), "minutes", null, this.format);
            if (!isDefaultTimeAvailable) {
                if (this.min) {
                    this._updateTime(NgxMatTimepickerAdapter.fromDateTimeToString((/** @type {?} */ (this.min)), this.format));
                    return;
                }
                if (this.max) {
                    this._updateTime(NgxMatTimepickerAdapter.fromDateTimeToString((/** @type {?} */ (this.max)), this.format));
                    return;
                }
            }
            this._updateTime(time);
        };
        /**
         * @private
         * @param {?} period
         * @return {?}
         */
        NgxMatTimepickerFieldComponent.prototype._isPeriodDisabled = /**
         * @private
         * @param {?} period
         * @return {?}
         */
        function (period) {
            return NgxMatTimepickerUtils.disableHours(NgxMatTimepickerUtils.getHours(12), {
                min: (/** @type {?} */ (this.min)),
                max: (/** @type {?} */ (this.max)),
                format: 12,
                period: period === NgxMatTimepickerPeriods.AM ? NgxMatTimepickerPeriods.PM : NgxMatTimepickerPeriods.AM
            }).every((/**
             * @param {?} time
             * @return {?}
             */
            function (time) { return time.disabled; }));
        };
        /**
         * @private
         * @return {?}
         */
        NgxMatTimepickerFieldComponent.prototype._resetTime = /**
         * @private
         * @return {?}
         */
        function () {
            this._timepickerService.hour = { angle: 0, time: null };
            this._timepickerService.minute = { angle: 0, time: null };
        };
        /**
         * @private
         * @return {?}
         */
        NgxMatTimepickerFieldComponent.prototype._updateAvailableHours = /**
         * @private
         * @return {?}
         */
        function () {
            this.hoursList = NgxMatTimepickerUtils.disableHours(this.hoursList, {
                min: (/** @type {?} */ (this.min)),
                max: (/** @type {?} */ (this.max)),
                format: this.format,
                period: this.period
            });
        };
        /**
         * @private
         * @return {?}
         */
        NgxMatTimepickerFieldComponent.prototype._updateAvailableMinutes = /**
         * @private
         * @return {?}
         */
        function () {
            this.minutesList = NgxMatTimepickerUtils.disableMinutes(this.minutesList, this._selectedHour, {
                min: (/** @type {?} */ (this.min)),
                max: (/** @type {?} */ (this.max)),
                format: this.format,
                period: this.period
            });
        };
        /**
         * @private
         * @return {?}
         */
        NgxMatTimepickerFieldComponent.prototype._updateAvailableTime = /**
         * @private
         * @return {?}
         */
        function () {
            this._updateAvailableHours();
            if (this._selectedHour) {
                this._updateAvailableMinutes();
            }
        };
        /**
         * @private
         * @param {?} time
         * @return {?}
         */
        NgxMatTimepickerFieldComponent.prototype._updateTime = /**
         * @private
         * @param {?} time
         * @return {?}
         */
        function (time) {
            if (time) {
                /** @type {?} */
                var formattedTime = NgxMatTimepickerAdapter.formatTime(time, { locale: this._locale, format: this.format });
                this._timepickerService.setDefaultTimeIfAvailable(formattedTime, (/** @type {?} */ (this.min)), (/** @type {?} */ (this.max)), this.format);
                this.timepickerTime = formattedTime;
            }
        };
        NgxMatTimepickerFieldComponent.decorators = [
            { type: core.Component, args: [{
                        selector: "ngx-mat-timepicker-field",
                        template: "<div class=\"ngx-mat-timepicker\"\n     [ngClass]=\"{'ngx-mat-timepicker--disabled': disabled}\">\n    <ngx-mat-timepicker-time-control\n            class=\"ngx-mat-timepicker__control--first\"\n            [color]=\"color\"\n            [floatLabel]=\"floatLabel\"\n            [placeholder]=\"'HH'\"\n            [time]=\"(hour$ | async)?.time\"\n            [min]=\"minHour\"\n            [max]=\"maxHour\"\n            [timeUnit]=\"timeUnit.HOUR\"\n            [disabled]=\"disabled\"\n            [timeList]=\"hoursList\"\n            [preventTyping]=\"isTimeRangeSet\"\n            (timeChanged)=\"changeHour($event)\"></ngx-mat-timepicker-time-control>\n    <span class=\"separator-colon ngx-mat-timepicker__control--second\">:</span>\n    <ngx-mat-timepicker-time-control\n            class=\"ngx-mat-timepicker__control--third\"\n            [color]=\"color\"\n            [floatLabel]=\"floatLabel\"\n            [placeholder]=\"'MM'\"\n            [time]=\"(minute$ | async)?.time\"\n            [min]=\"0\"\n            [max]=\"59\"\n            [timeUnit]=\"timeUnit.MINUTE\"\n            [disabled]=\"disabled\"\n            [timeList]=\"minutesList\"\n            [preventTyping]=\"isTimeRangeSet\"\n            (timeChanged)=\"changeMinute($event)\"></ngx-mat-timepicker-time-control>\n    <mat-form-field class=\"period-select ngx-mat-timepicker__control--forth\"\n                    *ngIf=\"format !== 24\"\n                    [color]=\"color\">\n        <mat-select [disabled]=\"disabled || isChangePeriodDisabled\"\n                    (selectionChange)=\"changePeriod($event)\"\n                    [ngModel]=\"period\">\n            <mat-option *ngFor=\"let option of periods\"\n                        [value]=\"option\">{{option}}</mat-option>\n        </mat-select>\n    </mat-form-field>\n    <ngx-mat-timepicker-toggle\n            class=\"ngx-mat-timepicker__toggle\"\n            *ngIf=\"!controlOnly\"\n            [for]=\"timepicker\"\n            [disabled]=\"disabled\">\n        <span ngxMatTimepickerToggleIcon>\n            <ng-container *ngTemplateOutlet=\"toggleIcon || defaultIcon\"></ng-container>\n        </span>\n    </ngx-mat-timepicker-toggle>\n</div>\n<ngx-mat-timepicker\n        [color]=\"color\"\n        [min]=\"min\"\n        [max]=\"max\"\n        [theme]=\"clockTheme\"\n        [defaultTime]=\"timepickerTime\"\n        [format]=\"format\"\n        [cancelBtnTmpl]=\"cancelBtnTmpl\"\n        [confirmBtnTmpl]=\"confirmBtnTmpl\"\n        (timeSet)=\"onTimeSet($event)\"\n        #timepicker></ngx-mat-timepicker>\n\n<ng-template #defaultIcon>\n    <mat-icon>watch_later</mat-icon>\n</ng-template>\n",
                        providers: [
                            NgxMatTimepickerService,
                            {
                                provide: forms.NG_VALUE_ACCESSOR,
                                useExisting: NgxMatTimepickerFieldComponent,
                                multi: true
                            }
                        ],
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        encapsulation: core.ViewEncapsulation.None,
                        styles: [".ngx-mat-timepicker{display:flex;align-items:center;height:100%}.ngx-mat-timepicker--disabled{background:rgba(0,0,0,.07);pointer-events:none}.ngx-mat-timepicker .separator-colon{margin-left:5px;margin-right:5px}.ngx-mat-timepicker .period-select{width:60px;min-width:60px;margin-left:8px;text-align:center}.ngx-mat-timepicker__control--first{order:1}.ngx-mat-timepicker__control--second{order:2}.ngx-mat-timepicker__control--third{order:3}.ngx-mat-timepicker__control--forth,.ngx-mat-timepicker__toggle{order:4}"]
                    }] }
        ];
        /** @nocollapse */
        NgxMatTimepickerFieldComponent.ctorParameters = function () { return [
            { type: NgxMatTimepickerService },
            { type: String, decorators: [{ type: core.Inject, args: [NGX_MAT_TIMEPICKER_LOCALE,] }] }
        ]; };
        NgxMatTimepickerFieldComponent.propDecorators = {
            color: [{ type: core.Input }],
            defaultTime: [{ type: core.Input }],
            floatLabel: [{ type: core.Input }],
            format: [{ type: core.Input }],
            max: [{ type: core.Input }],
            min: [{ type: core.Input }],
            cancelBtnTmpl: [{ type: core.Input }],
            clockTheme: [{ type: core.Input }],
            confirmBtnTmpl: [{ type: core.Input }],
            controlOnly: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            timeChanged: [{ type: core.Output }],
            toggleIcon: [{ type: core.Input }]
        };
        return NgxMatTimepickerFieldComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/directives/ngx-mat-timepicker-toggle-icon.directive.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /* To override a default toggle icon */
    var NgxMatTimepickerToggleIconDirective = /** @class */ (function () {
        function NgxMatTimepickerToggleIconDirective() {
        }
        NgxMatTimepickerToggleIconDirective.decorators = [
            { type: core.Directive, args: [{ selector: "[ngxMatTimepickerToggleIcon]" },] }
        ];
        return NgxMatTimepickerToggleIconDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/services/ngx-mat-timepicker-event.service.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NgxMatTimepickerEventService = /** @class */ (function () {
        function NgxMatTimepickerEventService() {
            this._backdropClick$ = new rxjs.Subject();
            this._keydownEvent$ = new rxjs.Subject();
        }
        Object.defineProperty(NgxMatTimepickerEventService.prototype, "backdropClick", {
            get: /**
             * @return {?}
             */
            function () {
                return this._backdropClick$.asObservable().pipe(operators.shareReplay({ bufferSize: 1, refCount: true }));
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxMatTimepickerEventService.prototype, "keydownEvent", {
            get: /**
             * @return {?}
             */
            function () {
                return this._keydownEvent$.asObservable().pipe(operators.shareReplay({ bufferSize: 1, refCount: true }));
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @param {?} event
         * @return {?}
         */
        NgxMatTimepickerEventService.prototype.dispatchEvent = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            switch (event.type) {
                case "click":
                    this._backdropClick$.next((/** @type {?} */ (event)));
                    break;
                case "keydown":
                    this._keydownEvent$.next((/** @type {?} */ (event)));
                    break;
                default:
                    throw new Error("no such event type");
            }
        };
        NgxMatTimepickerEventService.decorators = [
            { type: core.Injectable, args: [{
                        providedIn: "root"
                    },] }
        ];
        /** @nocollapse */
        NgxMatTimepickerEventService.ctorParameters = function () { return []; };
        /** @nocollapse */ NgxMatTimepickerEventService.ɵprov = core["ɵɵdefineInjectable"]({ factory: function NgxMatTimepickerEventService_Factory() { return new NgxMatTimepickerEventService(); }, token: NgxMatTimepickerEventService, providedIn: "root" });
        return NgxMatTimepickerEventService;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/tokens/ngx-mat-timepicker-config.token.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var NGX_MAT_TIMEPICKER_CONFIG = new core.InjectionToken("NGX_MAT_TIMEPICKER_CONFIG");

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/directives/ngx-mat-timepicker-base.directive.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NgxMatTimepickerBaseDirective = /** @class */ (function () {
        function NgxMatTimepickerBaseDirective(_timepickerSrv, _eventSrv, _locale, data) {
            this._timepickerSrv = _timepickerSrv;
            this._eventSrv = _eventSrv;
            this._locale = _locale;
            this.data = data;
            this.activeTimeUnit = NgxMatTimepickerUnits.HOUR;
            this.timeUnit = NgxMatTimepickerUnits;
            this._color = "primary";
            this._subsCtrl$ = new rxjs.Subject();
            this.color = data.color;
            this.defaultTime = data.defaultTime;
        }
        Object.defineProperty(NgxMatTimepickerBaseDirective.prototype, "color", {
            get: /**
             * @return {?}
             */
            function () {
                return this._color;
            },
            set: /**
             * @param {?} newValue
             * @return {?}
             */
            function (newValue) {
                this._color = newValue;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxMatTimepickerBaseDirective.prototype, "defaultTime", {
            get: /**
             * @return {?}
             */
            function () {
                return this._defaultTime;
            },
            set: /**
             * @param {?} time
             * @return {?}
             */
            function (time) {
                this._defaultTime = time;
                this._setDefaultTime(time);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @param {?} period
         * @return {?}
         */
        NgxMatTimepickerBaseDirective.prototype.changePeriod = /**
         * @param {?} period
         * @return {?}
         */
        function (period) {
            this._timepickerSrv.period = period;
            this._onTimeChange();
        };
        /**
         * @param {?} unit
         * @return {?}
         */
        NgxMatTimepickerBaseDirective.prototype.changeTimeUnit = /**
         * @param {?} unit
         * @return {?}
         */
        function (unit) {
            this.activeTimeUnit = unit;
        };
        /**
         * @return {?}
         */
        NgxMatTimepickerBaseDirective.prototype.close = /**
         * @return {?}
         */
        function () {
            this.data.timepickerBaseRef.close();
        };
        /**
         * @return {?}
         */
        NgxMatTimepickerBaseDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._subsCtrl$.next();
            this._subsCtrl$.complete();
        };
        /**
         * @return {?}
         */
        NgxMatTimepickerBaseDirective.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            this._defineTime();
            this.selectedHour = this._timepickerSrv.selectedHour
                .pipe(operators.shareReplay({ bufferSize: 1, refCount: true }));
            this.selectedMinute = this._timepickerSrv.selectedMinute
                .pipe(operators.shareReplay({ bufferSize: 1, refCount: true }));
            this.selectedPeriod = this._timepickerSrv.selectedPeriod
                .pipe(operators.shareReplay({ bufferSize: 1, refCount: true }));
            this.data.timepickerBaseRef.timeUpdated.pipe(operators.takeUntil(this._subsCtrl$))
                .subscribe(this._setDefaultTime.bind(this));
        };
        /**
         * @param {?} hour
         * @return {?}
         */
        NgxMatTimepickerBaseDirective.prototype.onHourChange = /**
         * @param {?} hour
         * @return {?}
         */
        function (hour) {
            this._timepickerSrv.hour = hour;
            this._onTimeChange();
        };
        /**
         * @param {?} hour
         * @return {?}
         */
        NgxMatTimepickerBaseDirective.prototype.onHourSelected = /**
         * @param {?} hour
         * @return {?}
         */
        function (hour) {
            if (!this.data.hoursOnly) {
                this.changeTimeUnit(NgxMatTimepickerUnits.MINUTE);
            }
            this.data.timepickerBaseRef.hourSelected.next(hour);
        };
        /**
         * @param {?} e
         * @return {?}
         */
        NgxMatTimepickerBaseDirective.prototype.onKeydown = /**
         * @param {?} e
         * @return {?}
         */
        function (e) {
            this._eventSrv.dispatchEvent(e);
            e.stopPropagation();
        };
        /**
         * @param {?} minute
         * @return {?}
         */
        NgxMatTimepickerBaseDirective.prototype.onMinuteChange = /**
         * @param {?} minute
         * @return {?}
         */
        function (minute) {
            this._timepickerSrv.minute = minute;
            this._onTimeChange();
        };
        /**
         * @return {?}
         */
        NgxMatTimepickerBaseDirective.prototype.setTime = /**
         * @return {?}
         */
        function () {
            this.data.timepickerBaseRef.timeSet.next(this._timepickerSrv.getFullTime(this.data.format));
            this.close();
        };
        /**
         * @protected
         * @return {?}
         */
        NgxMatTimepickerBaseDirective.prototype._defineTime = /**
         * @protected
         * @return {?}
         */
        function () {
            /** @type {?} */
            var minTime = this.data.minTime;
            if (minTime && (!this.data.time && !this.data.defaultTime)) {
                /** @type {?} */
                var time = NgxMatTimepickerAdapter.fromDateTimeToString(minTime, this.data.format);
                this._setDefaultTime(time);
            }
        };
        /**
         * @protected
         * @return {?}
         */
        NgxMatTimepickerBaseDirective.prototype._onTimeChange = /**
         * @protected
         * @return {?}
         */
        function () {
            /** @type {?} */
            var time = NgxMatTimepickerAdapter.toLocaleTimeString(this._timepickerSrv.getFullTime(this.data.format), {
                locale: this._locale,
                format: this.data.format
            });
            this.data.timepickerBaseRef.timeChanged.emit(time);
        };
        /**
         * @protected
         * @param {?} time
         * @return {?}
         */
        NgxMatTimepickerBaseDirective.prototype._setDefaultTime = /**
         * @protected
         * @param {?} time
         * @return {?}
         */
        function (time) {
            this._timepickerSrv.setDefaultTimeIfAvailable(time, this.data.minTime, this.data.maxTime, this.data.format, this.data.minutesGap);
        };
        NgxMatTimepickerBaseDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: "[ngxMatTimepickerBase]"
                    },] }
        ];
        /** @nocollapse */
        NgxMatTimepickerBaseDirective.ctorParameters = function () { return [
            { type: NgxMatTimepickerService },
            { type: NgxMatTimepickerEventService },
            { type: String, decorators: [{ type: core.Inject, args: [NGX_MAT_TIMEPICKER_LOCALE,] }] },
            { type: undefined, decorators: [{ type: core.Inject, args: [NGX_MAT_TIMEPICKER_CONFIG,] }, { type: core.Optional }] }
        ]; };
        NgxMatTimepickerBaseDirective.propDecorators = {
            color: [{ type: core.Input }],
            defaultTime: [{ type: core.Input }],
            onKeydown: [{ type: core.HostListener, args: ["keydown", ["$event"],] }]
        };
        return NgxMatTimepickerBaseDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/components/ngx-mat-timepicker-dialog/ngx-mat-timepicker-dialog.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    //
    var NgxMatTimepickerDialogComponent = /** @class */ (function (_super) {
        __extends(NgxMatTimepickerDialogComponent, _super);
        function NgxMatTimepickerDialogComponent(data, _dialogRef, timepickerSrv, eventSrv, locale) {
            var _this = _super.call(this, timepickerSrv, eventSrv, locale, data) || this;
            _this.data = data;
            _this._dialogRef = _dialogRef;
            return _this;
        }
        /**
         * @return {?}
         */
        NgxMatTimepickerDialogComponent.prototype.close = /**
         * @return {?}
         */
        function () {
            this._dialogRef.close();
        };
        NgxMatTimepickerDialogComponent.decorators = [
            { type: core.Component, args: [{
                        selector: "ngx-mat-timepicker-dialog",
                        template: "<ng-template #cancelBtnDefault>\n    <button mat-button\n            [color]=\"color\">CANCEL\n    </button>\n</ng-template>\n<ng-template #confirmBtnDefault>\n    <button mat-button\n            [color]=\"color\">OK\n    </button>\n</ng-template>\n<div mat-dialog-content>\n    <ngx-mat-timepicker-content [appendToInput]=\"data.appendToInput\"\n                                [inputElement]=\"data.inputElement\"\n                                [ngxMatTimepickerTheme]=\"data.theme\">\n        <div class=\"timepicker\"\n             [ngClass]=\"data.timepickerClass\">\n            <mat-toolbar [color]=\"color\"\n                         class=\"timepicker-header\">\n                <ngx-mat-timepicker-dial [color]=\"color\"\n                                         [format]=\"data.format\"\n                                         [hour]=\"(selectedHour | async)?.time\"\n                                         [minute]=\"(selectedMinute | async)?.time\"\n                                         [period]=\"selectedPeriod | async\"\n                                         [activeTimeUnit]=\"activeTimeUnit\"\n                                         [minTime]=\"data.minTime\"\n                                         [maxTime]=\"data.maxTime\"\n                                         [isEditable]=\"data.enableKeyboardInput\"\n                                         [editableHintTmpl]=\"data.editableHintTmpl\"\n                                         [minutesGap]=\"data.minutesGap\"\n                                         [hoursOnly]=\"data.hoursOnly\"\n                                         (periodChanged)=\"changePeriod($event)\"\n                                         (timeUnitChanged)=\"changeTimeUnit($event)\"\n                                         (hourChanged)=\"onHourChange($event)\"\n                                         (minuteChanged)=\"onMinuteChange($event)\"\n                ></ngx-mat-timepicker-dial>\n            </mat-toolbar>\n            <div class=\"timepicker__main-content\">\n                <div class=\"timepicker__body\"\n                     [ngSwitch]=\"activeTimeUnit\">\n                    <div *ngSwitchCase=\"timeUnit.HOUR\">\n                        <ngx-mat-timepicker-24-hours-face *ngIf=\"data.format === 24;else ampmHours\"\n                                                          [color]=\"color\"\n                                                          (hourChange)=\"onHourChange($event)\"\n                                                          [selectedHour]=\"selectedHour | async\"\n                                                          [minTime]=\"data.minTime\"\n                                                          [maxTime]=\"data.maxTime\"\n                                                          [format]=\"data.format\"\n                                                          (hourSelected)=\"onHourSelected($event)\"></ngx-mat-timepicker-24-hours-face>\n                        <ng-template #ampmHours>\n                            <ngx-mat-timepicker-12-hours-face\n                                    [color]=\"color\"\n                                    (hourChange)=\"onHourChange($event)\"\n                                    [selectedHour]=\"selectedHour | async\"\n                                    [period]=\"selectedPeriod | async\"\n                                    [minTime]=\"data.minTime\"\n                                    [maxTime]=\"data.maxTime\"\n                                    (hourSelected)=\"onHourSelected($event)\"></ngx-mat-timepicker-12-hours-face>\n                        </ng-template>\n                    </div>\n                    <ngx-mat-timepicker-minutes-face *ngSwitchCase=\"timeUnit.MINUTE\"\n                                                     [color]=\"color\"\n                                                     [selectedMinute]=\"selectedMinute | async\"\n                                                     [selectedHour]=\"(selectedHour | async)?.time\"\n                                                     [minTime]=\"data.minTime\"\n                                                     [maxTime]=\"data.maxTime\"\n                                                     [format]=\"data.format\"\n                                                     [period]=\"selectedPeriod | async\"\n                                                     [minutesGap]=\"data.minutesGap\"\n                                                     (minuteChange)=\"onMinuteChange($event)\"></ngx-mat-timepicker-minutes-face>\n                </div>\n            </div>\n        </div>\n    </ngx-mat-timepicker-content>\n</div>\n<div mat-dialog-actions>\n    <div (click)=\"close()\">\n        <ng-container\n                *ngTemplateOutlet=\"data.cancelBtnTmpl ? data.cancelBtnTmpl : cancelBtnDefault\"></ng-container>\n    </div>\n    <div (click)=\"setTime()\">\n        <ng-container\n                *ngTemplateOutlet=\"data.confirmBtnTmpl ? data.confirmBtnTmpl : confirmBtnDefault\"></ng-container>\n    </div>\n</div>\n",
                        encapsulation: core.ViewEncapsulation.None,
                        styles: ["div.ngx-mat-timepicker-dialog>mat-dialog-container.mat-dialog-container{padding-top:0}div.ngx-mat-timepicker-dialog>mat-dialog-container.mat-dialog-container .mat-dialog-content{padding:0;max-height:85vh}div.ngx-mat-timepicker-dialog>mat-dialog-container.mat-dialog-container .mat-dialog-content mat-toolbar.timepicker-header{display:flex;justify-content:center;align-items:center}div.ngx-mat-timepicker-dialog>mat-dialog-container.mat-dialog-container .mat-dialog-content .clock-face{margin:16px}div.ngx-mat-timepicker-dialog>mat-dialog-container.mat-dialog-container div[mat-dialog-actions]{justify-content:flex-end;display:flex}"]
                    }] }
        ];
        /** @nocollapse */
        NgxMatTimepickerDialogComponent.ctorParameters = function () { return [
            { type: undefined, decorators: [{ type: core.Inject, args: [dialog.MAT_DIALOG_DATA,] }] },
            { type: dialog.MatDialogRef },
            { type: NgxMatTimepickerService },
            { type: NgxMatTimepickerEventService },
            { type: String, decorators: [{ type: core.Inject, args: [NGX_MAT_TIMEPICKER_LOCALE,] }] }
        ]; };
        return NgxMatTimepickerDialogComponent;
    }(NgxMatTimepickerBaseDirective));

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/components/ngx-mat-timepicker/ngx-mat-timepicker.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var config;
    var NgxMatTimepickerComponent = /** @class */ (function () {
        function NgxMatTimepickerComponent(_vcr, _eventService, _dialog, _overlay, _domService) {
            this._vcr = _vcr;
            this._eventService = _eventService;
            this._dialog = _dialog;
            this._overlay = _overlay;
            this._domService = _domService;
            this.closed = new core.EventEmitter();
            this.hourSelected = new core.EventEmitter();
            this.hoursOnly = false;
            this.id = "ngx_mat_timepicker_" + ++NgxMatTimepickerComponent.nextId;
            this.isEsc = !0;
            this.opened = new core.EventEmitter();
            this.overlayPositions = [
                {
                    originX: "center",
                    originY: "bottom",
                    overlayX: "center",
                    overlayY: "top",
                    offsetY: 0
                },
                {
                    originX: "center",
                    originY: "top",
                    overlayX: "center",
                    overlayY: "bottom",
                    offsetY: 0
                }
            ];
            this.showPicker = !1;
            this.timeChanged = new core.EventEmitter();
            this.timeSet = new core.EventEmitter();
            this.timeUpdated = new rxjs.Subject(); // used in the dialog, check if a better approach can be used
            // used in the dialog, check if a better approach can be used
            this._color = "primary";
        }
        Object.defineProperty(NgxMatTimepickerComponent.prototype, "color", {
            get: /**
             * @return {?}
             */
            function () {
                return this._color;
            },
            set: /**
             * @param {?} newValue
             * @return {?}
             */
            function (newValue) {
                this._color = newValue;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxMatTimepickerComponent.prototype, "disabled", {
            get: /**
             * @return {?}
             */
            function () {
                return this._timepickerInput && this._timepickerInput.disabled;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxMatTimepickerComponent.prototype, "format", {
            get: /**
             * @return {?}
             */
            function () {
                return this._timepickerInput ? this._timepickerInput.format : this._format;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._format = value === 24 ? 24 : 12;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxMatTimepickerComponent.prototype, "inputElement", {
            get: /**
             * @return {?}
             */
            function () {
                return this._timepickerInput && this._timepickerInput.element;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxMatTimepickerComponent.prototype, "maxTime", {
            get: /**
             * @return {?}
             */
            function () {
                return this._timepickerInput ? ((/** @type {?} */ (this._timepickerInput.max))) : this.max;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxMatTimepickerComponent.prototype, "minTime", {
            get: /**
             * @return {?}
             */
            function () {
                return this._timepickerInput ? ((/** @type {?} */ (this._timepickerInput.min))) : this.min;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxMatTimepickerComponent.prototype, "minutesGap", {
            get: /**
             * @return {?}
             */
            function () {
                return this._minutesGap;
            },
            set: /**
             * @param {?} gap
             * @return {?}
             */
            function (gap) {
                if (gap == null) {
                    return;
                }
                gap = Math.floor(gap);
                this._minutesGap = gap <= 59 ? gap : 1;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxMatTimepickerComponent.prototype, "overlayOrigin", {
            get: /**
             * @return {?}
             */
            function () {
                return this._timepickerInput ? this._timepickerInput.cdkOverlayOrigin : void 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxMatTimepickerComponent.prototype, "time", {
            get: /**
             * @return {?}
             */
            function () {
                return this._timepickerInput && this._timepickerInput.value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxMatTimepickerComponent.prototype, "ngxMatTimepickerTheme", {
            set: /**
             * @param {?} newValue
             * @return {?}
             */
            function (newValue) {
                this._ngxMatTimepickerTheme = newValue;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @return {?}
         */
        NgxMatTimepickerComponent.prototype.close = /**
         * @return {?}
         */
        function () {
            if (this.appendToInput) {
                this._overlayRef && this._overlayRef.dispose();
            }
            else {
                this._dialogRef && this._dialogRef.close();
            }
            this.showPicker = !1;
            this.closed.emit();
        };
        /**
         * @return {?}
         */
        NgxMatTimepickerComponent.prototype.open = /**
         * @return {?}
         */
        function () {
            var _this = this;
            config = {
                timepickerBaseRef: this,
                time: this.time,
                defaultTime: this.defaultTime,
                maxTime: this.maxTime,
                minTime: this.minTime,
                format: this.format,
                minutesGap: this.minutesGap,
                disableAnimation: this.disableAnimation,
                cancelBtnTmpl: this.cancelBtnTmpl,
                confirmBtnTmpl: this.confirmBtnTmpl,
                editableHintTmpl: this.editableHintTmpl,
                disabled: this.disabled,
                enableKeyboardInput: this.enableKeyboardInput,
                preventOverlayClick: this.preventOverlayClick,
                appendToInput: this.appendToInput,
                hoursOnly: this.hoursOnly,
                theme: this.theme || this._ngxMatTimepickerTheme,
                timepickerClass: this.timepickerClass,
                inputElement: this.inputElement,
                color: this.color
            };
            if (this.appendToInput) {
                this.showPicker = !0;
            }
            else {
                this._dialogRef = this._dialog.open(NgxMatTimepickerDialogComponent, {
                    panelClass: "ngx-mat-timepicker-dialog",
                    data: __assign({}, config)
                });
                this._dialogRef
                    .afterClosed()
                    .subscribe((/**
                 * @return {?}
                 */
                function () {
                    _this.closed.emit();
                }));
            }
            this.opened.emit();
        };
        /***
         * Register an input with this timepicker.
         * input - The timepicker input to register with this timepicker
         */
        /**
         *
         * Register an input with this timepicker.
         * input - The timepicker input to register with this timepicker
         * @param {?} input
         * @return {?}
         */
        NgxMatTimepickerComponent.prototype.registerInput = /**
         *
         * Register an input with this timepicker.
         * input - The timepicker input to register with this timepicker
         * @param {?} input
         * @return {?}
         */
        function (input) {
            if (this._timepickerInput) {
                throw Error("A Timepicker can only be associated with a single input.");
            }
            this._timepickerInput = input;
        };
        /**
         * @return {?}
         */
        NgxMatTimepickerComponent.prototype.unregisterInput = /**
         * @return {?}
         */
        function () {
            this._timepickerInput = void 0;
        };
        /**
         * @param {?} time
         * @return {?}
         */
        NgxMatTimepickerComponent.prototype.updateTime = /**
         * @param {?} time
         * @return {?}
         */
        function (time) {
            this.timeUpdated.next(time);
        };
        NgxMatTimepickerComponent.nextId = 0;
        NgxMatTimepickerComponent.decorators = [
            { type: core.Component, args: [{
                        selector: "ngx-mat-timepicker",
                        template: "\n\t\t<ng-template\n\t\t\t\tcdkConnectedOverlay\n\t\t\t\t[cdkConnectedOverlayPositions]=\"overlayPositions\"\n\t\t\t\t[cdkConnectedOverlayHasBackdrop]=\"!0\"\n\t\t\t\tcdkConnectedOverlayBackdropClass=\"cdk-overlay-transparent-backdrop\"\n\t\t\t\t(backdropClick)=\"close()\"\n\t\t\t\t[cdkConnectedOverlayOrigin]=\"overlayOrigin\"\n\t\t\t\t[cdkConnectedOverlayOpen]=\"showPicker\">\n\t\t\t<ngx-mat-timepicker-standalone></ngx-mat-timepicker-standalone>\n\t\t</ng-template>",
                        providers: [
                            {
                                provide: NGX_MAT_TIMEPICKER_CONFIG,
                                useFactory: /**
                                 * @return {?}
                                 */
                                function () {
                                    return config;
                                }
                            }
                        ]
                    }] }
        ];
        /** @nocollapse */
        NgxMatTimepickerComponent.ctorParameters = function () { return [
            { type: core.ViewContainerRef },
            { type: NgxMatTimepickerEventService },
            { type: dialog.MatDialog },
            { type: overlay.Overlay },
            { type: smpCoreUtils.SmpDomService }
        ]; };
        NgxMatTimepickerComponent.propDecorators = {
            color: [{ type: core.Input }],
            format: [{ type: core.Input }],
            minutesGap: [{ type: core.Input }],
            appendToInput: [{ type: core.Input }],
            cancelBtnTmpl: [{ type: core.Input }],
            closed: [{ type: core.Output }],
            confirmBtnTmpl: [{ type: core.Input }],
            defaultTime: [{ type: core.Input }],
            disableAnimation: [{ type: core.Input }],
            editableHintTmpl: [{ type: core.Input }],
            enableKeyboardInput: [{ type: core.Input }],
            hourSelected: [{ type: core.Output }],
            hoursOnly: [{ type: core.Input }],
            id: [{ type: core.HostBinding, args: ["id",] }],
            isEsc: [{ type: core.Input }],
            max: [{ type: core.Input }],
            min: [{ type: core.Input }],
            opened: [{ type: core.Output }],
            preventOverlayClick: [{ type: core.Input }],
            theme: [{ type: core.Input }],
            timeChanged: [{ type: core.Output }],
            timepickerClass: [{ type: core.Input }],
            timeSet: [{ type: core.Output }]
        };
        return NgxMatTimepickerComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/components/ngx-mat-timepicker-toggle/ngx-mat-timepicker-toggle.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NgxMatTimepickerToggleComponent = /** @class */ (function () {
        function NgxMatTimepickerToggleComponent() {
        }
        Object.defineProperty(NgxMatTimepickerToggleComponent.prototype, "disabled", {
            get: /**
             * @return {?}
             */
            function () {
                return this._disabled === undefined ? this.timepicker.disabled : this._disabled;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._disabled = value;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @param {?} event
         * @return {?}
         */
        NgxMatTimepickerToggleComponent.prototype.open = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            if (this.timepicker) {
                this.timepicker.open();
                event.stopPropagation();
            }
        };
        NgxMatTimepickerToggleComponent.decorators = [
            { type: core.Component, args: [{
                        selector: "ngx-mat-timepicker-toggle",
                        template: "<button class=\"ngx-mat-timepicker-toggle mat-elevation-z0\"\n        color=\"\"\n        mat-mini-fab\n        (click)=\"open($event)\"\n        [disabled]=\"disabled\"\n        type=\"button\">\n    <svg xmlns=\"http://www.w3.org/2000/svg\"\n         viewBox=\"0 0 24 24\"\n         width=\"24px\"\n         height=\"24px\"\n         *ngIf=\"!customIcon\">\n        <path d=\"M 12 2 C 6.4889971 2 2 6.4889971 2 12 C 2 17.511003                   6.4889971 22 12 22 C 17.511003 22 22 17.511003 22 12 C 22 6.4889971 17.511003 2 12 2 z M 12 4 C 16.430123 4 20 7.5698774 20 12 C 20 16.430123 16.430123 20 12 20 C 7.5698774 20 4 16.430123 4 12 C 4 7.5698774 7.5698774 4 12 4 z M 11 6 L 11 12.414062 L 15.292969 16.707031 L 16.707031 15.292969 L 13 11.585938 L 13 6 L 11 6 z\" />\n    </svg>\n\n    <ng-content select=\"[ngxMatTimepickerToggleIcon]\"></ng-content>\n</button>\n",
                        styles: ["button.ngx-mat-timepicker-toggle{background-color:transparent;text-align:center;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;box-shadow:none}"]
                    }] }
        ];
        NgxMatTimepickerToggleComponent.propDecorators = {
            disabled: [{ type: core.Input }],
            customIcon: [{ type: core.ContentChild, args: [NgxMatTimepickerToggleIconDirective, { static: true },] }],
            timepicker: [{ type: core.Input, args: ["for",] }]
        };
        return NgxMatTimepickerToggleComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/directives/ngx-mat-timepicker.directive.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NgxMatTimepickerDirective = /** @class */ (function () {
        function NgxMatTimepickerDirective(_elementRef, _matFormField, _locale) {
            this._elementRef = _elementRef;
            this._matFormField = _matFormField;
            this._locale = _locale;
            // TODO: IMPROVE DETECTING (INJECT) MAT-FORM-FIELD IF PRESENT
            this.cdkOverlayOrigin = new overlay.CdkOverlayOrigin(this._matFormField ? this._matFormField.getConnectedOverlayOrigin() : this._elementRef);
            this._format = 12;
            this._subsCtrl$ = new rxjs.Subject();
            this._value = "";
            this.onTouched = (/**
             * @return {?}
             */
            function () {
            });
            this._onChange = (/**
             * @return {?}
             */
            function () {
            });
        }
        Object.defineProperty(NgxMatTimepickerDirective.prototype, "element", {
            get: /**
             * @return {?}
             */
            function () {
                return this._elementRef && this._elementRef.nativeElement;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxMatTimepickerDirective.prototype, "format", {
            get: /**
             * @return {?}
             */
            function () {
                return this._format;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._format = +value === 24 ? 24 : 12;
                /** @type {?} */
                var isDynamicallyChanged = value && (this._previousFormat && this._previousFormat !== this._format);
                if (isDynamicallyChanged) {
                    this.value = this._value;
                    this._timepicker.updateTime(this._value);
                }
                this._previousFormat = this._format;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxMatTimepickerDirective.prototype, "max", {
            get: /**
             * @return {?}
             */
            function () {
                return this._max;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (typeof value === "string") {
                    this._max = NgxMatTimepickerAdapter.parseTime(value, { locale: this._locale, format: this.format });
                    return;
                }
                this._max = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxMatTimepickerDirective.prototype, "min", {
            get: /**
             * @return {?}
             */
            function () {
                return this._min;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (typeof value === "string") {
                    this._min = NgxMatTimepickerAdapter.parseTime(value, { locale: this._locale, format: this.format });
                    return;
                }
                this._min = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxMatTimepickerDirective.prototype, "timepicker", {
            set: /**
             * @param {?} picker
             * @return {?}
             */
            function (picker) {
                this._registerTimepicker(picker);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxMatTimepickerDirective.prototype, "value", {
            get: /**
             * @return {?}
             */
            function () {
                if (!this._value) {
                    return "";
                }
                return NgxMatTimepickerAdapter.toLocaleTimeString(this._value, { format: this.format, locale: this._locale });
            },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (!value) {
                    this._value = "";
                    this._updateInputValue();
                    return;
                }
                /** @type {?} */
                var time = NgxMatTimepickerAdapter.formatTime(value, { locale: this._locale, format: this.format });
                /** @type {?} */
                var isAvailable = NgxMatTimepickerAdapter.isTimeAvailable(time, (/** @type {?} */ (this._min)), (/** @type {?} */ (this._max)), "minutes", this._timepicker.minutesGap, this._format);
                if (isAvailable) {
                    this._value = time;
                    this._updateInputValue();
                    return;
                }
                console.warn("Selected time doesn't match min or max value");
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxMatTimepickerDirective.prototype, "_defaultTime", {
            set: /**
             * @private
             * @param {?} time
             * @return {?}
             */
            function (time) {
                this._timepicker.defaultTime = NgxMatTimepickerAdapter.formatTime(time, {
                    locale: this._locale,
                    format: this.format
                });
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @param {?} changes
         * @return {?}
         */
        NgxMatTimepickerDirective.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
        function (changes) {
            if (changes.value && changes.value.currentValue) {
                this._defaultTime = changes.value.currentValue;
            }
        };
        /**
         * @return {?}
         */
        NgxMatTimepickerDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._unregisterTimepicker();
            this._subsCtrl$.next();
            this._subsCtrl$.complete();
        };
        /**
         * @param {?} event
         * @return {?}
         */
        NgxMatTimepickerDirective.prototype.onClick = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            if (!this.disableClick) {
                this._timepicker.open();
                event.stopPropagation();
            }
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        NgxMatTimepickerDirective.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this._onChange = fn;
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        NgxMatTimepickerDirective.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this.onTouched = fn;
        };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        NgxMatTimepickerDirective.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
        function (isDisabled) {
            this.disabled = isDisabled;
        };
        /**
         * @param {?} value
         * @return {?}
         */
        NgxMatTimepickerDirective.prototype.updateValue = /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.value = value;
            this._onChange(value);
        };
        /**
         * @param {?} value
         * @return {?}
         */
        NgxMatTimepickerDirective.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.value = value;
            if (value) {
                this._defaultTime = value;
            }
        };
        /**
         * @private
         * @param {?} picker
         * @return {?}
         */
        NgxMatTimepickerDirective.prototype._registerTimepicker = /**
         * @private
         * @param {?} picker
         * @return {?}
         */
        function (picker) {
            var _this = this;
            if (picker) {
                this._timepicker = picker;
                this._timepicker.registerInput(this);
                this._timepicker.timeSet
                    .pipe(operators.takeUntil(this._subsCtrl$))
                    .subscribe((/**
                 * @param {?} time
                 * @return {?}
                 */
                function (time) {
                    _this.value = time;
                    _this._onChange(_this.value);
                    _this.onTouched();
                    _this._defaultTime = _this._value;
                }));
            }
            else {
                throw new Error("NgxMatTimepickerComponent is not defined." +
                    " Please make sure you passed the timepicker to ngxMatTimepicker directive");
            }
        };
        /**
         * @private
         * @return {?}
         */
        NgxMatTimepickerDirective.prototype._unregisterTimepicker = /**
         * @private
         * @return {?}
         */
        function () {
            if (this._timepicker) {
                this._timepicker.unregisterInput();
            }
        };
        /**
         * @private
         * @return {?}
         */
        NgxMatTimepickerDirective.prototype._updateInputValue = /**
         * @private
         * @return {?}
         */
        function () {
            this._elementRef.nativeElement.value = this.value;
        };
        NgxMatTimepickerDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: "[ngxMatTimepicker]",
                        providers: [
                            {
                                provide: forms.NG_VALUE_ACCESSOR,
                                useExisting: NgxMatTimepickerDirective,
                                multi: true
                            }
                        ],
                        // tslint:disable-next-line:no-host-metadata-property
                        host: {
                            "[disabled]": "disabled",
                            "(blur)": "onTouched()",
                        },
                    },] }
        ];
        /** @nocollapse */
        NgxMatTimepickerDirective.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: formField.MatFormField, decorators: [{ type: core.Optional }, { type: core.Inject, args: [formField.MatFormField,] }] },
            { type: String, decorators: [{ type: core.Inject, args: [NGX_MAT_TIMEPICKER_LOCALE,] }] }
        ]; };
        NgxMatTimepickerDirective.propDecorators = {
            format: [{ type: core.Input }],
            max: [{ type: core.Input }],
            min: [{ type: core.Input }],
            timepicker: [{ type: core.Input, args: ["ngxMatTimepicker",] }],
            value: [{ type: core.Input }],
            cdkOverlayOrigin: [{ type: core.HostBinding, args: ["attr.cdkOverlayOrigin",] }],
            disableClick: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            onClick: [{ type: core.HostListener, args: ["click", ["$event"],] }],
            updateValue: [{ type: core.HostListener, args: ["change", ["$event"],] }]
        };
        return NgxMatTimepickerDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/directives/ngx-mat-timepicker-theme.directive.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NgxMatTimepickerThemeDirective = /** @class */ (function () {
        function NgxMatTimepickerThemeDirective(elementRef) {
            this._element = elementRef.nativeElement;
        }
        /**
         * @return {?}
         */
        NgxMatTimepickerThemeDirective.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            if (this.theme) {
                this.setTheme(this.theme);
            }
        };
        /**
         * @private
         * @param {?} theme
         * @return {?}
         */
        NgxMatTimepickerThemeDirective.prototype.setTheme = /**
         * @private
         * @param {?} theme
         * @return {?}
         */
        function (theme) {
            for (var val in theme) {
                if (theme.hasOwnProperty(val)) {
                    if (typeof theme[val] === "string") {
                        for (var prop in theme) {
                            if (theme.hasOwnProperty(prop)) {
                                this._element.style.setProperty("--" + camelCaseToDash(prop), theme[prop]);
                            }
                        }
                        return;
                    }
                    this.setTheme(theme[val]);
                }
            }
        };
        NgxMatTimepickerThemeDirective.decorators = [
            { type: core.Directive, args: [{ selector: "[ngxMatTimepickerTheme]" },] }
        ];
        /** @nocollapse */
        NgxMatTimepickerThemeDirective.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        NgxMatTimepickerThemeDirective.propDecorators = {
            theme: [{ type: core.Input, args: ["ngxMatTimepickerTheme",] }]
        };
        return NgxMatTimepickerThemeDirective;
    }());
    /**
     * @param {?} myStr
     * @return {?}
     */
    function camelCaseToDash(myStr) {
        return myStr.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/components/ngx-mat-timepicker-hours-face/ngx-mat-timepicker-hours-face.directive.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NgxMatTimepickerHoursFaceDirective = /** @class */ (function () {
        function NgxMatTimepickerHoursFaceDirective() {
            this.hourChange = new core.EventEmitter();
            this.hourSelected = new core.EventEmitter();
            this.hoursList = [];
            this._color = "primary";
            this._format = 24;
        }
        Object.defineProperty(NgxMatTimepickerHoursFaceDirective.prototype, "color", {
            get: /**
             * @return {?}
             */
            function () {
                return this._color;
            },
            set: /**
             * @param {?} newValue
             * @return {?}
             */
            function (newValue) {
                this._color = newValue;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxMatTimepickerHoursFaceDirective.prototype, "format", {
            get: /**
             * @return {?}
             */
            function () {
                return this._format;
            },
            set: /**
             * @param {?} newValue
             * @return {?}
             */
            function (newValue) {
                this._format = newValue;
                this.hoursList = NgxMatTimepickerUtils.getHours(this._format);
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @param {?} time
         * @return {?}
         */
        NgxMatTimepickerHoursFaceDirective.prototype.onTimeSelected = /**
         * @param {?} time
         * @return {?}
         */
        function (time) {
            this.hourSelected.next(time);
        };
        NgxMatTimepickerHoursFaceDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: "[ngxMatTimepickerHoursFace]"
                    },] }
        ];
        /** @nocollapse */
        NgxMatTimepickerHoursFaceDirective.ctorParameters = function () { return []; };
        NgxMatTimepickerHoursFaceDirective.propDecorators = {
            color: [{ type: core.Input }],
            format: [{ type: core.Input }],
            hourChange: [{ type: core.Output }],
            hourSelected: [{ type: core.Output }],
            maxTime: [{ type: core.Input }],
            minTime: [{ type: core.Input }],
            selectedHour: [{ type: core.Input }]
        };
        return NgxMatTimepickerHoursFaceDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/components/ngx-mat-timepicker-24-hours-face/ngx-mat-timepicker-24-hours-face.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NgxMatTimepicker24HoursFaceComponent = /** @class */ (function (_super) {
        __extends(NgxMatTimepicker24HoursFaceComponent, _super);
        function NgxMatTimepicker24HoursFaceComponent() {
            var _this = _super.call(this) || this;
            _this.format = 24;
            return _this;
        }
        /**
         * @return {?}
         */
        NgxMatTimepicker24HoursFaceComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            this.hoursList = NgxMatTimepickerUtils.disableHours(this.hoursList, {
                min: this.minTime,
                max: this.maxTime,
                format: this.format
            });
        };
        NgxMatTimepicker24HoursFaceComponent.decorators = [
            { type: core.Component, args: [{
                        selector: "ngx-mat-timepicker-24-hours-face",
                        template: "<ngx-mat-timepicker-face [color]=\"color\"\n                     [selectedTime]=\"selectedHour\"\n                     [faceTime]=\"hoursList\"\n                     [format]=\"format\"\n                     (timeChange)=\"hourChange.next($event)\"\n                     (timeSelected)=\"onTimeSelected($event)\"></ngx-mat-timepicker-face>\n",
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        NgxMatTimepicker24HoursFaceComponent.ctorParameters = function () { return []; };
        return NgxMatTimepicker24HoursFaceComponent;
    }(NgxMatTimepickerHoursFaceDirective));

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/components/ngx-mat-timepicker-12-hours-face/ngx-mat-timepicker-12-hours-face.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NgxMatTimepicker12HoursFaceComponent = /** @class */ (function (_super) {
        __extends(NgxMatTimepicker12HoursFaceComponent, _super);
        function NgxMatTimepicker12HoursFaceComponent() {
            var _this = _super.call(this) || this;
            _this.format = 12;
            return _this;
        }
        /**
         * @param {?} changes
         * @return {?}
         */
        NgxMatTimepicker12HoursFaceComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
        function (changes) {
            if (changes.period && changes.period.currentValue) {
                this.hoursList = NgxMatTimepickerUtils.disableHours(this.hoursList, {
                    min: this.minTime,
                    max: this.maxTime,
                    format: this.format,
                    period: this.period
                });
            }
        };
        NgxMatTimepicker12HoursFaceComponent.decorators = [
            { type: core.Component, args: [{
                        selector: "ngx-mat-timepicker-12-hours-face",
                        template: "<ngx-mat-timepicker-face [color]=\"color\"\n                     [selectedTime]=\"selectedHour\"\n                     [faceTime]=\"hoursList\"\n                     (timeChange)=\"hourChange.next($event)\"\n                     (timeSelected)=\"onTimeSelected($event)\"></ngx-mat-timepicker-face>\n",
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        NgxMatTimepicker12HoursFaceComponent.ctorParameters = function () { return []; };
        NgxMatTimepicker12HoursFaceComponent.propDecorators = {
            period: [{ type: core.Input }]
        };
        return NgxMatTimepicker12HoursFaceComponent;
    }(NgxMatTimepickerHoursFaceDirective));

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/components/ngx-mat-timepicker-minutes-face/ngx-mat-timepicker-minutes-face.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NgxMatTimepickerMinutesFaceComponent = /** @class */ (function () {
        function NgxMatTimepickerMinutesFaceComponent() {
            this.minuteChange = new core.EventEmitter();
            this.minutesList = [];
            this.timeUnit = NgxMatTimepickerUnits;
            this._color = "primary";
        }
        Object.defineProperty(NgxMatTimepickerMinutesFaceComponent.prototype, "color", {
            get: /**
             * @return {?}
             */
            function () {
                return this._color;
            },
            set: /**
             * @param {?} newValue
             * @return {?}
             */
            function (newValue) {
                this._color = newValue;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @param {?} changes
         * @return {?}
         */
        NgxMatTimepickerMinutesFaceComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
        function (changes) {
            if (changes.period && changes.period.currentValue) {
                /** @type {?} */
                var minutes = NgxMatTimepickerUtils.getMinutes(this.minutesGap);
                this.minutesList = NgxMatTimepickerUtils.disableMinutes(minutes, this.selectedHour, {
                    min: this.minTime,
                    max: this.maxTime,
                    format: this.format,
                    period: this.period
                });
            }
        };
        NgxMatTimepickerMinutesFaceComponent.decorators = [
            { type: core.Component, args: [{
                        selector: "ngx-mat-timepicker-minutes-face",
                        template: "<ngx-mat-timepicker-face [color]=\"color\"\n                     [faceTime]=\"minutesList\"\n                     [selectedTime]=\"selectedMinute\"\n                     [minutesGap]=\"minutesGap\"\n                     (timeChange)=\"minuteChange.next($event)\"\n                     [unit]=\"timeUnit.MINUTE\"></ngx-mat-timepicker-face>\n"
                    }] }
        ];
        /** @nocollapse */
        NgxMatTimepickerMinutesFaceComponent.ctorParameters = function () { return []; };
        NgxMatTimepickerMinutesFaceComponent.propDecorators = {
            color: [{ type: core.Input }],
            format: [{ type: core.Input }],
            maxTime: [{ type: core.Input }],
            minTime: [{ type: core.Input }],
            minuteChange: [{ type: core.Output }],
            minutesGap: [{ type: core.Input }],
            period: [{ type: core.Input }],
            selectedHour: [{ type: core.Input }],
            selectedMinute: [{ type: core.Input }]
        };
        return NgxMatTimepickerMinutesFaceComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/components/ngx-mat-timepicker-face/ngx-mat-timepicker-face.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} angle
     * @param {?} step
     * @return {?}
     */
    function roundAngle(angle, step) {
        return Math.round(angle / step) * step;
    }
    /**
     * @param {?} x0
     * @param {?} y0
     * @param {?} x
     * @param {?} y
     * @param {?} currentAngle
     * @return {?}
     */
    function countAngleByCords(x0, y0, x, y, currentAngle) {
        if (y > y0 && x >= x0) { // II quarter
            return 180 - currentAngle;
        }
        else if (y > y0 && x < x0) { // III quarter
            return 180 + currentAngle;
        }
        else if (y < y0 && x < x0) { // IV quarter
            return 360 - currentAngle;
        }
        else { // I quarter
            return currentAngle;
        }
    }
    /** @type {?} */
    var CLOCK_HAND_STYLES = {
        small: {
            height: "75px",
            top: "calc(50% - 75px)"
        },
        large: {
            height: "103px",
            top: "calc(50% - 103px)"
        }
    };
    var NgxMatTimepickerFaceComponent = /** @class */ (function () {
        function NgxMatTimepickerFaceComponent() {
            this.color = "primary";
            this.innerClockFaceSize = 85;
            this.timeChange = new core.EventEmitter();
            this.timeSelected = new core.EventEmitter();
            this.timeUnit = NgxMatTimepickerUnits;
        }
        /**
         * @return {?}
         */
        NgxMatTimepickerFaceComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            this._setClockHandPosition();
            this._addTouchEvents();
        };
        /**
         * @param {?} changes
         * @return {?}
         */
        NgxMatTimepickerFaceComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
        function (changes) {
            var _this = this;
            /** @type {?} */
            var faceTimeChanges = changes.faceTime;
            /** @type {?} */
            var selectedTimeChanges = changes.selectedTime;
            if ((faceTimeChanges && faceTimeChanges.currentValue)
                && (selectedTimeChanges && selectedTimeChanges.currentValue)) {
                /* Set time according to passed an input value */
                this.selectedTime = this.faceTime.find((/**
                 * @param {?} time
                 * @return {?}
                 */
                function (time) { return time.time === _this.selectedTime.time; }));
            }
            if (selectedTimeChanges && selectedTimeChanges.currentValue) {
                this._setClockHandPosition();
            }
            if (faceTimeChanges && faceTimeChanges.currentValue) {
                // To avoid an error ExpressionChangedAfterItHasBeenCheckedError
                setTimeout((/**
                 * @return {?}
                 */
                function () { return _this._selectAvailableTime(); }));
            }
        };
        /**
         * @return {?}
         */
        NgxMatTimepickerFaceComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._removeTouchEvents();
        };
        /**
         * @param {?} e
         * @return {?}
         */
        NgxMatTimepickerFaceComponent.prototype.onMousedown = /**
         * @param {?} e
         * @return {?}
         */
        function (e) {
            e.preventDefault();
            this._isStarted = true;
        };
        /**
         * @param {?} e
         * @return {?}
         */
        NgxMatTimepickerFaceComponent.prototype.onMouseup = /**
         * @param {?} e
         * @return {?}
         */
        function (e) {
            e.preventDefault();
            this._isStarted = false;
        };
        /**
         * @param {?} e
         * @return {?}
         */
        NgxMatTimepickerFaceComponent.prototype.selectTime = /**
         * @param {?} e
         * @return {?}
         */
        function (e) {
            if (!this._isStarted && (e instanceof MouseEvent && e.type !== "click")) {
                return;
            }
            /** @type {?} */
            var clockFaceCords = this.clockFace.nativeElement.getBoundingClientRect();
            /* Get x0 and y0 of the circle */
            /** @type {?} */
            var centerX = clockFaceCords.left + clockFaceCords.width / 2;
            /** @type {?} */
            var centerY = clockFaceCords.top + clockFaceCords.height / 2;
            /* Counting the arctangent and convert it to from radian to deg */
            /** @type {?} */
            var arctangent = Math.atan(Math.abs(e.clientX - centerX) / Math.abs(e.clientY - centerY)) * 180 / Math.PI;
            /* Get angle according to quadrant */
            /** @type {?} */
            var circleAngle = countAngleByCords(centerX, centerY, e.clientX, e.clientY, arctangent);
            /* Check if selected time from the inner clock face (24 hours format only) */
            /** @type {?} */
            var isInnerClockChosen = this.format && this._isInnerClockFace(centerX, centerY, e.clientX, e.clientY);
            /* Round angle according to angle step */
            /** @type {?} */
            var angleStep = this.unit === NgxMatTimepickerUnits.MINUTE ? (6 * (this.minutesGap || 1)) : 30;
            /** @type {?} */
            var roundedAngle = roundAngle(circleAngle, angleStep);
            /** @type {?} */
            var angle = (roundedAngle || 360) + (isInnerClockChosen ? 360 : 0);
            /** @type {?} */
            var selectedTime = this.faceTime.find((/**
             * @param {?} val
             * @return {?}
             */
            function (val) { return val.angle === angle; }));
            if (selectedTime && !selectedTime.disabled) {
                this.timeChange.next(selectedTime);
                /* To let know whether user ended interaction with clock face */
                if (!this._isStarted) {
                    this.timeSelected.next(selectedTime.time);
                }
            }
        };
        /**
         * @param {?} _item_
         * @param {?} time
         * @return {?}
         */
        NgxMatTimepickerFaceComponent.prototype.trackByTime = /**
         * @param {?} _item_
         * @param {?} time
         * @return {?}
         */
        function (_item_, time) {
            return time.time;
        };
        /**
         * @private
         * @return {?}
         */
        NgxMatTimepickerFaceComponent.prototype._addTouchEvents = /**
         * @private
         * @return {?}
         */
        function () {
            this._touchStartHandler = this.onMousedown.bind(this);
            this._touchEndHandler = this.onMouseup.bind(this);
            this.clockFace.nativeElement.addEventListener("touchstart", this._touchStartHandler);
            this.clockFace.nativeElement.addEventListener("touchend", this._touchEndHandler);
        };
        /**
         * @private
         * @return {?}
         */
        NgxMatTimepickerFaceComponent.prototype._decreaseClockHand = /**
         * @private
         * @return {?}
         */
        function () {
            this.clockHand.nativeElement.style.height = CLOCK_HAND_STYLES.small.height;
            this.clockHand.nativeElement.style.top = CLOCK_HAND_STYLES.small.top;
        };
        /**
         * @private
         * @return {?}
         */
        NgxMatTimepickerFaceComponent.prototype._increaseClockHand = /**
         * @private
         * @return {?}
         */
        function () {
            this.clockHand.nativeElement.style.height = CLOCK_HAND_STYLES.large.height;
            this.clockHand.nativeElement.style.top = CLOCK_HAND_STYLES.large.top;
        };
        /**
         * @private
         * @param {?} x0
         * @param {?} y0
         * @param {?} x
         * @param {?} y
         * @return {?}
         */
        NgxMatTimepickerFaceComponent.prototype._isInnerClockFace = /**
         * @private
         * @param {?} x0
         * @param {?} y0
         * @param {?} x
         * @param {?} y
         * @return {?}
         */
        function (x0, y0, x, y) {
            /* Detect whether time from the inner clock face or not (24 format only) */
            return Math.sqrt(Math.pow(x - x0, 2) + Math.pow(y - y0, 2)) < this.innerClockFaceSize;
        };
        /**
         * @private
         * @return {?}
         */
        NgxMatTimepickerFaceComponent.prototype._removeTouchEvents = /**
         * @private
         * @return {?}
         */
        function () {
            this.clockFace.nativeElement.removeEventListener("touchstart", this._touchStartHandler);
            this.clockFace.nativeElement.removeEventListener("touchend", this._touchEndHandler);
        };
        /**
         * @private
         * @return {?}
         */
        NgxMatTimepickerFaceComponent.prototype._selectAvailableTime = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            /** @type {?} */
            var currentTime = this.faceTime.find((/**
             * @param {?} time
             * @return {?}
             */
            function (time) { return _this.selectedTime.time === time.time; }));
            this.isClockFaceDisabled = this.faceTime.every((/**
             * @param {?} time
             * @return {?}
             */
            function (time) { return time.disabled; }));
            if ((currentTime && currentTime.disabled) && !this.isClockFaceDisabled) {
                /** @type {?} */
                var availableTime = this.faceTime.find((/**
                 * @param {?} time
                 * @return {?}
                 */
                function (time) { return !time.disabled; }));
                this.timeChange.next(availableTime);
            }
        };
        /**
         * @private
         * @return {?}
         */
        NgxMatTimepickerFaceComponent.prototype._setClockHandPosition = /**
         * @private
         * @return {?}
         */
        function () {
            if (this.format === 24) {
                if (this.selectedTime.time > 12 || this.selectedTime.time === 0) {
                    this._decreaseClockHand();
                }
                else {
                    this._increaseClockHand();
                }
            }
            this.clockHand.nativeElement.style.transform = "rotate(" + this.selectedTime.angle + "deg)";
        };
        NgxMatTimepickerFaceComponent.decorators = [
            { type: core.Component, args: [{
                        selector: "ngx-mat-timepicker-face",
                        template: "<ng-template #hourButton\n             let-time>\n    <button mat-mini-fab\n            class=\"mat-elevation-z0\"\n            [color]=\"(time.time | activeHour: selectedTime?.time : isClockFaceDisabled) ? color : undefined\"\n            [ngStyle]=\"{'transform': 'rotateZ(-'+ time.angle +'deg)'}\"\n            [disabled]=\"time.disabled\">\n        {{time.time | timeLocalizer: timeUnit.HOUR}}\n    </button>\n</ng-template>\n<div class=\"clock-face\"\n     #clockFace>\n    <div *ngIf=\"unit !== timeUnit.MINUTE;else minutesFace\"\n         class=\"clock-face__container\">\n        <div class=\"clock-face__number clock-face__number--outer\"\n             [ngStyle]=\"{'transform': 'rotateZ('+ time.angle +'deg)'}\"\n             *ngFor=\"let time of faceTime | slice: 0 : 12; trackBy: trackByTime\">\n            <ng-content *ngTemplateOutlet=\"hourButton; context: {$implicit: time}\"></ng-content>\n        </div>\n        <div class=\"clock-face__inner\"\n             *ngIf=\"faceTime.length > 12\">\n            <div class=\"clock-face__number clock-face__number--inner\"\n                 [style.top]=\"'calc(50% - ' + innerClockFaceSize + 'px)'\"\n                 [ngStyle]=\"{'transform': 'rotateZ('+ time.angle +'deg)'}\"\n                 [style.height.px]=\"innerClockFaceSize\"\n                 *ngFor=\"let time of faceTime | slice: 12 : 24; trackBy: trackByTime\">\n                <ng-content *ngTemplateOutlet=\"hourButton; context: {$implicit: time}\"></ng-content>\n            </div>\n        </div>\n    </div>\n    <mat-toolbar class=\"clock-face__clock-hand\"\n                 [color]=\"color\"\n                 [ngClass]=\"{'clock-face__clock-hand_minute': unit === timeUnit.MINUTE}\"\n                 #clockHand\n                 [hidden]=\"isClockFaceDisabled\">\n        <button mat-mini-fab\n                *ngIf=\"unit === timeUnit.MINUTE\"\n                [color]=\"color\">\n            <span class=\"clock-face__clock-hand_minute_dot\"></span>\n        </button>\n    </mat-toolbar>\n    <mat-toolbar class=\"clock-face__center\"\n                 [color]=\"color\"></mat-toolbar>\n</div>\n<ng-template #minutesFace>\n    <div class=\"clock-face__container\">\n        <div class=\"clock-face__number clock-face__number--outer\"\n             [ngStyle]=\"{'transform': 'rotateZ('+ time.angle +'deg)'}\"\n             *ngFor=\"let time of faceTime; trackBy: trackByTime\">\n            <button mat-mini-fab\n                    class=\"mat-elevation-z0\"\n                    [disableRipple]=\"time.time % minutesGap !== 0\"\n                    [color]=\"(time.time | activeMinute: selectedTime?.time:minutesGap:isClockFaceDisabled) ? color : undefined\"\n                    [ngStyle]=\"{'transform': 'rotateZ(-'+ time.angle +'deg)'}\">\n                {{time.time | minutesFormatter: minutesGap | timeLocalizer: timeUnit.MINUTE}}\n            </button>\n        </div>\n    </div>\n</ng-template>\n",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        styles: [".clock-face{width:290px;height:290px;border-radius:50%;position:relative;display:flex;justify-content:center;box-sizing:border-box;background-color:rgba(200,200,200,.5)!important}.clock-face__inner{position:absolute;top:0;left:0;width:100%;height:100%}.clock-face [mat-mini-fab]{box-shadow:none}.clock-face [mat-mini-fab]:not(.mat-primary):not(.mat-accent):not(.mat-warn){background:0 0}.clock-face__container{margin-left:-2px}.clock-face__number{position:absolute;transform-origin:25px 100%;width:50px;text-align:center;z-index:2;top:calc(50% - 125px);left:calc(50% - 25px)}.clock-face__number--outer{height:calc(290px / 2 - 20px)}.clock-face__number--outer>span{font-size:16px}.clock-face__number--inner>span{font-size:14px}.clock-face__clock-hand{height:103px;width:2px;padding:0;transform-origin:1px 100%;position:absolute;top:calc(50% - 103px);z-index:1}.clock-face__center{width:8px;height:8px;padding:0;position:absolute;border-radius:50%;top:50%;left:50%;margin:-4px}.clock-face__clock-hand_minute>button{position:absolute;top:-22px;left:calc(50% - 20px);box-sizing:content-box;display:flex;justify-content:center;align-items:center}.clock-face__clock-hand_minute>button .clock-face__clock-hand_minute_dot{display:block;width:4px;height:4px;background:#fff;border-radius:50%}@media (max-device-width:1023px) and (orientation:landscape){.clock-face{width:250px;height:250px}}@media screen and (max-width:360px){.clock-face{width:250px;height:250px}}"]
                    }] }
        ];
        NgxMatTimepickerFaceComponent.propDecorators = {
            clockFace: [{ type: core.ViewChild, args: ["clockFace", { static: true },] }],
            clockHand: [{ type: core.ViewChild, args: ["clockHand", { static: true, read: core.ElementRef },] }],
            color: [{ type: core.Input }],
            faceTime: [{ type: core.Input }],
            format: [{ type: core.Input }],
            minutesGap: [{ type: core.Input }],
            selectedTime: [{ type: core.Input }],
            timeChange: [{ type: core.Output }],
            timeSelected: [{ type: core.Output }],
            unit: [{ type: core.Input }],
            onMousedown: [{ type: core.HostListener, args: ["mousedown", ["$event"],] }],
            onMouseup: [{ type: core.HostListener, args: ["mouseup", ["$event"],] }],
            selectTime: [{ type: core.HostListener, args: ["click", ["$event"],] }, { type: core.HostListener, args: ["touchmove", ["$event.changedTouches[0]"],] }, { type: core.HostListener, args: ["touchend", ["$event.changedTouches[0]"],] }, { type: core.HostListener, args: ["mousemove", ["$event"],] }]
        };
        return NgxMatTimepickerFaceComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/components/ngx-mat-timepicker-dial/ngx-mat-timepicker-dial.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NgxMatTimepickerDialComponent = /** @class */ (function () {
        function NgxMatTimepickerDialComponent(_locale) {
            this._locale = _locale;
            this.hourChanged = new core.EventEmitter();
            this.meridiems = tsLuxon.Info.meridiems({ locale: this._locale });
            this.minuteChanged = new core.EventEmitter();
            this.periodChanged = new core.EventEmitter();
            this.timeUnit = NgxMatTimepickerUnits;
            this.timeUnitChanged = new core.EventEmitter();
            this._color = "primary";
        }
        Object.defineProperty(NgxMatTimepickerDialComponent.prototype, "color", {
            get: /**
             * @return {?}
             */
            function () {
                return this._color;
            },
            set: /**
             * @param {?} newValue
             * @return {?}
             */
            function (newValue) {
                this._color = newValue;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @param {?} hour
         * @return {?}
         */
        NgxMatTimepickerDialComponent.prototype.changeHour = /**
         * @param {?} hour
         * @return {?}
         */
        function (hour) {
            this.hourChanged.next(hour);
        };
        /**
         * @param {?} minute
         * @return {?}
         */
        NgxMatTimepickerDialComponent.prototype.changeMinute = /**
         * @param {?} minute
         * @return {?}
         */
        function (minute) {
            this.minuteChanged.next(minute);
        };
        /**
         * @param {?} period
         * @return {?}
         */
        NgxMatTimepickerDialComponent.prototype.changePeriod = /**
         * @param {?} period
         * @return {?}
         */
        function (period) {
            this.periodChanged.next(period);
        };
        /**
         * @param {?} unit
         * @return {?}
         */
        NgxMatTimepickerDialComponent.prototype.changeTimeUnit = /**
         * @param {?} unit
         * @return {?}
         */
        function (unit) {
            this.timeUnitChanged.next(unit);
        };
        /**
         * @return {?}
         */
        NgxMatTimepickerDialComponent.prototype.hideHint = /**
         * @return {?}
         */
        function () {
            this.isHintVisible = false;
        };
        /**
         * @param {?} changes
         * @return {?}
         */
        NgxMatTimepickerDialComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
        function (changes) {
            /** @type {?} */
            var periodChanged = changes.period && changes.period.currentValue;
            if (periodChanged || changes.format && changes.format.currentValue) {
                /** @type {?} */
                var hours = NgxMatTimepickerUtils.getHours(this.format);
                this.hours = NgxMatTimepickerUtils.disableHours(hours, {
                    min: this.minTime,
                    max: this.maxTime,
                    format: this.format,
                    period: this.period
                });
            }
            if (periodChanged || changes.hour && changes.hour.currentValue) {
                /** @type {?} */
                var minutes = NgxMatTimepickerUtils.getMinutes(this.minutesGap);
                this.minutes = NgxMatTimepickerUtils.disableMinutes(minutes, +this.hour, {
                    min: this.minTime,
                    max: this.maxTime,
                    format: this.format,
                    period: this.period
                });
            }
        };
        /**
         * @return {?}
         */
        NgxMatTimepickerDialComponent.prototype.showHint = /**
         * @return {?}
         */
        function () {
            this.isHintVisible = true;
        };
        NgxMatTimepickerDialComponent.decorators = [
            { type: core.Component, args: [{
                        selector: "ngx-mat-timepicker-dial",
                        template: "<div class=\"timepicker-dial\">\n    <div class=\"timepicker-dial__container\">\n        <div class=\"timepicker-dial__time\">\n            <ngx-mat-timepicker-dial-control [timeList]=\"hours\"\n                                         [time]=\"hour\"\n                                         [timeUnit]=\"timeUnit.HOUR\"\n                                         [isActive]=\"activeTimeUnit === timeUnit.HOUR\"\n                                         [isEditable]=\"isEditable\"\n                                         (timeUnitChanged)=\"changeTimeUnit($event)\"\n                                         (timeChanged)=\"changeHour($event)\"\n                                         (focused)=\"showHint()\"\n                                         (unfocused)=\"hideHint()\">\n\n            </ngx-mat-timepicker-dial-control>\n            <span>:</span>\n            <ngx-mat-timepicker-dial-control [timeList]=\"minutes\"\n                                         [time]=\"minute\"\n                                         [timeUnit]=\"timeUnit.MINUTE\"\n                                         [isActive]=\"activeTimeUnit === timeUnit.MINUTE\"\n                                         [isEditable]=\"isEditable\"\n                                         [minutesGap]=\"minutesGap\"\n                                         [disabled]=\"hoursOnly\"\n                                         (timeUnitChanged)=\"changeTimeUnit($event)\"\n                                         (timeChanged)=\"changeMinute($event)\"\n                                         (focused)=\"showHint()\"\n                                         (unfocused)=\"hideHint()\">\n\n            </ngx-mat-timepicker-dial-control>\n        </div>\n        <ngx-mat-timepicker-period class=\"timepicker-dial__period\"\n                                   *ngIf=\"format !== 24\"\n                                   [selectedPeriod]=\"period\"\n                                   [activeTimeUnit]=\"activeTimeUnit\"\n                                   [maxTime]=\"maxTime\"\n                                   [minTime]=\"minTime\"\n                                   [format]=\"format\"\n                                   [hours]=\"hours\"\n                                   [minutes]=\"minutes\"\n                                   [selectedHour]=\"hour\"\n                                   [meridiems]=\"meridiems\"\n                                   (periodChanged)=\"changePeriod($event)\"></ngx-mat-timepicker-period>\n    </div>\n    <div *ngIf=\"isEditable || editableHintTmpl\"\n         [ngClass]=\"{'timepicker-dial__hint-container--hidden': !isHintVisible}\">\n        <ng-container *ngTemplateOutlet=\"editableHintTmpl ? editableHintTmpl : editableHintDefault\"></ng-container>\n        <ng-template #editableHintDefault>\n            <small class=\"timepicker-dial__hint\"> * use arrows (<span>&#8645;</span>) to change the time</small>\n        </ng-template>\n    </div>\n</div>\n",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        styles: [".timepicker-dial{text-align:center}.timepicker-dial__container{display:flex;align-items:center;justify-content:center;-webkit-tap-highlight-color:transparent}.timepicker-dial__time{display:flex;align-items:baseline;line-height:normal;font-size:50px}.timepicker-dial__period{display:block;margin-left:10px}.timepicker-dial__hint-container--hidden{visibility:hidden}.timepicker-dial__hint{display:inline-block;font-size:10px}.timepicker-dial__hint span{font-size:14px}"]
                    }] }
        ];
        /** @nocollapse */
        NgxMatTimepickerDialComponent.ctorParameters = function () { return [
            { type: String, decorators: [{ type: core.Inject, args: [NGX_MAT_TIMEPICKER_LOCALE,] }] }
        ]; };
        NgxMatTimepickerDialComponent.propDecorators = {
            activeTimeUnit: [{ type: core.Input }],
            color: [{ type: core.Input }],
            editableHintTmpl: [{ type: core.Input }],
            format: [{ type: core.Input }],
            hour: [{ type: core.Input }],
            hourChanged: [{ type: core.Output }],
            hoursOnly: [{ type: core.Input }],
            isEditable: [{ type: core.Input }],
            maxTime: [{ type: core.Input }],
            minTime: [{ type: core.Input }],
            minute: [{ type: core.Input }],
            minuteChanged: [{ type: core.Output }],
            minutesGap: [{ type: core.Input }],
            period: [{ type: core.Input }],
            periodChanged: [{ type: core.Output }],
            timeUnitChanged: [{ type: core.Output }]
        };
        return NgxMatTimepickerDialComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/models/ngx-mat-timepicker-measures.enum.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @enum {string} */
    var NgxMatTimepickerMeasure = {
        hour: "hour",
        minute: "minute",
    };

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/pipes/ngx-mat-timepicker-parser.pipe.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NgxMatTimepickerParserPipe = /** @class */ (function () {
        function NgxMatTimepickerParserPipe(_locale) {
            this._locale = _locale;
            this._numberingSystem = (/** @type {?} */ (tsLuxon.DateTime.local().setLocale(this._locale).resolvedLocaleOpts().numberingSystem));
        }
        /**
         * @param {?} time
         * @param {?=} timeUnit
         * @return {?}
         */
        NgxMatTimepickerParserPipe.prototype.transform = /**
         * @param {?} time
         * @param {?=} timeUnit
         * @return {?}
         */
        function (time, timeUnit) {
            if (timeUnit === void 0) { timeUnit = NgxMatTimepickerUnits.HOUR; }
            if (time == null || time === "") {
                return "";
            }
            if (!isNaN(+time)) {
                return "" + time;
            }
            if (timeUnit === NgxMatTimepickerUnits.MINUTE) {
                return this._parseTime(time, "mm", NgxMatTimepickerMeasure.minute).toString();
            }
            return this._parseTime(time, "HH", NgxMatTimepickerMeasure.hour).toString();
        };
        /**
         * @private
         * @param {?} time
         * @param {?} format
         * @param {?} timeMeasure
         * @return {?}
         */
        NgxMatTimepickerParserPipe.prototype._parseTime = /**
         * @private
         * @param {?} time
         * @param {?} format
         * @param {?} timeMeasure
         * @return {?}
         */
        function (time, format, timeMeasure) {
            /** @type {?} */
            var parsedTime = tsLuxon.DateTime.fromFormat(String(time), format, { numberingSystem: this._numberingSystem })[timeMeasure];
            if (!isNaN(parsedTime)) {
                return parsedTime;
            }
            throw new Error("Cannot parse time - " + time);
        };
        NgxMatTimepickerParserPipe.decorators = [
            { type: core.Pipe, args: [{
                        name: "ngxMatTimepickerParser"
                    },] },
            { type: core.Injectable }
        ];
        /** @nocollapse */
        NgxMatTimepickerParserPipe.ctorParameters = function () { return [
            { type: String, decorators: [{ type: core.Inject, args: [NGX_MAT_TIMEPICKER_LOCALE,] }] }
        ]; };
        return NgxMatTimepickerParserPipe;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/components/ngx-mat-timepicker-dial-control/ngx-mat-timepicker-dial-control.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @return {?}
     */
    function retainSelection() {
        this.selectionStart = this.selectionEnd;
    }
    var NgxMatTimepickerDialControlComponent = /** @class */ (function () {
        function NgxMatTimepickerDialControlComponent(_elRef, _timeParserPipe) {
            this._elRef = _elRef;
            this._timeParserPipe = _timeParserPipe;
            this.focused = new core.EventEmitter();
            this.timeChanged = new core.EventEmitter();
            this.timeUnitChanged = new core.EventEmitter();
            this.unfocused = new core.EventEmitter();
        }
        Object.defineProperty(NgxMatTimepickerDialControlComponent.prototype, "_selectedTime", {
            get: /**
             * @private
             * @return {?}
             */
            function () {
                var _this = this;
                if (!!this.time) {
                    return this.timeList.find((/**
                     * @param {?} t
                     * @return {?}
                     */
                    function (t) { return t.time === +_this.time; }));
                }
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @param {?} e
         * @return {?}
         */
        NgxMatTimepickerDialControlComponent.prototype.changeTimeByKeyboard = /**
         * @param {?} e
         * @return {?}
         */
        function (e) {
            /** @type {?} */
            var char = String.fromCharCode(e.keyCode);
            if (isTimeDisabledToChange(this.time, char, this.timeList)) {
                e.preventDefault();
            }
        };
        /**
         * @return {?}
         */
        NgxMatTimepickerDialControlComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            this._elRef.nativeElement.querySelector("input").addEventListener("select", retainSelection, false);
        };
        /**
         * @return {?}
         */
        NgxMatTimepickerDialControlComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._elRef.nativeElement.querySelector("input").removeEventListener("select", retainSelection);
        };
        /**
         * @param {?} e
         * @return {?}
         */
        NgxMatTimepickerDialControlComponent.prototype.onKeydown = /**
         * @param {?} e
         * @return {?}
         */
        function (e) {
            if (!NgxMatTimepickerUtils.isDigit(e)) {
                e.preventDefault();
            }
            else {
                this._changeTimeByArrow(e.keyCode);
            }
        };
        /**
         * @param {?} value
         * @return {?}
         */
        NgxMatTimepickerDialControlComponent.prototype.onModelChange = /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.time = this._timeParserPipe.transform(value, this.timeUnit);
        };
        /**
         * @param {?} event
         * @param {?} unit
         * @return {?}
         */
        NgxMatTimepickerDialControlComponent.prototype.saveTimeAndChangeTimeUnit = /**
         * @param {?} event
         * @param {?} unit
         * @return {?}
         */
        function (event, unit) {
            event.preventDefault();
            this.previousTime = this.time;
            this.timeUnitChanged.next(unit);
            this.focused.next();
        };
        /**
         * @return {?}
         */
        NgxMatTimepickerDialControlComponent.prototype.updateTime = /**
         * @return {?}
         */
        function () {
            if (this._selectedTime) {
                this.timeChanged.next(this._selectedTime);
                this.previousTime = this._selectedTime.time;
            }
        };
        /**
         * @private
         * @param {?} amount
         * @return {?}
         */
        NgxMatTimepickerDialControlComponent.prototype._addTime = /**
         * @private
         * @param {?} amount
         * @return {?}
         */
        function (amount) {
            return ("0" + (+this.time + amount)).substr(-2);
        };
        /**
         * @private
         * @param {?} keyCode
         * @return {?}
         */
        NgxMatTimepickerDialControlComponent.prototype._changeTimeByArrow = /**
         * @private
         * @param {?} keyCode
         * @return {?}
         */
        function (keyCode) {
            /** @type {?} */
            var time;
            // arrow up
            if (keyCode === 38) {
                time = this._addTime(this.minutesGap || 1);
            }
            // arrow down
            else if (keyCode === 40) {
                time = this._addTime(-1 * (this.minutesGap || 1));
            }
            if (!isTimeUnavailable(time, this.timeList)) {
                this.time = time;
                this.updateTime();
            }
        };
        NgxMatTimepickerDialControlComponent.decorators = [
            { type: core.Component, args: [{
                        selector: "ngx-mat-timepicker-dial-control",
                        template: "<input class=\"timepicker-dial__control timepicker-dial__item\"\n       [ngClass]=\"{'active': isActive}\"\n       [ngModel]=\"time | timeLocalizer: timeUnit: true\"\n       (ngModelChange)=\"time = $event\"\n       [disabled]=\"disabled\"\n       (input)=\"updateTime()\"\n       (focus)=\"saveTimeAndChangeTimeUnit($event, timeUnit)\"\n       readonly\n       [ngxMatTimepickerAutofocus]=\"isActive\"\n       *ngIf=\"!isEditable;else editableTemplate\">\n\n<ng-template #editableTemplate>\n    <input class=\"timepicker-dial__control timepicker-dial__item timepicker-dial__control_editable\"\n           [ngClass]=\"{'active': isActive}\"\n           [ngModel]=\"time | ngxMatTimepickerParser: timeUnit | timeLocalizer: timeUnit : true\"\n           (ngModelChange)=\"onModelChange($event)\"\n           [disabled]=\"disabled\"\n           (input)=\"updateTime()\"\n           (focus)=\"saveTimeAndChangeTimeUnit($event, timeUnit)\"\n           [ngxMatTimepickerAutofocus]=\"isActive\"\n           (keydown)=\"onKeydown($event)\"\n           (keypress)=\"changeTimeByKeyboard($event)\">\n</ng-template>\n",
                        providers: [NgxMatTimepickerParserPipe],
                        styles: [".timepicker-dial__control{border:none;background-color:transparent;font-size:50px;width:60px;padding:0;border-radius:3px;text-align:center;color:inherit}.timepicker-dial__control:focus{outline:0;background-color:rgba(0,0,0,.1)}.timepicker-dial__control:disabled{cursor:default}"]
                    }] }
        ];
        /** @nocollapse */
        NgxMatTimepickerDialControlComponent.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: NgxMatTimepickerParserPipe }
        ]; };
        NgxMatTimepickerDialControlComponent.propDecorators = {
            disabled: [{ type: core.Input }],
            focused: [{ type: core.Output }],
            isActive: [{ type: core.Input }],
            isEditable: [{ type: core.Input }],
            minutesGap: [{ type: core.Input }],
            time: [{ type: core.Input }],
            timeChanged: [{ type: core.Output }],
            timeList: [{ type: core.Input }],
            timeUnit: [{ type: core.Input }],
            timeUnitChanged: [{ type: core.Output }],
            unfocused: [{ type: core.Output }]
        };
        return NgxMatTimepickerDialControlComponent;
    }());
    /**
     * @param {?} currentTime
     * @param {?} nextTime
     * @param {?} timeList
     * @return {?}
     */
    function isTimeDisabledToChange(currentTime, nextTime, timeList) {
        /** @type {?} */
        var isNumber = /\d/.test(nextTime);
        if (isNumber) {
            /** @type {?} */
            var time = currentTime + nextTime;
            return isTimeUnavailable(time, timeList);
        }
    }
    /**
     * @param {?} time
     * @param {?} timeList
     * @return {?}
     */
    function isTimeUnavailable(time, timeList) {
        /** @type {?} */
        var selectedTime = timeList.find((/**
         * @param {?} value
         * @return {?}
         */
        function (value) { return value.time === +time; }));
        return !selectedTime || (selectedTime && selectedTime.disabled);
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/components/ngx-mat-timepicker-period/ngx-mat-timepicker-period.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NgxMatTimepickerPeriodComponent = /** @class */ (function () {
        function NgxMatTimepickerPeriodComponent() {
            this.isPeriodAvailable = true;
            this.periodChanged = new core.EventEmitter();
            this.timePeriod = NgxMatTimepickerPeriods;
        }
        /**
         * @return {?}
         */
        NgxMatTimepickerPeriodComponent.prototype.animationDone = /**
         * @return {?}
         */
        function () {
            this.isPeriodAvailable = true;
        };
        /**
         * @param {?} period
         * @return {?}
         */
        NgxMatTimepickerPeriodComponent.prototype.changePeriod = /**
         * @param {?} period
         * @return {?}
         */
        function (period) {
            this.isPeriodAvailable = this._isSwitchPeriodAvailable(period);
            if (this.isPeriodAvailable) {
                this.periodChanged.next(period);
            }
        };
        /**
         * @private
         * @param {?} period
         * @return {?}
         */
        NgxMatTimepickerPeriodComponent.prototype._getDisabledTimeByPeriod = /**
         * @private
         * @param {?} period
         * @return {?}
         */
        function (period) {
            switch (this.activeTimeUnit) {
                case NgxMatTimepickerUnits.HOUR:
                    return NgxMatTimepickerUtils.disableHours(this.hours, {
                        min: this.minTime,
                        max: this.maxTime,
                        format: this.format,
                        period: period
                    });
                case NgxMatTimepickerUnits.MINUTE:
                    return NgxMatTimepickerUtils.disableMinutes(this.minutes, +this.selectedHour, {
                        min: this.minTime,
                        max: this.maxTime,
                        format: this.format,
                        period: period
                    });
                default:
                    throw new Error("no such NgxMatTimepickerUnits");
            }
        };
        /**
         * @private
         * @param {?} period
         * @return {?}
         */
        NgxMatTimepickerPeriodComponent.prototype._isSwitchPeriodAvailable = /**
         * @private
         * @param {?} period
         * @return {?}
         */
        function (period) {
            /** @type {?} */
            var time = this._getDisabledTimeByPeriod(period);
            return !time.every((/**
             * @param {?} t
             * @return {?}
             */
            function (t) { return t.disabled; }));
        };
        NgxMatTimepickerPeriodComponent.decorators = [
            { type: core.Component, args: [{
                        selector: "ngx-mat-timepicker-period",
                        template: "<div class=\"timepicker-period\">\n    <button class=\"timepicker-dial__item timepicker-period__btn\"\n            [ngClass]=\"{'active': selectedPeriod === timePeriod.AM}\"\n            (click)=\"changePeriod(timePeriod.AM)\"\n            type=\"button\">{{meridiems[0]}}</button>\n    <button class=\"timepicker-dial__item timepicker-period__btn\"\n            [ngClass]=\"{'active': selectedPeriod === timePeriod.PM}\"\n            (click)=\"changePeriod(timePeriod.PM)\"\n            type=\"button\">{{meridiems[1]}}</button>\n    <div class=\"timepicker-period__warning\"\n         [@scaleInOut]\n         (@scaleInOut.done)=\"animationDone()\"\n         *ngIf=\"!isPeriodAvailable\">\n        <p>Current time would be invalid in this period.</p>\n    </div>\n</div>\n",
                        animations: [
                            animations.trigger("scaleInOut", [
                                animations.transition(":enter", [
                                    animations.style({ transform: "scale(0)" }),
                                    animations.animate(".2s", animations.style({ transform: "scale(1)" })),
                                    animations.sequence([
                                        animations.animate("3s", animations.style({ opacity: 1 })),
                                        animations.animate(".3s", animations.style({ opacity: 0 }))
                                    ])
                                ])
                            ])
                        ],
                        styles: [".timepicker-period{display:flex;flex-direction:column;position:relative}.timepicker-period__btn{opacity:.5;padding:1px 3px;border:0;background-color:transparent;font-size:18px;font-weight:500;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;outline:0;border-radius:3px;transition:background-color .5s;color:inherit}.timepicker-period__btn.active{opacity:1}.timepicker-period__btn:focus{background-color:rgba(0,0,0,.07)}.timepicker-period__warning{padding:5px 10px;border-radius:3px;background-color:rgba(0,0,0,.55);position:absolute;width:200px;left:-20px;top:40px}.timepicker-period__warning>p{margin:0;font-size:12px}"]
                    }] }
        ];
        NgxMatTimepickerPeriodComponent.propDecorators = {
            activeTimeUnit: [{ type: core.Input }],
            format: [{ type: core.Input }],
            hours: [{ type: core.Input }],
            maxTime: [{ type: core.Input }],
            meridiems: [{ type: core.Input }],
            minTime: [{ type: core.Input }],
            minutes: [{ type: core.Input }],
            periodChanged: [{ type: core.Output }],
            selectedHour: [{ type: core.Input }],
            selectedPeriod: [{ type: core.Input }]
        };
        return NgxMatTimepickerPeriodComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/pipes/ngx-mat-timepicker-time-formatter.pipe.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NgxMatTimepickerTimeFormatterPipe = /** @class */ (function () {
        function NgxMatTimepickerTimeFormatterPipe() {
        }
        /**
         * @param {?} time
         * @param {?} timeUnit
         * @return {?}
         */
        NgxMatTimepickerTimeFormatterPipe.prototype.transform = /**
         * @param {?} time
         * @param {?} timeUnit
         * @return {?}
         */
        function (time, timeUnit) {
            if (time == null || time === '') {
                return time;
            }
            switch (timeUnit) {
                case NgxMatTimepickerUnits.HOUR:
                    return tsLuxon.DateTime.fromObject({ hour: +time }).toFormat("HH");
                case NgxMatTimepickerUnits.MINUTE:
                    return tsLuxon.DateTime.fromObject({ minute: +time }).toFormat("mm");
                default:
                    throw new Error("no such time unit");
            }
        };
        NgxMatTimepickerTimeFormatterPipe.decorators = [
            { type: core.Pipe, args: [{
                        name: "timeFormatter"
                    },] }
        ];
        return NgxMatTimepickerTimeFormatterPipe;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/pipes/ngx-mat-timepicker-minutes-formatter.pipe.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NgxMatTimepickerMinutesFormatterPipe = /** @class */ (function () {
        function NgxMatTimepickerMinutesFormatterPipe() {
        }
        /**
         * @param {?} minute
         * @param {?=} gap
         * @return {?}
         */
        NgxMatTimepickerMinutesFormatterPipe.prototype.transform = /**
         * @param {?} minute
         * @param {?=} gap
         * @return {?}
         */
        function (minute, gap) {
            if (gap === void 0) { gap = 5; }
            if (!minute) {
                return minute;
            }
            return minute % gap === 0 ? minute : '';
        };
        NgxMatTimepickerMinutesFormatterPipe.decorators = [
            { type: core.Pipe, args: [{
                        name: 'minutesFormatter'
                    },] }
        ];
        return NgxMatTimepickerMinutesFormatterPipe;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/directives/ngx-mat-timepicker-autofocus.directive.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NgxMatTimepickerAutofocusDirective = /** @class */ (function () {
        function NgxMatTimepickerAutofocusDirective(_element, document) {
            this._element = _element;
            this.document = document;
            this._activeElement = this.document.activeElement;
        }
        /**
         * @return {?}
         */
        NgxMatTimepickerAutofocusDirective.prototype.ngOnChanges = /**
         * @return {?}
         */
        function () {
            var _this = this;
            if (this.isFocusActive) {
                // To avoid ExpressionChangedAfterItHasBeenCheckedError;
                setTimeout((/**
                 * @return {?}
                 */
                function () { return _this._element.nativeElement.focus({ preventScroll: true }); }));
            }
        };
        /**
         * @return {?}
         */
        NgxMatTimepickerAutofocusDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            var _this = this;
            // To avoid ExpressionChangedAfterItHasBeenCheckedError;
            setTimeout((/**
             * @return {?}
             */
            function () { return _this._activeElement.focus({ preventScroll: true }); }));
        };
        NgxMatTimepickerAutofocusDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: "[ngxMatTimepickerAutofocus]"
                    },] }
        ];
        /** @nocollapse */
        NgxMatTimepickerAutofocusDirective.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [common.DOCUMENT,] }] }
        ]; };
        NgxMatTimepickerAutofocusDirective.propDecorators = {
            isFocusActive: [{ type: core.Input, args: ["ngxMatTimepickerAutofocus",] }]
        };
        return NgxMatTimepickerAutofocusDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/components/ngx-mat-timepicker-field/ngx-mat-timepicker-control/ngx-mat-timepicker-control.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} currentTime
     * @param {?} nextTime
     * @return {?}
     */
    function concatTime(currentTime, nextTime) {
        /** @type {?} */
        var isNumber = /\d/.test(nextTime);
        if (isNumber) {
            /** @type {?} */
            var time = currentTime + nextTime;
            return +time;
        }
    }
    var NgxMatTimepickerControlComponent = /** @class */ (function () {
        function NgxMatTimepickerControlComponent(_timeParser) {
            this._timeParser = _timeParser;
            this.id = NgxMatTimepickerControlComponent.nextId++;
            this.timeChanged = new core.EventEmitter();
            this._color = "primary";
            this._floatLabel = "never";
        }
        Object.defineProperty(NgxMatTimepickerControlComponent.prototype, "color", {
            get: /**
             * @return {?}
             */
            function () {
                return this._color;
            },
            set: /**
             * @param {?} newValue
             * @return {?}
             */
            function (newValue) {
                this._color = newValue;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxMatTimepickerControlComponent.prototype, "floatLabel", {
            get: /**
             * @return {?}
             */
            function () {
                return this._floatLabel;
            },
            set: /**
             * @param {?} newValue
             * @return {?}
             */
            function (newValue) {
                this._floatLabel = newValue;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @param {?} event
         * @return {?}
         */
        NgxMatTimepickerControlComponent.prototype.changeTime = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            event.stopPropagation();
            /** @type {?} */
            var char = String.fromCharCode(event.keyCode);
            /** @type {?} */
            var time = concatTime(String(this.time), char);
            this._changeTimeIfValid(time);
        };
        /**
         * @return {?}
         */
        NgxMatTimepickerControlComponent.prototype.decrease = /**
         * @return {?}
         */
        function () {
            if (!this.disabled) {
                /** @type {?} */
                var previousTime = +this.time - 1;
                if (previousTime < this.min) {
                    previousTime = this.max;
                }
                if (this._isSelectedTimeDisabled(previousTime)) {
                    previousTime = this._getAvailableTime(previousTime, this._getPrevAvailableTime.bind(this));
                }
                if (previousTime !== this.time) {
                    this.timeChanged.emit(previousTime);
                }
            }
        };
        /**
         * @return {?}
         */
        NgxMatTimepickerControlComponent.prototype.increase = /**
         * @return {?}
         */
        function () {
            if (!this.disabled) {
                /** @type {?} */
                var nextTime = +this.time + 1;
                if (nextTime > this.max) {
                    nextTime = this.min;
                }
                if (this._isSelectedTimeDisabled(nextTime)) {
                    nextTime = this._getAvailableTime(nextTime, this._getNextAvailableTime.bind(this));
                }
                if (nextTime !== this.time) {
                    this.timeChanged.emit(nextTime);
                }
            }
        };
        /**
         * @param {?} changes
         * @return {?}
         */
        NgxMatTimepickerControlComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
        function (changes) {
            if (changes.timeList && this.time != null) {
                if (this._isSelectedTimeDisabled(this.time)) {
                    this._setAvailableTime();
                }
            }
        };
        /**
         * @return {?}
         */
        NgxMatTimepickerControlComponent.prototype.onBlur = /**
         * @return {?}
         */
        function () {
            this.isFocused = false;
            if (this._previousTime !== this.time) {
                this._changeTimeIfValid(+this.time);
            }
        };
        /**
         * @return {?}
         */
        NgxMatTimepickerControlComponent.prototype.onFocus = /**
         * @return {?}
         */
        function () {
            this.isFocused = true;
            this._previousTime = this.time;
        };
        /**
         * @param {?} event
         * @return {?}
         */
        NgxMatTimepickerControlComponent.prototype.onKeydown = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            event.stopPropagation();
            if (!NgxMatTimepickerUtils.isDigit(event)) {
                event.preventDefault();
            }
            switch (event.key) {
                case "ArrowUp":
                    this.increase();
                    break;
                case "ArrowDown":
                    this.decrease();
                    break;
            }
            if (this.preventTyping && event.key !== "Tab") {
                event.preventDefault();
            }
        };
        /**
         * @param {?} value
         * @return {?}
         */
        NgxMatTimepickerControlComponent.prototype.onModelChange = /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.time = +this._timeParser.transform(value, this.timeUnit);
        };
        /**
         * @private
         * @param {?} value
         * @return {?}
         */
        NgxMatTimepickerControlComponent.prototype._changeTimeIfValid = /**
         * @private
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (!isNaN(value)) {
                this.time = value;
                if (this.time > this.max) {
                    /** @type {?} */
                    var timeString = String(value);
                    this.time = +timeString[timeString.length - 1];
                }
                if (this.time < this.min) {
                    this.time = this.min;
                }
                this.timeChanged.emit(this.time);
            }
        };
        /**
         * @private
         * @param {?} currentTime
         * @param {?} fn
         * @return {?}
         */
        NgxMatTimepickerControlComponent.prototype._getAvailableTime = /**
         * @private
         * @param {?} currentTime
         * @param {?} fn
         * @return {?}
         */
        function (currentTime, fn) {
            /** @type {?} */
            var currentTimeIndex = this.timeList.findIndex((/**
             * @param {?} time
             * @return {?}
             */
            function (time) { return time.time === currentTime; }));
            /** @type {?} */
            var availableTime = fn(currentTimeIndex);
            return availableTime != null ? availableTime : this.time;
        };
        /**
         * @private
         * @param {?} index
         * @return {?}
         */
        NgxMatTimepickerControlComponent.prototype._getNextAvailableTime = /**
         * @private
         * @param {?} index
         * @return {?}
         */
        function (index) {
            /** @type {?} */
            var timeCollection = this.timeList;
            /** @type {?} */
            var maxValue = timeCollection.length;
            for (var i = index + 1; i < maxValue; i++) {
                /** @type {?} */
                var time = timeCollection[i];
                if (!time.disabled) {
                    return time.time;
                }
            }
        };
        /**
         * @private
         * @param {?} index
         * @return {?}
         */
        NgxMatTimepickerControlComponent.prototype._getPrevAvailableTime = /**
         * @private
         * @param {?} index
         * @return {?}
         */
        function (index) {
            for (var i = index; i >= 0; i--) {
                /** @type {?} */
                var time = this.timeList[i];
                if (!time.disabled) {
                    return time.time;
                }
            }
        };
        /**
         * @private
         * @param {?} time
         * @return {?}
         */
        NgxMatTimepickerControlComponent.prototype._isSelectedTimeDisabled = /**
         * @private
         * @param {?} time
         * @return {?}
         */
        function (time) {
            return this.timeList.find((/**
             * @param {?} faceTime
             * @return {?}
             */
            function (faceTime) { return faceTime.time === time; })).disabled;
        };
        /**
         * @private
         * @return {?}
         */
        NgxMatTimepickerControlComponent.prototype._setAvailableTime = /**
         * @private
         * @return {?}
         */
        function () {
            this.time = this.timeList.find((/**
             * @param {?} t
             * @return {?}
             */
            function (t) { return !t.disabled; })).time;
            this.timeChanged.emit(this.time);
        };
        NgxMatTimepickerControlComponent.nextId = 0;
        NgxMatTimepickerControlComponent.decorators = [
            { type: core.Component, args: [{
                        selector: "ngx-mat-timepicker-time-control",
                        template: "<mat-form-field [color]=\"color\"\n                [floatLabel]=\"floatLabel\"\n                [ngClass]=\"{'active': isFocused}\"\n                class=\"ngx-mat-timepicker-control\">\n    <input id=\"ngx_mat_timepicker_field_{{id}}\"\n           name=\"ngx_mat_timepicker_field_{{id}}\"\n           matInput\n           maxlength=\"2\"\n           [ngModel]=\"time | ngxMatTimepickerParser: timeUnit | timeLocalizer: timeUnit : true\"\n           (ngModelChange)=\"onModelChange($event)\"\n           [placeholder]=\"placeholder\"\n           [disabled]=\"disabled\"\n           (keydown)=\"onKeydown($event)\"\n           (keypress)=\"changeTime($event)\"\n           (focus)=\"onFocus()\"\n           (blur)=\"onBlur()\" />\n    <div class=\"arrows-wrap\"\n         matSuffix>\n        <span class=\"arrow\"\n              role=\"button\"\n              (click)=\"increase()\">\n            <svg xmlns=\"http://www.w3.org/2000/svg\"\n                 height=\"18\"\n                 viewBox=\"0 0 24 24\"\n                 width=\"18\">\n                <path d=\"M0 0h24v24H0z\"\n                      fill=\"none\" />\n                <path d=\"M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z\" />\n            </svg>\n        </span>\n        <span class=\"arrow\"\n              role=\"button\"\n              (click)=\"decrease()\">\n            <svg xmlns=\"http://www.w3.org/2000/svg\"\n                 height=\"18\"\n                 viewBox=\"0 0 24 24\"\n                 width=\"18\">\n                <path d=\"M0 0h24v24H0V0z\"\n                      fill=\"none\" />\n                <path d=\"M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z\" />\n            </svg>\n        </span>\n    </div>\n</mat-form-field>\n",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        providers: [NgxMatTimepickerParserPipe],
                        styles: [".ngx-mat-timepicker-control{width:60px;min-width:60px}.ngx-mat-timepicker-control input{text-align:center}.ngx-mat-timepicker-control .arrows-wrap{position:absolute;right:0;bottom:-8px;display:flex;flex-direction:column}.ngx-mat-timepicker-control .arrows-wrap>.arrow{text-align:center;opacity:.5;height:15px;cursor:pointer;transition:opacity .2s;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.ngx-mat-timepicker-control .arrows-wrap>.arrow:hover{opacity:1}"]
                    }] }
        ];
        /** @nocollapse */
        NgxMatTimepickerControlComponent.ctorParameters = function () { return [
            { type: NgxMatTimepickerParserPipe }
        ]; };
        NgxMatTimepickerControlComponent.propDecorators = {
            color: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            floatLabel: [{ type: core.Input }],
            max: [{ type: core.Input }],
            min: [{ type: core.Input }],
            placeholder: [{ type: core.Input }],
            preventTyping: [{ type: core.Input }],
            time: [{ type: core.Input }],
            timeChanged: [{ type: core.Output }],
            timeList: [{ type: core.Input }],
            timeUnit: [{ type: core.Input }]
        };
        return NgxMatTimepickerControlComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/pipes/ngx-mat-timepicker-time-localizer.pipe.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NgxMatTimepickerTimeLocalizerPipe = /** @class */ (function () {
        function NgxMatTimepickerTimeLocalizerPipe(_locale) {
            this._locale = _locale;
        }
        /**
         * @param {?} time
         * @param {?} timeUnit
         * @param {?=} isKeyboardEnabled
         * @return {?}
         */
        NgxMatTimepickerTimeLocalizerPipe.prototype.transform = /**
         * @param {?} time
         * @param {?} timeUnit
         * @param {?=} isKeyboardEnabled
         * @return {?}
         */
        function (time, timeUnit, isKeyboardEnabled) {
            if (isKeyboardEnabled === void 0) { isKeyboardEnabled = false; }
            if (time == null || time === "") {
                return "";
            }
            switch (timeUnit) {
                case NgxMatTimepickerUnits.HOUR: {
                    /** @type {?} */
                    var format = (time === 0 || isKeyboardEnabled) ? "HH" : "H";
                    return this._formatTime(NgxMatTimepickerMeasure.hour, time, format);
                }
                case NgxMatTimepickerUnits.MINUTE:
                    return this._formatTime(NgxMatTimepickerMeasure.minute, time, "mm");
                default:
                    throw new Error("There is no Time Unit with type " + timeUnit);
            }
        };
        /**
         * @private
         * @param {?} timeMeasure
         * @param {?} time
         * @param {?} format
         * @return {?}
         */
        NgxMatTimepickerTimeLocalizerPipe.prototype._formatTime = /**
         * @private
         * @param {?} timeMeasure
         * @param {?} time
         * @param {?} format
         * @return {?}
         */
        function (timeMeasure, time, format) {
            var _a;
            try {
                return tsLuxon.DateTime.fromObject((_a = {}, _a[timeMeasure] = +time, _a)).setLocale(this._locale).toFormat(format);
            }
            catch (_b) {
                throw new Error("Cannot format provided time - " + time + " to locale - " + this._locale);
            }
        };
        NgxMatTimepickerTimeLocalizerPipe.decorators = [
            { type: core.Pipe, args: [{
                        name: "timeLocalizer"
                    },] }
        ];
        /** @nocollapse */
        NgxMatTimepickerTimeLocalizerPipe.ctorParameters = function () { return [
            { type: String, decorators: [{ type: core.Inject, args: [NGX_MAT_TIMEPICKER_LOCALE,] }] }
        ]; };
        return NgxMatTimepickerTimeLocalizerPipe;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/pipes/ngx-mat-timepicker-active-hour.pipe.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NgxMatTimepickerActiveHourPipe = /** @class */ (function () {
        function NgxMatTimepickerActiveHourPipe() {
        }
        /**
         * @param {?} hour
         * @param {?} currentHour
         * @param {?} isClockFaceDisabled
         * @return {?}
         */
        NgxMatTimepickerActiveHourPipe.prototype.transform = /**
         * @param {?} hour
         * @param {?} currentHour
         * @param {?} isClockFaceDisabled
         * @return {?}
         */
        function (hour, currentHour, isClockFaceDisabled) {
            if (hour == null || isClockFaceDisabled) {
                return false;
            }
            return hour === currentHour;
        };
        NgxMatTimepickerActiveHourPipe.decorators = [
            { type: core.Pipe, args: [{
                        name: 'activeHour'
                    },] }
        ];
        return NgxMatTimepickerActiveHourPipe;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/pipes/ngx-mat-timepicker-active-minute.pipe.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NgxMatTimepickerActiveMinutePipe = /** @class */ (function () {
        function NgxMatTimepickerActiveMinutePipe() {
        }
        /**
         * @param {?} minute
         * @param {?} currentMinute
         * @param {?} gap
         * @param {?} isClockFaceDisabled
         * @return {?}
         */
        NgxMatTimepickerActiveMinutePipe.prototype.transform = /**
         * @param {?} minute
         * @param {?} currentMinute
         * @param {?} gap
         * @param {?} isClockFaceDisabled
         * @return {?}
         */
        function (minute, currentMinute, gap, isClockFaceDisabled) {
            if (minute == null || isClockFaceDisabled) {
                return false;
            }
            /** @type {?} */
            var defaultGap = 5;
            return ((currentMinute === minute) && (minute % (gap || defaultGap) === 0));
        };
        NgxMatTimepickerActiveMinutePipe.decorators = [
            { type: core.Pipe, args: [{
                        name: 'activeMinute'
                    },] }
        ];
        return NgxMatTimepickerActiveMinutePipe;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/components/ngx-mat-timepicker-content/ngx-mat-timepicker-content.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NgxMatTimepickerContentComponent = /** @class */ (function () {
        function NgxMatTimepickerContentComponent() {
        }
        NgxMatTimepickerContentComponent.decorators = [
            { type: core.Component, args: [{
                        selector: "ngx-mat-timepicker-content",
                        template: "<div *ngIf=\"appendToInput;else timepickerModal\">\n\t<ng-container *ngTemplateOutlet=\"timepickerOutlet\"></ng-container>\n</div>\n<ng-template #timepickerModal>\n\t<ng-container *ngTemplateOutlet=\"timepickerOutlet\"></ng-container>\n</ng-template>\n<ng-template #timepickerOutlet>\n\t<ng-content></ng-content>\n</ng-template>\n"
                    }] }
        ];
        NgxMatTimepickerContentComponent.propDecorators = {
            appendToInput: [{ type: core.Input }],
            inputElement: [{ type: core.Input }]
        };
        return NgxMatTimepickerContentComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/components/ngx-mat-timepicker-standalone/ngx-mat-timepicker-standalone.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NgxMatTimepickerStandaloneComponent = /** @class */ (function (_super) {
        __extends(NgxMatTimepickerStandaloneComponent, _super);
        function NgxMatTimepickerStandaloneComponent(data, timepickerSrv, eventSrv, locale) {
            var _this = _super.call(this, timepickerSrv, eventSrv, locale, data) || this;
            _this.data = data;
            return _this;
        }
        /**
         * @return {?}
         */
        NgxMatTimepickerStandaloneComponent.prototype.close = /**
         * @return {?}
         */
        function () {
            this.data.timepickerBaseRef.close();
        };
        NgxMatTimepickerStandaloneComponent.decorators = [
            { type: core.Component, args: [{
                        selector: "ngx-mat-timepicker-standalone",
                        template: "<ng-template #cancelBtnDefault>\n\t<button mat-button\n\t\t\t[color]=\"color\">CANCEL\n\t</button>\n</ng-template>\n<ng-template #confirmBtnDefault>\n\t<button mat-button\n\t\t\t[color]=\"color\">OK\n\t</button>\n</ng-template>\n<div cdkTrapFocus\n\t cdkTrapFocusAutoCapture>\n\t<ngx-mat-timepicker-content [appendToInput]=\"data.appendToInput\"\n\t\t\t\t\t\t\t\t[inputElement]=\"data.inputElement\"\n\t\t\t\t\t\t\t\t[ngxMatTimepickerTheme]=\"data.theme\">\n\t\t<div class=\"timepicker\"\n\t\t\t [ngClass]=\"data.timepickerClass\">\n\t\t\t<mat-toolbar [color]=\"color\"\n\t\t\t\t\t\t class=\"timepicker-header\">\n\t\t\t\t<ngx-mat-timepicker-dial [color]=\"color\"\n\t\t\t\t\t\t\t\t\t\t [format]=\"data.format\"\n\t\t\t\t\t\t\t\t\t\t [hour]=\"(selectedHour | async)?.time\"\n\t\t\t\t\t\t\t\t\t\t [minute]=\"(selectedMinute | async)?.time\"\n\t\t\t\t\t\t\t\t\t\t [period]=\"selectedPeriod | async\"\n\t\t\t\t\t\t\t\t\t\t [activeTimeUnit]=\"activeTimeUnit\"\n\t\t\t\t\t\t\t\t\t\t [minTime]=\"data.minTime\"\n\t\t\t\t\t\t\t\t\t\t [maxTime]=\"data.maxTime\"\n\t\t\t\t\t\t\t\t\t\t [isEditable]=\"data.enableKeyboardInput\"\n\t\t\t\t\t\t\t\t\t\t [editableHintTmpl]=\"data.editableHintTmpl\"\n\t\t\t\t\t\t\t\t\t\t [minutesGap]=\"data.minutesGap\"\n\t\t\t\t\t\t\t\t\t\t [hoursOnly]=\"data.hoursOnly\"\n\t\t\t\t\t\t\t\t\t\t (periodChanged)=\"changePeriod($event)\"\n\t\t\t\t\t\t\t\t\t\t (timeUnitChanged)=\"changeTimeUnit($event)\"\n\t\t\t\t\t\t\t\t\t\t (hourChanged)=\"onHourChange($event)\"\n\t\t\t\t\t\t\t\t\t\t (minuteChanged)=\"onMinuteChange($event)\">\n\t\t\t\t</ngx-mat-timepicker-dial>\n\t\t\t</mat-toolbar>\n\t\t\t<div class=\"timepicker__main-content\">\n\t\t\t\t<div class=\"timepicker__body\"\n\t\t\t\t\t [ngSwitch]=\"activeTimeUnit\">\n\t\t\t\t\t<div *ngSwitchCase=\"timeUnit.HOUR\">\n\t\t\t\t\t\t<ngx-mat-timepicker-24-hours-face *ngIf=\"data.format === 24;else ampmHours\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  [color]=\"color\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  (hourChange)=\"onHourChange($event)\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  [selectedHour]=\"selectedHour | async\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  [minTime]=\"data.minTime\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  [maxTime]=\"data.maxTime\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  [format]=\"data.format\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  (hourSelected)=\"onHourSelected($event)\"></ngx-mat-timepicker-24-hours-face>\n\t\t\t\t\t\t<ng-template #ampmHours>\n\t\t\t\t\t\t\t<ngx-mat-timepicker-12-hours-face\n\t\t\t\t\t\t\t\t\t[color]=\"color\"\n\t\t\t\t\t\t\t\t\t(hourChange)=\"onHourChange($event)\"\n\t\t\t\t\t\t\t\t\t[selectedHour]=\"selectedHour | async\"\n\t\t\t\t\t\t\t\t\t[period]=\"selectedPeriod | async\"\n\t\t\t\t\t\t\t\t\t[minTime]=\"data.minTime\"\n\t\t\t\t\t\t\t\t\t[maxTime]=\"data.maxTime\"\n\t\t\t\t\t\t\t\t\t(hourSelected)=\"onHourSelected($event)\"></ngx-mat-timepicker-12-hours-face>\n\t\t\t\t\t\t</ng-template>\n\t\t\t\t\t</div>\n\t\t\t\t\t<ngx-mat-timepicker-minutes-face *ngSwitchCase=\"timeUnit.MINUTE\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t [color]=\"color\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t [selectedMinute]=\"selectedMinute | async\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t [selectedHour]=\"(selectedHour | async)?.time\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t [minTime]=\"data.minTime\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t [maxTime]=\"data.maxTime\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t [format]=\"data.format\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t [period]=\"selectedPeriod | async\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t [minutesGap]=\"data.minutesGap\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t (minuteChange)=\"onMinuteChange($event)\"></ngx-mat-timepicker-minutes-face>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t</ngx-mat-timepicker-content>\n\n\t<div class=\"ngx-mat-timepicker-standalone-actions\">\n\t\t<div (click)=\"close()\">\n\t\t\t<ng-container\n\t\t\t\t\t*ngTemplateOutlet=\"data.cancelBtnTmpl ? data.cancelBtnTmpl : cancelBtnDefault\"></ng-container>\n\t\t</div>\n\t\t<div (click)=\"setTime()\">\n\t\t\t<ng-container\n\t\t\t\t\t*ngTemplateOutlet=\"data.confirmBtnTmpl ? data.confirmBtnTmpl : confirmBtnDefault\"></ng-container>\n\t\t</div>\n\t</div>\n</div>\n",
                        // tslint:disable-next-line:no-host-metadata-property
                        host: {
                            "[class.mat-app-background]": "true"
                        },
                        encapsulation: core.ViewEncapsulation.None,
                        styles: ["ngx-mat-timepicker-standalone{display:block;border-radius:4px;box-shadow:0 0 5px 2px rgba(0,0,0,.25);overflow:hidden}ngx-mat-timepicker-standalone ngx-mat-timepicker-content{display:block}ngx-mat-timepicker-standalone ngx-mat-timepicker-content mat-toolbar.timepicker-header{display:flex;justify-content:center;align-items:center}ngx-mat-timepicker-standalone ngx-mat-timepicker-content .clock-face{margin:16px}ngx-mat-timepicker-standalone .ngx-mat-timepicker-standalone-actions{display:flex;flex-direction:row;justify-content:flex-end;padding:0 16px 16px}"]
                    }] }
        ];
        /** @nocollapse */
        NgxMatTimepickerStandaloneComponent.ctorParameters = function () { return [
            { type: undefined, decorators: [{ type: core.Inject, args: [NGX_MAT_TIMEPICKER_CONFIG,] }] },
            { type: NgxMatTimepickerService },
            { type: NgxMatTimepickerEventService },
            { type: String, decorators: [{ type: core.Inject, args: [NGX_MAT_TIMEPICKER_LOCALE,] }] }
        ]; };
        return NgxMatTimepickerStandaloneComponent;
    }(NgxMatTimepickerBaseDirective));

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/ngx-mat-timepicker.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NgxMatTimepickerModule = /** @class */ (function () {
        function NgxMatTimepickerModule() {
        }
        /**
         * @param {?} locale
         * @return {?}
         */
        NgxMatTimepickerModule.setLocale = /**
         * @param {?} locale
         * @return {?}
         */
        function (locale) {
            return {
                ngModule: NgxMatTimepickerModule,
                providers: [
                    { provide: NGX_MAT_TIMEPICKER_LOCALE, useValue: locale },
                    { provide: NGX_MAT_TIMEPICKER_CONFIG, useValue: undefined },
                ]
            };
        };
        NgxMatTimepickerModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            a11y.A11yModule,
                            forms.FormsModule,
                            button.MatButtonModule,
                            formField.MatFormFieldModule,
                            dialog.MatDialogModule,
                            input.MatInputModule,
                            select.MatSelectModule,
                            toolbar.MatToolbarModule,
                            icon.MatIconModule,
                            overlay.OverlayModule,
                            portal.PortalModule,
                            smpCoreUtils.SmpCoreUtilsModule.forRoot()
                        ],
                        exports: [
                            NgxMatTimepickerComponent,
                            NgxMatTimepickerToggleComponent,
                            NgxMatTimepickerFieldComponent,
                            NgxMatTimepickerDirective,
                            NgxMatTimepickerToggleIconDirective
                        ],
                        declarations: [
                            // Not really used, but needed to use it as abstract class
                            NgxMatTimepickerBaseDirective,
                            NgxMatTimepickerHoursFaceDirective,
                            //
                            NgxMatTimepickerActiveHourPipe,
                            NgxMatTimepickerActiveMinutePipe,
                            NgxMatTimepickerComponent,
                            NgxMatTimepickerDialComponent,
                            NgxMatTimepickerDialControlComponent,
                            NgxMatTimepickerDialogComponent,
                            NgxMatTimepickerDirective,
                            NgxMatTimepickerFaceComponent,
                            NgxMatTimepickerMinutesFaceComponent,
                            NgxMatTimepickerPeriodComponent,
                            NgxMatTimepickerStandaloneComponent,
                            NgxMatTimepickerToggleComponent,
                            NgxMatTimepicker12HoursFaceComponent,
                            NgxMatTimepicker24HoursFaceComponent,
                            NgxMatTimepickerToggleIconDirective,
                            NgxMatTimepickerAutofocusDirective,
                            NgxMatTimepickerMinutesFormatterPipe,
                            NgxMatTimepickerThemeDirective,
                            NgxMatTimepickerFieldComponent,
                            NgxMatTimepickerControlComponent,
                            NgxMatTimepickerParserPipe,
                            NgxMatTimepickerContentComponent,
                            NgxMatTimepickerTimeFormatterPipe,
                            NgxMatTimepickerTimeLocalizerPipe
                        ],
                        entryComponents: [
                            NgxMatTimepickerDialogComponent,
                            NgxMatTimepickerStandaloneComponent
                        ]
                    },] }
        ];
        return NgxMatTimepickerModule;
    }());

    exports.NgxMatTimepickerDirective = NgxMatTimepickerDirective;
    exports.NgxMatTimepickerFieldComponent = NgxMatTimepickerFieldComponent;
    exports.NgxMatTimepickerModule = NgxMatTimepickerModule;
    exports.NgxMatTimepickerToggleComponent = NgxMatTimepickerToggleComponent;
    exports.NgxMatTimepickerToggleIconDirective = NgxMatTimepickerToggleIconDirective;
    exports.ɵa = NgxMatTimepickerService;
    exports.ɵb = NGX_MAT_TIMEPICKER_LOCALE;
    exports.ɵc = NgxMatTimepickerComponent;
    exports.ɵd = NGX_MAT_TIMEPICKER_CONFIG;
    exports.ɵe = NgxMatTimepickerEventService;
    exports.ɵf = NgxMatTimepickerBaseDirective;
    exports.ɵg = NgxMatTimepickerHoursFaceDirective;
    exports.ɵh = NgxMatTimepickerActiveHourPipe;
    exports.ɵi = NgxMatTimepickerActiveMinutePipe;
    exports.ɵj = NgxMatTimepickerDialComponent;
    exports.ɵk = NgxMatTimepickerDialControlComponent;
    exports.ɵl = NgxMatTimepickerParserPipe;
    exports.ɵm = NgxMatTimepickerDialogComponent;
    exports.ɵn = NgxMatTimepickerFaceComponent;
    exports.ɵo = NgxMatTimepickerMinutesFaceComponent;
    exports.ɵp = NgxMatTimepickerPeriodComponent;
    exports.ɵq = NgxMatTimepickerStandaloneComponent;
    exports.ɵr = NgxMatTimepicker12HoursFaceComponent;
    exports.ɵs = NgxMatTimepicker24HoursFaceComponent;
    exports.ɵt = NgxMatTimepickerAutofocusDirective;
    exports.ɵu = NgxMatTimepickerMinutesFormatterPipe;
    exports.ɵv = NgxMatTimepickerThemeDirective;
    exports.ɵw = NgxMatTimepickerControlComponent;
    exports.ɵx = NgxMatTimepickerContentComponent;
    exports.ɵy = NgxMatTimepickerTimeFormatterPipe;
    exports.ɵz = NgxMatTimepickerTimeLocalizerPipe;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ngx-mat-timepicker.umd.js.map
