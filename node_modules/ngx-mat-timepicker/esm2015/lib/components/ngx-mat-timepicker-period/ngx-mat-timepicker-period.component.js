/**
 * @fileoverview added by tsickle
 * Generated from: lib/components/ngx-mat-timepicker-period/ngx-mat-timepicker-period.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, EventEmitter, Input, Output } from "@angular/core";
import { animate, sequence, style, transition, trigger } from "@angular/animations";
//
import { NgxMatTimepickerPeriods } from "../../models/ngx-mat-timepicker-periods.enum";
import { NgxMatTimepickerUnits } from "../../models/ngx-mat-timepicker-units.enum";
import { NgxMatTimepickerUtils } from "../../utils/ngx-mat-timepicker.utils";
//
import { DateTime } from "ts-luxon";
export class NgxMatTimepickerPeriodComponent {
    constructor() {
        this.isPeriodAvailable = true;
        this.periodChanged = new EventEmitter();
        this.timePeriod = NgxMatTimepickerPeriods;
    }
    /**
     * @return {?}
     */
    animationDone() {
        this.isPeriodAvailable = true;
    }
    /**
     * @param {?} period
     * @return {?}
     */
    changePeriod(period) {
        this.isPeriodAvailable = this._isSwitchPeriodAvailable(period);
        if (this.isPeriodAvailable) {
            this.periodChanged.next(period);
        }
    }
    /**
     * @private
     * @param {?} period
     * @return {?}
     */
    _getDisabledTimeByPeriod(period) {
        switch (this.activeTimeUnit) {
            case NgxMatTimepickerUnits.HOUR:
                return NgxMatTimepickerUtils.disableHours(this.hours, {
                    min: this.minTime,
                    max: this.maxTime,
                    format: this.format,
                    period
                });
            case NgxMatTimepickerUnits.MINUTE:
                return NgxMatTimepickerUtils.disableMinutes(this.minutes, +this.selectedHour, {
                    min: this.minTime,
                    max: this.maxTime,
                    format: this.format,
                    period
                });
            default:
                throw new Error("no such NgxMatTimepickerUnits");
        }
    }
    /**
     * @private
     * @param {?} period
     * @return {?}
     */
    _isSwitchPeriodAvailable(period) {
        /** @type {?} */
        const time = this._getDisabledTimeByPeriod(period);
        return !time.every((/**
         * @param {?} t
         * @return {?}
         */
        t => t.disabled));
    }
}
NgxMatTimepickerPeriodComponent.decorators = [
    { type: Component, args: [{
                selector: "ngx-mat-timepicker-period",
                template: "<div class=\"timepicker-period\">\n    <button class=\"timepicker-dial__item timepicker-period__btn\"\n            [ngClass]=\"{'active': selectedPeriod === timePeriod.AM}\"\n            (click)=\"changePeriod(timePeriod.AM)\"\n            type=\"button\">{{meridiems[0]}}</button>\n    <button class=\"timepicker-dial__item timepicker-period__btn\"\n            [ngClass]=\"{'active': selectedPeriod === timePeriod.PM}\"\n            (click)=\"changePeriod(timePeriod.PM)\"\n            type=\"button\">{{meridiems[1]}}</button>\n    <div class=\"timepicker-period__warning\"\n         [@scaleInOut]\n         (@scaleInOut.done)=\"animationDone()\"\n         *ngIf=\"!isPeriodAvailable\">\n        <p>Current time would be invalid in this period.</p>\n    </div>\n</div>\n",
                animations: [
                    trigger("scaleInOut", [
                        transition(":enter", [
                            style({ transform: "scale(0)" }),
                            animate(".2s", style({ transform: "scale(1)" })),
                            sequence([
                                animate("3s", style({ opacity: 1 })),
                                animate(".3s", style({ opacity: 0 }))
                            ])
                        ])
                    ])
                ],
                styles: [".timepicker-period{display:flex;flex-direction:column;position:relative}.timepicker-period__btn{opacity:.5;padding:1px 3px;border:0;background-color:transparent;font-size:18px;font-weight:500;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;outline:0;border-radius:3px;transition:background-color .5s;color:inherit}.timepicker-period__btn.active{opacity:1}.timepicker-period__btn:focus{background-color:rgba(0,0,0,.07)}.timepicker-period__warning{padding:5px 10px;border-radius:3px;background-color:rgba(0,0,0,.55);position:absolute;width:200px;left:-20px;top:40px}.timepicker-period__warning>p{margin:0;font-size:12px}"]
            }] }
];
NgxMatTimepickerPeriodComponent.propDecorators = {
    activeTimeUnit: [{ type: Input }],
    format: [{ type: Input }],
    hours: [{ type: Input }],
    maxTime: [{ type: Input }],
    meridiems: [{ type: Input }],
    minTime: [{ type: Input }],
    minutes: [{ type: Input }],
    periodChanged: [{ type: Output }],
    selectedHour: [{ type: Input }],
    selectedPeriod: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    NgxMatTimepickerPeriodComponent.prototype.activeTimeUnit;
    /** @type {?} */
    NgxMatTimepickerPeriodComponent.prototype.format;
    /** @type {?} */
    NgxMatTimepickerPeriodComponent.prototype.hours;
    /** @type {?} */
    NgxMatTimepickerPeriodComponent.prototype.isPeriodAvailable;
    /** @type {?} */
    NgxMatTimepickerPeriodComponent.prototype.maxTime;
    /** @type {?} */
    NgxMatTimepickerPeriodComponent.prototype.meridiems;
    /** @type {?} */
    NgxMatTimepickerPeriodComponent.prototype.minTime;
    /** @type {?} */
    NgxMatTimepickerPeriodComponent.prototype.minutes;
    /** @type {?} */
    NgxMatTimepickerPeriodComponent.prototype.periodChanged;
    /** @type {?} */
    NgxMatTimepickerPeriodComponent.prototype.selectedHour;
    /** @type {?} */
    NgxMatTimepickerPeriodComponent.prototype.selectedPeriod;
    /** @type {?} */
    NgxMatTimepickerPeriodComponent.prototype.timePeriod;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LW1hdC10aW1lcGlja2VyLXBlcmlvZC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZ3gtbWF0LXRpbWVwaWNrZXIvIiwic291cmNlcyI6WyJsaWIvY29tcG9uZW50cy9uZ3gtbWF0LXRpbWVwaWNrZXItcGVyaW9kL25neC1tYXQtdGltZXBpY2tlci1wZXJpb2QuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUFDLFNBQVMsRUFBRSxZQUFZLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBQyxNQUFNLGVBQWUsQ0FBQztBQUNyRSxPQUFPLEVBQUMsT0FBTyxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUUsVUFBVSxFQUFFLE9BQU8sRUFBQyxNQUFNLHFCQUFxQixDQUFDOztBQUVsRixPQUFPLEVBQUMsdUJBQXVCLEVBQUMsTUFBTSw4Q0FBOEMsQ0FBQztBQUNyRixPQUFPLEVBQUMscUJBQXFCLEVBQUMsTUFBTSw0Q0FBNEMsQ0FBQztBQUVqRixPQUFPLEVBQUMscUJBQXFCLEVBQUMsTUFBTSxzQ0FBc0MsQ0FBQzs7QUFFM0UsT0FBTyxFQUFDLFFBQVEsRUFBQyxNQUFNLFVBQVUsQ0FBQztBQW1CbEMsTUFBTSxPQUFPLCtCQUErQjtJQWpCNUM7UUFzQkksc0JBQWlCLEdBQUcsSUFBSSxDQUFDO1FBS2Ysa0JBQWEsR0FBRyxJQUFJLFlBQVksRUFBMkIsQ0FBQztRQUd0RSxlQUFVLEdBQUcsdUJBQXVCLENBQUM7SUF1Q3pDLENBQUM7Ozs7SUFyQ0csYUFBYTtRQUNULElBQUksQ0FBQyxpQkFBaUIsR0FBRyxJQUFJLENBQUM7SUFDbEMsQ0FBQzs7Ozs7SUFFRCxZQUFZLENBQUMsTUFBK0I7UUFDeEMsSUFBSSxDQUFDLGlCQUFpQixHQUFHLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUMvRCxJQUFJLElBQUksQ0FBQyxpQkFBaUIsRUFBRTtZQUN4QixJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztTQUNuQztJQUNMLENBQUM7Ozs7OztJQUVPLHdCQUF3QixDQUFDLE1BQStCO1FBQzVELFFBQVEsSUFBSSxDQUFDLGNBQWMsRUFBRTtZQUN6QixLQUFLLHFCQUFxQixDQUFDLElBQUk7Z0JBQzNCLE9BQU8scUJBQXFCLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUU7b0JBQ2xELEdBQUcsRUFBRSxJQUFJLENBQUMsT0FBTztvQkFDakIsR0FBRyxFQUFFLElBQUksQ0FBQyxPQUFPO29CQUNqQixNQUFNLEVBQUUsSUFBSSxDQUFDLE1BQU07b0JBQ25CLE1BQU07aUJBQ1QsQ0FBQyxDQUFDO1lBQ1AsS0FBSyxxQkFBcUIsQ0FBQyxNQUFNO2dCQUM3QixPQUFPLHFCQUFxQixDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRTtvQkFDMUUsR0FBRyxFQUFFLElBQUksQ0FBQyxPQUFPO29CQUNqQixHQUFHLEVBQUUsSUFBSSxDQUFDLE9BQU87b0JBQ2pCLE1BQU0sRUFBRSxJQUFJLENBQUMsTUFBTTtvQkFDbkIsTUFBTTtpQkFDVCxDQUFDLENBQUM7WUFDUDtnQkFDSSxNQUFNLElBQUksS0FBSyxDQUFDLCtCQUErQixDQUFDLENBQUM7U0FDeEQ7SUFDTCxDQUFDOzs7Ozs7SUFFTyx3QkFBd0IsQ0FBQyxNQUErQjs7Y0FDdEQsSUFBSSxHQUFHLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxNQUFNLENBQUM7UUFFbEQsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLOzs7O1FBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFDLENBQUM7SUFDeEMsQ0FBQzs7O1lBcEVKLFNBQVMsU0FBQztnQkFDUCxRQUFRLEVBQUUsMkJBQTJCO2dCQUNyQyxpeEJBQXVEO2dCQUV2RCxVQUFVLEVBQUU7b0JBQ1IsT0FBTyxDQUFDLFlBQVksRUFBRTt3QkFDbEIsVUFBVSxDQUFDLFFBQVEsRUFBRTs0QkFDakIsS0FBSyxDQUFDLEVBQUMsU0FBUyxFQUFFLFVBQVUsRUFBQyxDQUFDOzRCQUM5QixPQUFPLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxFQUFDLFNBQVMsRUFBRSxVQUFVLEVBQUMsQ0FBQyxDQUFDOzRCQUM5QyxRQUFRLENBQUM7Z0NBQ0wsT0FBTyxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsRUFBQyxPQUFPLEVBQUUsQ0FBQyxFQUFDLENBQUMsQ0FBQztnQ0FDbEMsT0FBTyxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsRUFBQyxPQUFPLEVBQUUsQ0FBQyxFQUFDLENBQUMsQ0FBQzs2QkFDdEMsQ0FBQzt5QkFDTCxDQUFDO3FCQUNMLENBQUM7aUJBQ0w7O2FBQ0o7Ozs2QkFHSSxLQUFLO3FCQUNMLEtBQUs7b0JBQ0wsS0FBSztzQkFFTCxLQUFLO3dCQUNMLEtBQUs7c0JBQ0wsS0FBSztzQkFDTCxLQUFLOzRCQUNMLE1BQU07MkJBQ04sS0FBSzs2QkFDTCxLQUFLOzs7O0lBVk4seURBQStDOztJQUMvQyxpREFBd0I7O0lBQ3hCLGdEQUE0Qzs7SUFDNUMsNERBQXlCOztJQUN6QixrREFBMkI7O0lBQzNCLG9EQUE2Qjs7SUFDN0Isa0RBQTJCOztJQUMzQixrREFBOEM7O0lBQzlDLHdEQUFzRTs7SUFDdEUsdURBQXVDOztJQUN2Qyx5REFBaUQ7O0lBQ2pELHFEQUFxQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Q29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIElucHV0LCBPdXRwdXR9IGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XG5pbXBvcnQge2FuaW1hdGUsIHNlcXVlbmNlLCBzdHlsZSwgdHJhbnNpdGlvbiwgdHJpZ2dlcn0gZnJvbSBcIkBhbmd1bGFyL2FuaW1hdGlvbnNcIjtcbi8vXG5pbXBvcnQge05neE1hdFRpbWVwaWNrZXJQZXJpb2RzfSBmcm9tIFwiLi4vLi4vbW9kZWxzL25neC1tYXQtdGltZXBpY2tlci1wZXJpb2RzLmVudW1cIjtcbmltcG9ydCB7Tmd4TWF0VGltZXBpY2tlclVuaXRzfSBmcm9tIFwiLi4vLi4vbW9kZWxzL25neC1tYXQtdGltZXBpY2tlci11bml0cy5lbnVtXCI7XG5pbXBvcnQge05neE1hdFRpbWVwaWNrZXJDbG9ja0ZhY2V9IGZyb20gXCIuLi8uLi9tb2RlbHMvbmd4LW1hdC10aW1lcGlja2VyLWNsb2NrLWZhY2UuaW50ZXJmYWNlXCI7XG5pbXBvcnQge05neE1hdFRpbWVwaWNrZXJVdGlsc30gZnJvbSBcIi4uLy4uL3V0aWxzL25neC1tYXQtdGltZXBpY2tlci51dGlsc1wiO1xuLy9cbmltcG9ydCB7RGF0ZVRpbWV9IGZyb20gXCJ0cy1sdXhvblwiO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogXCJuZ3gtbWF0LXRpbWVwaWNrZXItcGVyaW9kXCIsXG4gICAgdGVtcGxhdGVVcmw6IFwibmd4LW1hdC10aW1lcGlja2VyLXBlcmlvZC5jb21wb25lbnQuaHRtbFwiLFxuICAgIHN0eWxlVXJsczogW1wibmd4LW1hdC10aW1lcGlja2VyLXBlcmlvZC5jb21wb25lbnQuc2Nzc1wiXSxcbiAgICBhbmltYXRpb25zOiBbXG4gICAgICAgIHRyaWdnZXIoXCJzY2FsZUluT3V0XCIsIFtcbiAgICAgICAgICAgIHRyYW5zaXRpb24oXCI6ZW50ZXJcIiwgW1xuICAgICAgICAgICAgICAgIHN0eWxlKHt0cmFuc2Zvcm06IFwic2NhbGUoMClcIn0pLFxuICAgICAgICAgICAgICAgIGFuaW1hdGUoXCIuMnNcIiwgc3R5bGUoe3RyYW5zZm9ybTogXCJzY2FsZSgxKVwifSkpLFxuICAgICAgICAgICAgICAgIHNlcXVlbmNlKFtcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0ZShcIjNzXCIsIHN0eWxlKHtvcGFjaXR5OiAxfSkpLFxuICAgICAgICAgICAgICAgICAgICBhbmltYXRlKFwiLjNzXCIsIHN0eWxlKHtvcGFjaXR5OiAwfSkpXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF0pXG4gICAgICAgIF0pXG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBOZ3hNYXRUaW1lcGlja2VyUGVyaW9kQ29tcG9uZW50IHtcblxuICAgIEBJbnB1dCgpIGFjdGl2ZVRpbWVVbml0OiBOZ3hNYXRUaW1lcGlja2VyVW5pdHM7XG4gICAgQElucHV0KCkgZm9ybWF0OiBudW1iZXI7XG4gICAgQElucHV0KCkgaG91cnM6IE5neE1hdFRpbWVwaWNrZXJDbG9ja0ZhY2VbXTtcbiAgICBpc1BlcmlvZEF2YWlsYWJsZSA9IHRydWU7XG4gICAgQElucHV0KCkgbWF4VGltZTogRGF0ZVRpbWU7XG4gICAgQElucHV0KCkgbWVyaWRpZW1zOiBzdHJpbmdbXTtcbiAgICBASW5wdXQoKSBtaW5UaW1lOiBEYXRlVGltZTtcbiAgICBASW5wdXQoKSBtaW51dGVzOiBOZ3hNYXRUaW1lcGlja2VyQ2xvY2tGYWNlW107XG4gICAgQE91dHB1dCgpIHBlcmlvZENoYW5nZWQgPSBuZXcgRXZlbnRFbWl0dGVyPE5neE1hdFRpbWVwaWNrZXJQZXJpb2RzPigpO1xuICAgIEBJbnB1dCgpIHNlbGVjdGVkSG91cjogbnVtYmVyIHwgc3RyaW5nO1xuICAgIEBJbnB1dCgpIHNlbGVjdGVkUGVyaW9kOiBOZ3hNYXRUaW1lcGlja2VyUGVyaW9kcztcbiAgICB0aW1lUGVyaW9kID0gTmd4TWF0VGltZXBpY2tlclBlcmlvZHM7XG5cbiAgICBhbmltYXRpb25Eb25lKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmlzUGVyaW9kQXZhaWxhYmxlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBjaGFuZ2VQZXJpb2QocGVyaW9kOiBOZ3hNYXRUaW1lcGlja2VyUGVyaW9kcyk6IHZvaWQge1xuICAgICAgICB0aGlzLmlzUGVyaW9kQXZhaWxhYmxlID0gdGhpcy5faXNTd2l0Y2hQZXJpb2RBdmFpbGFibGUocGVyaW9kKTtcbiAgICAgICAgaWYgKHRoaXMuaXNQZXJpb2RBdmFpbGFibGUpIHtcbiAgICAgICAgICAgIHRoaXMucGVyaW9kQ2hhbmdlZC5uZXh0KHBlcmlvZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIF9nZXREaXNhYmxlZFRpbWVCeVBlcmlvZChwZXJpb2Q6IE5neE1hdFRpbWVwaWNrZXJQZXJpb2RzKTogTmd4TWF0VGltZXBpY2tlckNsb2NrRmFjZVtdIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLmFjdGl2ZVRpbWVVbml0KSB7XG4gICAgICAgICAgICBjYXNlIE5neE1hdFRpbWVwaWNrZXJVbml0cy5IT1VSOlxuICAgICAgICAgICAgICAgIHJldHVybiBOZ3hNYXRUaW1lcGlja2VyVXRpbHMuZGlzYWJsZUhvdXJzKHRoaXMuaG91cnMsIHtcbiAgICAgICAgICAgICAgICAgICAgbWluOiB0aGlzLm1pblRpbWUsXG4gICAgICAgICAgICAgICAgICAgIG1heDogdGhpcy5tYXhUaW1lLFxuICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6IHRoaXMuZm9ybWF0LFxuICAgICAgICAgICAgICAgICAgICBwZXJpb2RcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgTmd4TWF0VGltZXBpY2tlclVuaXRzLk1JTlVURTpcbiAgICAgICAgICAgICAgICByZXR1cm4gTmd4TWF0VGltZXBpY2tlclV0aWxzLmRpc2FibGVNaW51dGVzKHRoaXMubWludXRlcywgK3RoaXMuc2VsZWN0ZWRIb3VyLCB7XG4gICAgICAgICAgICAgICAgICAgIG1pbjogdGhpcy5taW5UaW1lLFxuICAgICAgICAgICAgICAgICAgICBtYXg6IHRoaXMubWF4VGltZSxcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiB0aGlzLmZvcm1hdCxcbiAgICAgICAgICAgICAgICAgICAgcGVyaW9kXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vIHN1Y2ggTmd4TWF0VGltZXBpY2tlclVuaXRzXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfaXNTd2l0Y2hQZXJpb2RBdmFpbGFibGUocGVyaW9kOiBOZ3hNYXRUaW1lcGlja2VyUGVyaW9kcyk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCB0aW1lID0gdGhpcy5fZ2V0RGlzYWJsZWRUaW1lQnlQZXJpb2QocGVyaW9kKTtcblxuICAgICAgICByZXR1cm4gIXRpbWUuZXZlcnkodCA9PiB0LmRpc2FibGVkKTtcbiAgICB9XG59XG4iXX0=