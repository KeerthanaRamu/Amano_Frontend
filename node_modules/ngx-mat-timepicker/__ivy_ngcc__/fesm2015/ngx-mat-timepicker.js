import { Injectable, ɵɵdefineInjectable, InjectionToken, EventEmitter, Component, ChangeDetectionStrategy, ViewEncapsulation, Inject, Input, Output, Directive, Optional, HostListener, ViewContainerRef, HostBinding, ContentChild, ElementRef, ViewChild, Pipe, NgModule } from '@angular/core';
import { NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';
import { BehaviorSubject, Subject } from 'rxjs';
import { DateTime, Info } from 'ts-luxon';
import { tap, map, distinctUntilChanged, takeUntil, shareReplay } from 'rxjs/operators';
import { Overlay, CdkOverlayOrigin, OverlayModule } from '@angular/cdk/overlay';
import { MAT_DIALOG_DATA, MatDialogRef, MatDialog, MatDialogModule } from '@angular/material/dialog';
import { SmpDomService, SmpCoreUtilsModule } from 'smp-core-utils';
import { MatFormField, MatFormFieldModule } from '@angular/material/form-field';
import { PortalModule } from '@angular/cdk/portal';
import { DOCUMENT, CommonModule } from '@angular/common';
import { A11yModule } from '@angular/cdk/a11y';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatInputModule } from '@angular/material/input';
import { MatSelectModule } from '@angular/material/select';
import { MatToolbarModule } from '@angular/material/toolbar';
import { trigger, transition, style, animate, sequence } from '@angular/animations';

/**
 * @fileoverview added by tsickle
 * Generated from: lib/models/ngx-mat-timepicker-periods.enum.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
import * as ɵngcc2 from '@angular/material/form-field';
import * as ɵngcc3 from '@angular/material/select';
import * as ɵngcc4 from '@angular/forms';
import * as ɵngcc5 from '@angular/material/core';
import * as ɵngcc6 from '@angular/material/icon';
import * as ɵngcc7 from '@angular/material/dialog';
import * as ɵngcc8 from '@angular/material/toolbar';
import * as ɵngcc9 from '@angular/material/button';
import * as ɵngcc10 from '@angular/cdk/overlay';
import * as ɵngcc11 from 'smp-core-utils';
import * as ɵngcc12 from '@angular/material/input';
import * as ɵngcc13 from '@angular/cdk/a11y';

function NgxMatTimepickerFieldComponent_mat_form_field_7_mat_option_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mat-option", 12);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const option_r6 = ctx.$implicit;
    ɵngcc0.ɵɵproperty("value", option_r6);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(option_r6);
} }
function NgxMatTimepickerFieldComponent_mat_form_field_7_Template(rf, ctx) { if (rf & 1) {
    const _r8 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "mat-form-field", 9);
    ɵngcc0.ɵɵelementStart(1, "mat-select", 10);
    ɵngcc0.ɵɵlistener("selectionChange", function NgxMatTimepickerFieldComponent_mat_form_field_7_Template_mat_select_selectionChange_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r8); const ctx_r7 = ɵngcc0.ɵɵnextContext(); return ctx_r7.changePeriod($event); });
    ɵngcc0.ɵɵtemplate(2, NgxMatTimepickerFieldComponent_mat_form_field_7_mat_option_2_Template, 2, 2, "mat-option", 11);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("color", ctx_r0.color);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("disabled", ctx_r0.disabled || ctx_r0.isChangePeriodDisabled)("ngModel", ctx_r0.period);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r0.periods);
} }
function NgxMatTimepickerFieldComponent_ngx_mat_timepicker_toggle_8_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function NgxMatTimepickerFieldComponent_ngx_mat_timepicker_toggle_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "ngx-mat-timepicker-toggle", 13);
    ɵngcc0.ɵɵelementStart(1, "span", 14);
    ɵngcc0.ɵɵtemplate(2, NgxMatTimepickerFieldComponent_ngx_mat_timepicker_toggle_8_ng_container_2_Template, 1, 0, "ng-container", 15);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    const _r2 = ɵngcc0.ɵɵreference(10);
    const _r3 = ɵngcc0.ɵɵreference(12);
    ɵngcc0.ɵɵproperty("for", _r2)("disabled", ctx_r1.disabled);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1.toggleIcon || _r3);
} }
function NgxMatTimepickerFieldComponent_ng_template_11_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mat-icon");
    ɵngcc0.ɵɵtext(1, "watch_later");
    ɵngcc0.ɵɵelementEnd();
} }
const _c0 = function (a0) { return { "ngx-mat-timepicker--disabled": a0 }; };
function NgxMatTimepickerDialogComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "button", 14);
    ɵngcc0.ɵɵtext(1, "CANCEL ");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("color", ctx_r1.color);
} }
function NgxMatTimepickerDialogComponent_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "button", 14);
    ɵngcc0.ɵɵtext(1, "OK ");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("color", ctx_r3.color);
} }
function NgxMatTimepickerDialogComponent_div_14_ngx_mat_timepicker_24_hours_face_1_Template(rf, ctx) { if (rf & 1) {
    const _r12 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "ngx-mat-timepicker-24-hours-face", 17);
    ɵngcc0.ɵɵlistener("hourChange", function NgxMatTimepickerDialogComponent_div_14_ngx_mat_timepicker_24_hours_face_1_Template_ngx_mat_timepicker_24_hours_face_hourChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r12); const ctx_r11 = ɵngcc0.ɵɵnextContext(2); return ctx_r11.onHourChange($event); })("hourSelected", function NgxMatTimepickerDialogComponent_div_14_ngx_mat_timepicker_24_hours_face_1_Template_ngx_mat_timepicker_24_hours_face_hourSelected_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r12); const ctx_r13 = ɵngcc0.ɵɵnextContext(2); return ctx_r13.onHourSelected($event); });
    ɵngcc0.ɵɵpipe(1, "async");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r8 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("color", ctx_r8.color)("selectedHour", ɵngcc0.ɵɵpipeBind1(1, 5, ctx_r8.selectedHour))("minTime", ctx_r8.data.minTime)("maxTime", ctx_r8.data.maxTime)("format", ctx_r8.data.format);
} }
function NgxMatTimepickerDialogComponent_div_14_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    const _r15 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "ngx-mat-timepicker-12-hours-face", 18);
    ɵngcc0.ɵɵlistener("hourChange", function NgxMatTimepickerDialogComponent_div_14_ng_template_2_Template_ngx_mat_timepicker_12_hours_face_hourChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r15); const ctx_r14 = ɵngcc0.ɵɵnextContext(2); return ctx_r14.onHourChange($event); })("hourSelected", function NgxMatTimepickerDialogComponent_div_14_ng_template_2_Template_ngx_mat_timepicker_12_hours_face_hourSelected_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r15); const ctx_r16 = ɵngcc0.ɵɵnextContext(2); return ctx_r16.onHourSelected($event); });
    ɵngcc0.ɵɵpipe(1, "async");
    ɵngcc0.ɵɵpipe(2, "async");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r10 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("color", ctx_r10.color)("selectedHour", ɵngcc0.ɵɵpipeBind1(1, 5, ctx_r10.selectedHour))("period", ɵngcc0.ɵɵpipeBind1(2, 7, ctx_r10.selectedPeriod))("minTime", ctx_r10.data.minTime)("maxTime", ctx_r10.data.maxTime);
} }
function NgxMatTimepickerDialogComponent_div_14_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div");
    ɵngcc0.ɵɵtemplate(1, NgxMatTimepickerDialogComponent_div_14_ngx_mat_timepicker_24_hours_face_1_Template, 2, 7, "ngx-mat-timepicker-24-hours-face", 15);
    ɵngcc0.ɵɵtemplate(2, NgxMatTimepickerDialogComponent_div_14_ng_template_2_Template, 3, 9, "ng-template", null, 16, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const _r9 = ɵngcc0.ɵɵreference(3);
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r4.data.format === 24)("ngIfElse", _r9);
} }
function NgxMatTimepickerDialogComponent_ngx_mat_timepicker_minutes_face_15_Template(rf, ctx) { if (rf & 1) {
    const _r18 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "ngx-mat-timepicker-minutes-face", 19);
    ɵngcc0.ɵɵlistener("minuteChange", function NgxMatTimepickerDialogComponent_ngx_mat_timepicker_minutes_face_15_Template_ngx_mat_timepicker_minutes_face_minuteChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r18); const ctx_r17 = ɵngcc0.ɵɵnextContext(); return ctx_r17.onMinuteChange($event); });
    ɵngcc0.ɵɵpipe(1, "async");
    ɵngcc0.ɵɵpipe(2, "async");
    ɵngcc0.ɵɵpipe(3, "async");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext();
    let tmp_2_0;
    ɵngcc0.ɵɵproperty("color", ctx_r5.color)("selectedMinute", ɵngcc0.ɵɵpipeBind1(1, 8, ctx_r5.selectedMinute))("selectedHour", (tmp_2_0 = ɵngcc0.ɵɵpipeBind1(2, 10, ctx_r5.selectedHour)) == null ? null : tmp_2_0.time)("minTime", ctx_r5.data.minTime)("maxTime", ctx_r5.data.maxTime)("format", ctx_r5.data.format)("period", ɵngcc0.ɵɵpipeBind1(3, 12, ctx_r5.selectedPeriod))("minutesGap", ctx_r5.data.minutesGap);
} }
function NgxMatTimepickerDialogComponent_ng_container_18_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function NgxMatTimepickerDialogComponent_ng_container_20_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function NgxMatTimepickerComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "ngx-mat-timepicker-standalone");
} }
function NgxMatTimepickerToggleComponent__svg_svg_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "svg", 2);
    ɵngcc0.ɵɵelement(1, "path", 3);
    ɵngcc0.ɵɵelementEnd();
} }
const _c1 = [[["", "ngxMatTimepickerToggleIcon", ""]]];
const _c2 = ["[ngxMatTimepickerToggleIcon]"];
const _c3 = ["clockFace"];
const _c4 = ["clockHand"];
const _c5 = function (a0) { return { "transform": a0 }; };
function NgxMatTimepickerFaceComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "button", 9);
    ɵngcc0.ɵɵpipe(1, "activeHour");
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵpipe(3, "timeLocalizer");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const time_r8 = ctx.$implicit;
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("color", ɵngcc0.ɵɵpipeBind3(1, 4, time_r8.time, ctx_r1.selectedTime == null ? null : ctx_r1.selectedTime.time, ctx_r1.isClockFaceDisabled) ? ctx_r1.color : undefined)("ngStyle", ɵngcc0.ɵɵpureFunction1(11, _c5, "rotateZ(-" + time_r8.angle + "deg)"))("disabled", time_r8.disabled);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate1(" ", ɵngcc0.ɵɵpipeBind2(3, 8, time_r8.time, ctx_r1.timeUnit.HOUR), " ");
} }
function NgxMatTimepickerFaceComponent_div_4_div_1_ng_content_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 0, ["*ngTemplateOutlet", "hourButton; context: {$implicit: time}"]);
} }
const _c6 = function (a0) { return { $implicit: a0 }; };
function NgxMatTimepickerFaceComponent_div_4_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 13);
    ɵngcc0.ɵɵtemplate(1, NgxMatTimepickerFaceComponent_div_4_div_1_ng_content_1_Template, 1, 0, "ng-content", 14);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const time_r11 = ctx.$implicit;
    ɵngcc0.ɵɵnextContext(2);
    const _r0 = ɵngcc0.ɵɵreference(1);
    ɵngcc0.ɵɵproperty("ngStyle", ɵngcc0.ɵɵpureFunction1(3, _c5, "rotateZ(" + time_r11.angle + "deg)"));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r0)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(5, _c6, time_r11));
} }
function NgxMatTimepickerFaceComponent_div_4_div_3_div_1_ng_content_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 1, ["*ngTemplateOutlet", "hourButton; context: {$implicit: time}"]);
} }
function NgxMatTimepickerFaceComponent_div_4_div_3_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 17);
    ɵngcc0.ɵɵtemplate(1, NgxMatTimepickerFaceComponent_div_4_div_3_div_1_ng_content_1_Template, 1, 0, "ng-content", 14);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const time_r14 = ctx.$implicit;
    const ctx_r13 = ɵngcc0.ɵɵnextContext(3);
    const _r0 = ɵngcc0.ɵɵreference(1);
    ɵngcc0.ɵɵstyleProp("top", "calc(50% - " + ctx_r13.innerClockFaceSize + "px)")("height", ctx_r13.innerClockFaceSize, "px");
    ɵngcc0.ɵɵproperty("ngStyle", ɵngcc0.ɵɵpureFunction1(7, _c5, "rotateZ(" + time_r14.angle + "deg)"));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r0)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(9, _c6, time_r14));
} }
function NgxMatTimepickerFaceComponent_div_4_div_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 15);
    ɵngcc0.ɵɵtemplate(1, NgxMatTimepickerFaceComponent_div_4_div_3_div_1_Template, 2, 11, "div", 16);
    ɵngcc0.ɵɵpipe(2, "slice");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r10 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ɵngcc0.ɵɵpipeBind3(2, 2, ctx_r10.faceTime, 12, 24))("ngForTrackBy", ctx_r10.trackByTime);
} }
function NgxMatTimepickerFaceComponent_div_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 10);
    ɵngcc0.ɵɵtemplate(1, NgxMatTimepickerFaceComponent_div_4_div_1_Template, 2, 7, "div", 11);
    ɵngcc0.ɵɵpipe(2, "slice");
    ɵngcc0.ɵɵtemplate(3, NgxMatTimepickerFaceComponent_div_4_div_3_Template, 3, 6, "div", 12);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ɵngcc0.ɵɵpipeBind3(2, 3, ctx_r3.faceTime, 0, 12))("ngForTrackBy", ctx_r3.trackByTime);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r3.faceTime.length > 12);
} }
function NgxMatTimepickerFaceComponent_button_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "button", 18);
    ɵngcc0.ɵɵelement(1, "span", 19);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("color", ctx_r5.color);
} }
function NgxMatTimepickerFaceComponent_ng_template_9_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 13);
    ɵngcc0.ɵɵelementStart(1, "button", 20);
    ɵngcc0.ɵɵpipe(2, "activeMinute");
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵpipe(4, "timeLocalizer");
    ɵngcc0.ɵɵpipe(5, "minutesFormatter");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const time_r17 = ctx.$implicit;
    const ctx_r16 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngStyle", ɵngcc0.ɵɵpureFunction1(16, _c5, "rotateZ(" + time_r17.angle + "deg)"));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("disableRipple", time_r17.time % ctx_r16.minutesGap !== 0)("color", ɵngcc0.ɵɵpipeBind4(2, 5, time_r17.time, ctx_r16.selectedTime == null ? null : ctx_r16.selectedTime.time, ctx_r16.minutesGap, ctx_r16.isClockFaceDisabled) ? ctx_r16.color : undefined)("ngStyle", ɵngcc0.ɵɵpureFunction1(18, _c5, "rotateZ(-" + time_r17.angle + "deg)"));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate1(" ", ɵngcc0.ɵɵpipeBind2(4, 10, ɵngcc0.ɵɵpipeBind2(5, 13, time_r17.time, ctx_r16.minutesGap), ctx_r16.timeUnit.MINUTE), " ");
} }
function NgxMatTimepickerFaceComponent_ng_template_9_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 10);
    ɵngcc0.ɵɵtemplate(1, NgxMatTimepickerFaceComponent_ng_template_9_div_1_Template, 6, 20, "div", 11);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r7 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r7.faceTime)("ngForTrackBy", ctx_r7.trackByTime);
} }
const _c7 = ["*", "*"];
const _c8 = function (a0) { return { "clock-face__clock-hand_minute": a0 }; };
function NgxMatTimepickerDialComponent_ngx_mat_timepicker_period_7_Template(rf, ctx) { if (rf & 1) {
    const _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "ngx-mat-timepicker-period", 7);
    ɵngcc0.ɵɵlistener("periodChanged", function NgxMatTimepickerDialComponent_ngx_mat_timepicker_period_7_Template_ngx_mat_timepicker_period_periodChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); const ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.changePeriod($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("selectedPeriod", ctx_r0.period)("activeTimeUnit", ctx_r0.activeTimeUnit)("maxTime", ctx_r0.maxTime)("minTime", ctx_r0.minTime)("format", ctx_r0.format)("hours", ctx_r0.hours)("minutes", ctx_r0.minutes)("selectedHour", ctx_r0.hour)("meridiems", ctx_r0.meridiems);
} }
function NgxMatTimepickerDialComponent_div_8_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function NgxMatTimepickerDialComponent_div_8_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "small", 11);
    ɵngcc0.ɵɵtext(1, " * use arrows (");
    ɵngcc0.ɵɵelementStart(2, "span");
    ɵngcc0.ɵɵtext(3, "\u21C5");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtext(4, ") to change the time");
    ɵngcc0.ɵɵelementEnd();
} }
const _c9 = function (a0) { return { "timepicker-dial__hint-container--hidden": a0 }; };
function NgxMatTimepickerDialComponent_div_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 8);
    ɵngcc0.ɵɵtemplate(1, NgxMatTimepickerDialComponent_div_8_ng_container_1_Template, 1, 0, "ng-container", 9);
    ɵngcc0.ɵɵtemplate(2, NgxMatTimepickerDialComponent_div_8_ng_template_2_Template, 5, 0, "ng-template", null, 10, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const _r5 = ɵngcc0.ɵɵreference(3);
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(2, _c9, !ctx_r1.isHintVisible));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1.editableHintTmpl ? ctx_r1.editableHintTmpl : _r5);
} }
const _c10 = function (a0) { return { "active": a0 }; };
function NgxMatTimepickerDialControlComponent_input_0_Template(rf, ctx) { if (rf & 1) {
    const _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "input", 2);
    ɵngcc0.ɵɵlistener("ngModelChange", function NgxMatTimepickerDialControlComponent_input_0_Template_input_ngModelChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); const ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.time = $event; })("input", function NgxMatTimepickerDialControlComponent_input_0_Template_input_input_0_listener() { ɵngcc0.ɵɵrestoreView(_r4); const ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.updateTime(); })("focus", function NgxMatTimepickerDialControlComponent_input_0_Template_input_focus_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); const ctx_r6 = ɵngcc0.ɵɵnextContext(); return ctx_r6.saveTimeAndChangeTimeUnit($event, ctx_r6.timeUnit); });
    ɵngcc0.ɵɵpipe(1, "timeLocalizer");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(8, _c10, ctx_r0.isActive))("ngModel", ɵngcc0.ɵɵpipeBind3(1, 4, ctx_r0.time, ctx_r0.timeUnit, true))("disabled", ctx_r0.disabled)("ngxMatTimepickerAutofocus", ctx_r0.isActive);
} }
function NgxMatTimepickerDialControlComponent_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    const _r8 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "input", 3);
    ɵngcc0.ɵɵlistener("ngModelChange", function NgxMatTimepickerDialControlComponent_ng_template_1_Template_input_ngModelChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r8); const ctx_r7 = ɵngcc0.ɵɵnextContext(); return ctx_r7.onModelChange($event); })("input", function NgxMatTimepickerDialControlComponent_ng_template_1_Template_input_input_0_listener() { ɵngcc0.ɵɵrestoreView(_r8); const ctx_r9 = ɵngcc0.ɵɵnextContext(); return ctx_r9.updateTime(); })("focus", function NgxMatTimepickerDialControlComponent_ng_template_1_Template_input_focus_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r8); const ctx_r10 = ɵngcc0.ɵɵnextContext(); return ctx_r10.saveTimeAndChangeTimeUnit($event, ctx_r10.timeUnit); })("keydown", function NgxMatTimepickerDialControlComponent_ng_template_1_Template_input_keydown_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r8); const ctx_r11 = ɵngcc0.ɵɵnextContext(); return ctx_r11.onKeydown($event); })("keypress", function NgxMatTimepickerDialControlComponent_ng_template_1_Template_input_keypress_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r8); const ctx_r12 = ɵngcc0.ɵɵnextContext(); return ctx_r12.changeTimeByKeyboard($event); });
    ɵngcc0.ɵɵpipe(1, "timeLocalizer");
    ɵngcc0.ɵɵpipe(2, "ngxMatTimepickerParser");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(11, _c10, ctx_r2.isActive))("ngModel", ɵngcc0.ɵɵpipeBind3(1, 4, ɵngcc0.ɵɵpipeBind2(2, 8, ctx_r2.time, ctx_r2.timeUnit), ctx_r2.timeUnit, true))("disabled", ctx_r2.disabled)("ngxMatTimepickerAutofocus", ctx_r2.isActive);
} }
function NgxMatTimepickerPeriodComponent_div_5_Template(rf, ctx) { if (rf & 1) {
    const _r2 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 3);
    ɵngcc0.ɵɵlistener("@scaleInOut.done", function NgxMatTimepickerPeriodComponent_div_5_Template_div_animation_scaleInOut_done_0_listener() { ɵngcc0.ɵɵrestoreView(_r2); const ctx_r1 = ɵngcc0.ɵɵnextContext(); return ctx_r1.animationDone(); });
    ɵngcc0.ɵɵelementStart(1, "p");
    ɵngcc0.ɵɵtext(2, "Current time would be invalid in this period.");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵproperty("@scaleInOut", undefined);
} }
function NgxMatTimepickerContentComponent_div_0_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function NgxMatTimepickerContentComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div");
    ɵngcc0.ɵɵtemplate(1, NgxMatTimepickerContentComponent_div_0_ng_container_1_Template, 1, 0, "ng-container", 3);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext();
    const _r3 = ɵngcc0.ɵɵreference(4);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r3);
} }
function NgxMatTimepickerContentComponent_ng_template_1_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function NgxMatTimepickerContentComponent_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, NgxMatTimepickerContentComponent_ng_template_1_ng_container_0_Template, 1, 0, "ng-container", 3);
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext();
    const _r3 = ɵngcc0.ɵɵreference(4);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r3);
} }
function NgxMatTimepickerContentComponent_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0);
} }
const _c11 = ["*"];
function NgxMatTimepickerStandaloneComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "button", 14);
    ɵngcc0.ɵɵtext(1, "CANCEL ");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("color", ctx_r1.color);
} }
function NgxMatTimepickerStandaloneComponent_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "button", 14);
    ɵngcc0.ɵɵtext(1, "OK ");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("color", ctx_r3.color);
} }
function NgxMatTimepickerStandaloneComponent_div_14_ngx_mat_timepicker_24_hours_face_1_Template(rf, ctx) { if (rf & 1) {
    const _r12 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "ngx-mat-timepicker-24-hours-face", 17);
    ɵngcc0.ɵɵlistener("hourChange", function NgxMatTimepickerStandaloneComponent_div_14_ngx_mat_timepicker_24_hours_face_1_Template_ngx_mat_timepicker_24_hours_face_hourChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r12); const ctx_r11 = ɵngcc0.ɵɵnextContext(2); return ctx_r11.onHourChange($event); })("hourSelected", function NgxMatTimepickerStandaloneComponent_div_14_ngx_mat_timepicker_24_hours_face_1_Template_ngx_mat_timepicker_24_hours_face_hourSelected_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r12); const ctx_r13 = ɵngcc0.ɵɵnextContext(2); return ctx_r13.onHourSelected($event); });
    ɵngcc0.ɵɵpipe(1, "async");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r8 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("color", ctx_r8.color)("selectedHour", ɵngcc0.ɵɵpipeBind1(1, 5, ctx_r8.selectedHour))("minTime", ctx_r8.data.minTime)("maxTime", ctx_r8.data.maxTime)("format", ctx_r8.data.format);
} }
function NgxMatTimepickerStandaloneComponent_div_14_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    const _r15 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "ngx-mat-timepicker-12-hours-face", 18);
    ɵngcc0.ɵɵlistener("hourChange", function NgxMatTimepickerStandaloneComponent_div_14_ng_template_2_Template_ngx_mat_timepicker_12_hours_face_hourChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r15); const ctx_r14 = ɵngcc0.ɵɵnextContext(2); return ctx_r14.onHourChange($event); })("hourSelected", function NgxMatTimepickerStandaloneComponent_div_14_ng_template_2_Template_ngx_mat_timepicker_12_hours_face_hourSelected_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r15); const ctx_r16 = ɵngcc0.ɵɵnextContext(2); return ctx_r16.onHourSelected($event); });
    ɵngcc0.ɵɵpipe(1, "async");
    ɵngcc0.ɵɵpipe(2, "async");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r10 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("color", ctx_r10.color)("selectedHour", ɵngcc0.ɵɵpipeBind1(1, 5, ctx_r10.selectedHour))("period", ɵngcc0.ɵɵpipeBind1(2, 7, ctx_r10.selectedPeriod))("minTime", ctx_r10.data.minTime)("maxTime", ctx_r10.data.maxTime);
} }
function NgxMatTimepickerStandaloneComponent_div_14_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div");
    ɵngcc0.ɵɵtemplate(1, NgxMatTimepickerStandaloneComponent_div_14_ngx_mat_timepicker_24_hours_face_1_Template, 2, 7, "ngx-mat-timepicker-24-hours-face", 15);
    ɵngcc0.ɵɵtemplate(2, NgxMatTimepickerStandaloneComponent_div_14_ng_template_2_Template, 3, 9, "ng-template", null, 16, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const _r9 = ɵngcc0.ɵɵreference(3);
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r4.data.format === 24)("ngIfElse", _r9);
} }
function NgxMatTimepickerStandaloneComponent_ngx_mat_timepicker_minutes_face_15_Template(rf, ctx) { if (rf & 1) {
    const _r18 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "ngx-mat-timepicker-minutes-face", 19);
    ɵngcc0.ɵɵlistener("minuteChange", function NgxMatTimepickerStandaloneComponent_ngx_mat_timepicker_minutes_face_15_Template_ngx_mat_timepicker_minutes_face_minuteChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r18); const ctx_r17 = ɵngcc0.ɵɵnextContext(); return ctx_r17.onMinuteChange($event); });
    ɵngcc0.ɵɵpipe(1, "async");
    ɵngcc0.ɵɵpipe(2, "async");
    ɵngcc0.ɵɵpipe(3, "async");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext();
    let tmp_2_0;
    ɵngcc0.ɵɵproperty("color", ctx_r5.color)("selectedMinute", ɵngcc0.ɵɵpipeBind1(1, 8, ctx_r5.selectedMinute))("selectedHour", (tmp_2_0 = ɵngcc0.ɵɵpipeBind1(2, 10, ctx_r5.selectedHour)) == null ? null : tmp_2_0.time)("minTime", ctx_r5.data.minTime)("maxTime", ctx_r5.data.maxTime)("format", ctx_r5.data.format)("period", ɵngcc0.ɵɵpipeBind1(3, 12, ctx_r5.selectedPeriod))("minutesGap", ctx_r5.data.minutesGap);
} }
function NgxMatTimepickerStandaloneComponent_ng_container_18_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function NgxMatTimepickerStandaloneComponent_ng_container_20_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
const NgxMatTimepickerPeriods = {
    AM: "AM",
    PM: "PM",
};

/**
 * @fileoverview added by tsickle
 * Generated from: lib/models/ngx-mat-timepicker-format.enum.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const NgxMatTimepickerFormat = {
    TWELVE: "hh:mm a",
    TWELVE_SHORT: "h:m a",
    TWENTY_FOUR: "HH:mm",
    TWENTY_FOUR_SHORT: "H:m",
};

/**
 * @fileoverview added by tsickle
 * Generated from: lib/services/ngx-mat-timepicker-adapter.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// @dynamic
class NgxMatTimepickerAdapter {
    /**
     *
     *  Format hour according to time format (12 or 24)
     * @param {?} currentHour
     * @param {?} format
     * @param {?} period
     * @return {?}
     */
    static formatHour(currentHour, format, period) {
        if (format === 24) {
            return currentHour;
        }
        /** @type {?} */
        const hour = period === NgxMatTimepickerPeriods.AM ? currentHour : currentHour + 12;
        if (period === NgxMatTimepickerPeriods.AM && hour === 12) {
            return 0;
        }
        else if (period === NgxMatTimepickerPeriods.PM && hour === 24) {
            return 12;
        }
        return hour;
    }
    /**
     * @param {?} time
     * @param {?} opts
     * @return {?}
     */
    static formatTime(time, opts) {
        if (!time) {
            return "Invalid Time";
        }
        const { format } = opts;
        /** @type {?} */
        const parsedTime = NgxMatTimepickerAdapter.parseTime(time, opts).setLocale(NgxMatTimepickerAdapter.defaultLocale);
        if (format !== 24) {
            return parsedTime.toLocaleString(Object.assign(Object.assign({}, DateTime.TIME_SIMPLE), { hour12: format !== 24 })).replace(/\u200E/g, "");
        }
        return parsedTime.toISOTime({
            includeOffset: false,
            suppressMilliseconds: true,
            suppressSeconds: true
        }).replace(/\u200E/g, "");
    }
    /**
     * @param {?} time
     * @param {?} format
     * @return {?}
     */
    static fromDateTimeToString(time, format) {
        /** @type {?} */
        const timeFormat = format === 24 ? NgxMatTimepickerFormat.TWENTY_FOUR : NgxMatTimepickerFormat.TWELVE;
        return time.reconfigure({
            numberingSystem: NgxMatTimepickerAdapter.defaultNumberingSistem,
            locale: NgxMatTimepickerAdapter.defaultLocale
        }).toFormat(timeFormat);
    }
    /**
     * @param {?} time
     * @param {?} before
     * @param {?} after
     * @param {?=} unit
     * @return {?}
     */
    static isBetween(time, before, after, unit = "minutes") {
        if (unit === "hours") {
            return this.isSameOrBefore(time, after, unit) && this.isSameOrAfter(time, before, unit);
        }
        if (unit === "minutes") {
            return this.isSameOrBefore(time, after) && this.isSameOrAfter(time, before);
        }
    }
    /**
     * @param {?} time
     * @param {?} compareWith
     * @param {?=} unit
     * @return {?}
     */
    static isSameOrAfter(time, compareWith, unit = "minutes") {
        if (unit === "hours") {
            return time.hour >= compareWith.hour;
        }
        if (unit === "minutes") {
            return time.hasSame(compareWith, unit) || time.valueOf() > compareWith.valueOf();
        }
    }
    /**
     * @param {?} time
     * @param {?} compareWith
     * @param {?=} unit
     * @return {?}
     */
    static isSameOrBefore(time, compareWith, unit = "minutes") {
        if (unit === "hours") {
            return time.hour <= compareWith.hour;
        }
        if (unit === "minutes") {
            return time.hasSame(compareWith, unit) || time.valueOf() <= compareWith.valueOf();
        }
    }
    /**
     * @param {?} time
     * @param {?=} min
     * @param {?=} max
     * @param {?=} granularity
     * @param {?=} minutesGap
     * @param {?=} format
     * @return {?}
     */
    static isTimeAvailable(time, min, max, granularity, minutesGap, format) {
        if (!time) {
            return;
        }
        /** @type {?} */
        const convertedTime = this.parseTime(time, { format });
        /** @type {?} */
        const minutes = convertedTime.minute;
        if (minutesGap && minutes === minutes && minutes % minutesGap !== 0) {
            throw new Error(`Your minutes - ${minutes} doesn\'t match your minutesGap - ${minutesGap}`);
        }
        /** @type {?} */
        const isAfter = (min && !max)
            && this.isSameOrAfter(convertedTime, min, granularity);
        /** @type {?} */
        const isBefore = (max && !min)
            && this.isSameOrBefore(convertedTime, max, granularity);
        /** @type {?} */
        const between = (min && max)
            && this.isBetween(convertedTime, min, max, granularity);
        /** @type {?} */
        const isAvailable = !min && !max;
        return isAfter || isBefore || between || isAvailable;
    }
    /**
     * @param {?} time
     * @param {?} opts
     * @return {?}
     */
    static parseTime(time, opts) {
        const { numberingSystem, locale } = NgxMatTimepickerAdapter._getLocaleOptionsByTime(time, opts);
        /** @type {?} */
        const isPeriodExist = time.split(" ").length === 2;
        /** @type {?} */
        const timeMask = isPeriodExist ? NgxMatTimepickerFormat.TWELVE_SHORT : NgxMatTimepickerFormat.TWENTY_FOUR_SHORT;
        return DateTime.fromFormat(time, timeMask, { numberingSystem, locale });
    }
    /**
     * @param {?} time
     * @param {?=} opts
     * @return {?}
     */
    static toLocaleTimeString(time, opts = {}) {
        const { format = NgxMatTimepickerAdapter.defaultFormat, locale = NgxMatTimepickerAdapter.defaultLocale } = opts;
        /** @type {?} */
        const hourCycle = format === 24 ? "h23" : "h12";
        /** @type {?} */
        const timeFormat = Object.assign(Object.assign({}, DateTime.TIME_SIMPLE), { hourCycle });
        /** @type {?} */
        const timeMask = (format === 24) ? NgxMatTimepickerFormat.TWENTY_FOUR_SHORT : NgxMatTimepickerFormat.TWELVE_SHORT;
        return DateTime.fromFormat(time, timeMask).setLocale(locale).toLocaleString(timeFormat);
    }
    /**
     * @private
     * @param {?} time
     * @param {?} opts
     * @return {?}
     */
    static _getLocaleOptionsByTime(time, opts) {
        const { numberingSystem, locale } = DateTime.local().setLocale(opts.locale).resolvedLocaleOpts();
        /** @type {?} */
        const localeConfig = {
            numberingSystem: (/** @type {?} */ (numberingSystem)),
            locale
        };
        /** @type {?} */
        const defaultConfig = {
            numberingSystem: NgxMatTimepickerAdapter.defaultNumberingSistem,
            locale: NgxMatTimepickerAdapter.defaultLocale
        };
        return isNaN(parseInt(time, 10)) ? localeConfig : defaultConfig;
    }
}
NgxMatTimepickerAdapter.defaultFormat = 12;
NgxMatTimepickerAdapter.defaultLocale = "en-US";
NgxMatTimepickerAdapter.defaultNumberingSistem = "latn";

/**
 * @fileoverview added by tsickle
 * Generated from: lib/services/ngx-mat-timepicker.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DEFAULT_HOUR = {
    time: 12,
    angle: 360
};
/** @type {?} */
const DEFAULT_MINUTE = {
    time: 0,
    angle: 360
};
class NgxMatTimepickerService {
    constructor() {
        this._hour$ = new BehaviorSubject(DEFAULT_HOUR);
        this._minute$ = new BehaviorSubject(DEFAULT_MINUTE);
        this._period$ = new BehaviorSubject(NgxMatTimepickerPeriods.AM);
    }
    /**
     * @param {?} hour
     * @return {?}
     */
    set hour(hour) {
        this._hour$.next(hour);
    }
    /**
     * @param {?} minute
     * @return {?}
     */
    set minute(minute) {
        this._minute$.next(minute);
    }
    /**
     * @param {?} period
     * @return {?}
     */
    set period(period) {
        /** @type {?} */
        const isPeriodValid = (period === NgxMatTimepickerPeriods.AM) || (period === NgxMatTimepickerPeriods.PM);
        if (isPeriodValid) {
            this._period$.next(period);
        }
    }
    /**
     * @return {?}
     */
    get selectedHour() {
        return this._hour$.asObservable();
    }
    /**
     * @return {?}
     */
    get selectedMinute() {
        return this._minute$.asObservable();
    }
    /**
     * @return {?}
     */
    get selectedPeriod() {
        return this._period$.asObservable();
    }
    /**
     * @param {?} format
     * @return {?}
     */
    getFullTime(format) {
        /** @type {?} */
        const selectedHour = this._hour$.getValue().time;
        /** @type {?} */
        const selectedMinute = this._minute$.getValue().time;
        /** @type {?} */
        const hour = selectedHour != null ? selectedHour : DEFAULT_HOUR.time;
        /** @type {?} */
        const minute = selectedMinute != null ? selectedMinute : DEFAULT_MINUTE.time;
        /** @type {?} */
        const period = format === 12 ? this._period$.getValue() : "";
        /** @type {?} */
        const time = `${hour}:${minute} ${period}`.trim();
        return NgxMatTimepickerAdapter.formatTime(time, { format });
    }
    /**
     * @param {?} time
     * @param {?} min
     * @param {?} max
     * @param {?} format
     * @param {?=} minutesGap
     * @return {?}
     */
    setDefaultTimeIfAvailable(time, min, max, format, minutesGap) {
        /* Workaround to double error message*/
        try {
            if (NgxMatTimepickerAdapter.isTimeAvailable(time, min, max, "minutes", minutesGap)) {
                this._setDefaultTime(time, format);
            }
        }
        catch (e) {
            console.error(e);
        }
    }
    /**
     * @private
     * @return {?}
     */
    _resetTime() {
        this.hour = Object.assign({}, DEFAULT_HOUR);
        this.minute = Object.assign({}, DEFAULT_MINUTE);
        this.period = NgxMatTimepickerPeriods.AM;
    }
    /**
     * @private
     * @param {?} time
     * @param {?} format
     * @return {?}
     */
    _setDefaultTime(time, format) {
        /** @type {?} */
        const defaultTime = NgxMatTimepickerAdapter.parseTime(time, { format }).toJSDate();
        // Check on null, because invalid date will be null
        if (DateTime.fromJSDate(defaultTime) !== null) {
            /** @type {?} */
            const period = time.substr(time.length - 2).toUpperCase();
            /** @type {?} */
            const hour = defaultTime.getHours();
            this.hour = Object.assign(Object.assign({}, DEFAULT_HOUR), { time: formatHourByPeriod(hour, (/** @type {?} */ (period))) });
            this.minute = Object.assign(Object.assign({}, DEFAULT_MINUTE), { time: defaultTime.getMinutes() });
            this.period = (/** @type {?} */ (period));
        }
        else {
            this._resetTime();
        }
    }
}
NgxMatTimepickerService.ɵfac = function NgxMatTimepickerService_Factory(t) { return new (t || NgxMatTimepickerService)(); };
/** @nocollapse */ NgxMatTimepickerService.ɵprov = ɵɵdefineInjectable({ factory: function NgxMatTimepickerService_Factory() { return new NgxMatTimepickerService(); }, token: NgxMatTimepickerService, providedIn: "root" });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxMatTimepickerService, [{
        type: Injectable,
        args: [{
                providedIn: "root"
            }]
    }], function () { return []; }, null); })();
/**
 *
 *  Format hour in 24hours format to meridian (AM or PM) format
 * @param {?} hour
 * @param {?} period
 * @return {?}
 */
function formatHourByPeriod(hour, period) {
    switch (period) {
        case NgxMatTimepickerPeriods.AM:
            return hour === 0 ? 12 : hour;
        case NgxMatTimepickerPeriods.PM:
            return hour === 12 ? 12 : hour - 12;
        default:
            return hour;
    }
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/models/ngx-mat-timepicker-units.enum.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const NgxMatTimepickerUnits = {
    HOUR: 0,
    MINUTE: 1,
};
NgxMatTimepickerUnits[NgxMatTimepickerUnits.HOUR] = 'HOUR';
NgxMatTimepickerUnits[NgxMatTimepickerUnits.MINUTE] = 'MINUTE';

/**
 * @fileoverview added by tsickle
 * Generated from: lib/tokens/ngx-mat-timepicker-time-locale.token.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const NGX_MAT_TIMEPICKER_LOCALE = new InjectionToken("TimeLocale", {
    providedIn: "root",
    factory: (/**
     * @return {?}
     */
    () => NgxMatTimepickerAdapter.defaultLocale)
});

/**
 * @fileoverview added by tsickle
 * Generated from: lib/utils/ngx-mat-timepicker.utils.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// @dynamic
class NgxMatTimepickerUtils {
    /**
     * @param {?} hours
     * @param {?} config
     * @return {?}
     */
    static disableHours(hours, config) {
        if (config.min || config.max) {
            return hours.map((/**
             * @param {?} value
             * @return {?}
             */
            value => {
                /** @type {?} */
                const hour = config.format === 24 ? value.time : NgxMatTimepickerAdapter.formatHour(value.time, config.format, config.period);
                /** @type {?} */
                const currentTime = DateTime.fromObject({ hour }).toFormat(NgxMatTimepickerFormat.TWELVE);
                return Object.assign(Object.assign({}, value), { disabled: !NgxMatTimepickerAdapter.isTimeAvailable(currentTime, config.min, config.max, "hours") });
            }));
        }
        return hours;
    }
    /**
     * @param {?} minutes
     * @param {?} selectedHour
     * @param {?} config
     * @return {?}
     */
    static disableMinutes(minutes, selectedHour, config) {
        if (config.min || config.max) {
            /** @type {?} */
            const hour = NgxMatTimepickerAdapter.formatHour(selectedHour, config.format, config.period);
            return minutes.map((/**
             * @param {?} value
             * @return {?}
             */
            value => {
                /** @type {?} */
                const currentTime = DateTime.fromObject({
                    hour,
                    minute: value.time
                }).toFormat(NgxMatTimepickerFormat.TWELVE);
                return Object.assign(Object.assign({}, value), { disabled: !NgxMatTimepickerAdapter.isTimeAvailable(currentTime, config.min, config.max, "minutes") });
            }));
        }
        return minutes;
    }
    /**
     * @param {?} format
     * @return {?}
     */
    static getHours(format) {
        return Array(format).fill(1).map((/**
         * @param {?} v
         * @param {?} i
         * @return {?}
         */
        (v, i) => {
            /** @type {?} */
            const angleStep = 30;
            /** @type {?} */
            const time = v + i;
            /** @type {?} */
            const angle = angleStep * time;
            return { time: time === 24 ? 0 : time, angle };
        }));
    }
    /**
     * @param {?=} gap
     * @return {?}
     */
    static getMinutes(gap = 1) {
        /** @type {?} */
        const minutesCount = 60;
        /** @type {?} */
        const angleStep = 360 / minutesCount;
        /** @type {?} */
        const minutes = [];
        for (let i = 0; i < minutesCount; i++) {
            /** @type {?} */
            const angle = angleStep * i;
            if (i % gap === 0) {
                minutes.push({ time: i, angle: angle !== 0 ? angle : 360 });
            }
        }
        return minutes;
    }
    /**
     * @param {?} e
     * @return {?}
     */
    static isDigit(e) {
        // Allow: backspace, delete, tab, escape, enter
        if ([46, 8, 9, 27, 13].some((/**
         * @param {?} n
         * @return {?}
         */
        n => n === e.keyCode)) ||
            // Allow: Ctrl/cmd+A
            (e.keyCode == 65 && (e.ctrlKey === true || e.metaKey === true)) ||
            // Allow: Ctrl/cmd+C
            (e.keyCode == 67 && (e.ctrlKey === true || e.metaKey === true)) ||
            // Allow: Ctrl/cmd+X
            (e.keyCode == 88 && (e.ctrlKey === true || e.metaKey === true)) ||
            // Allow: home, end, left, right, up, down
            (e.keyCode >= 35 && e.keyCode <= 40)) {
            return true;
        }
        return !((e.keyCode < 48 || e.keyCode > 57) && (e.keyCode < 96 || e.keyCode > 105));
    }
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/components/ngx-mat-timepicker-field/ngx-mat-timepicker-field.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxMatTimepickerFieldComponent {
    /**
     * @param {?} _timepickerService
     * @param {?} _locale
     */
    constructor(_timepickerService, _locale) {
        this._timepickerService = _timepickerService;
        this._locale = _locale;
        this.maxHour = 12;
        this.minHour = 1;
        this.period = NgxMatTimepickerPeriods.AM;
        this.periods = [
            NgxMatTimepickerPeriods.AM,
            NgxMatTimepickerPeriods.PM
        ];
        this.timeChanged = new EventEmitter();
        this.timeUnit = NgxMatTimepickerUnits;
        this._color = "primary";
        this._floatLabel = "never";
        this._format = 12;
        this._isFirstTimeChange = true;
        this._subsCtrl$ = new Subject();
        this._onChange = (/**
         * @return {?}
         */
        () => {
        });
    }
    /**
     * @return {?}
     */
    get color() {
        return this._color;
    }
    /**
     * @param {?} newValue
     * @return {?}
     */
    set color(newValue) {
        this._color = newValue;
    }
    /**
     * @return {?}
     */
    get defaultTime() {
        return this._defaultTime;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set defaultTime(val) {
        this._defaultTime = val;
        this._isDefaultTime = !!val;
    }
    /**
     * @return {?}
     */
    get floatLabel() {
        return this._floatLabel;
    }
    /**
     * @param {?} newValue
     * @return {?}
     */
    set floatLabel(newValue) {
        this._floatLabel = newValue;
    }
    /**
     * @return {?}
     */
    get format() {
        return this._format;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set format(value) {
        this._format = value === 24 ? 24 : 12;
        this.minHour = this._format === 12 ? 1 : 0;
        this.maxHour = this._format === 12 ? 12 : 23;
        this.hoursList = NgxMatTimepickerUtils.getHours(this._format);
        /** @type {?} */
        const isDynamicallyChanged = value && (this._previousFormat && this._previousFormat !== this._format);
        if (isDynamicallyChanged) {
            this._updateTime(this.timepickerTime);
        }
        this._previousFormat = this._format;
    }
    /**
     * @return {?}
     */
    get max() {
        return this._max;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set max(value) {
        if (typeof value === "string") {
            this._max = NgxMatTimepickerAdapter.parseTime(value, { locale: this._locale, format: this.format });
            return;
        }
        this._max = value;
    }
    /**
     * @return {?}
     */
    get min() {
        return this._min;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set min(value) {
        if (typeof value === "string") {
            this._min = NgxMatTimepickerAdapter.parseTime(value, { locale: this._locale, format: this.format });
            return;
        }
        this._min = value;
    }
    /**
     * @param {?} hour
     * @return {?}
     */
    changeHour(hour) {
        this._timepickerService.hour = this.hoursList.find((/**
         * @param {?} h
         * @return {?}
         */
        h => h.time === hour));
        this._changeTime();
    }
    /**
     * @param {?} minute
     * @return {?}
     */
    changeMinute(minute) {
        this._timepickerService.minute = this.minutesList.find((/**
         * @param {?} m
         * @return {?}
         */
        m => m.time === minute));
        this._changeTime();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    changePeriod(event) {
        this._timepickerService.period = (/** @type {?} */ (event.value));
        this._changeTime();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._subsCtrl$.next();
        this._subsCtrl$.complete();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._initTime(this.defaultTime);
        this.hoursList = NgxMatTimepickerUtils.getHours(this._format);
        this.minutesList = NgxMatTimepickerUtils.getMinutes();
        this.isTimeRangeSet = !!(this.min || this.max);
        this.hour$ = (/** @type {?} */ (this._timepickerService.selectedHour.pipe(tap((/**
         * @param {?} clockTime
         * @return {?}
         */
        (clockTime) => this._selectedHour = clockTime.time)), map(this._changeDefaultTimeValue.bind(this)), tap((/**
         * @return {?}
         */
        () => this.isTimeRangeSet && this._updateAvailableMinutes())))));
        this.minute$ = (/** @type {?} */ (this._timepickerService.selectedMinute.pipe(map(this._changeDefaultTimeValue.bind(this)), tap((/**
         * @return {?}
         */
        () => this._isFirstTimeChange = false)))));
        if (this.format === 12) {
            this._timepickerService.selectedPeriod.pipe(distinctUntilChanged(), tap((/**
             * @param {?} period
             * @return {?}
             */
            (period) => this.period = period)), tap((/**
             * @param {?} period
             * @return {?}
             */
            period => this.isChangePeriodDisabled = this._isPeriodDisabled(period))), takeUntil(this._subsCtrl$)).subscribe((/**
             * @return {?}
             */
            () => this.isTimeRangeSet && this._updateAvailableTime()));
        }
    }
    /**
     * @param {?} time
     * @return {?}
     */
    onTimeSet(time) {
        this._updateTime(time);
        this._emitLocalTimeChange(time);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this._onChange = fn;
    }
    /**
     * @param {?} _fn_
     * @return {?}
     */
    registerOnTouched(_fn_) {
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    writeValue(val) {
        if (val) {
            this._initTime(val);
        }
        else {
            this._resetTime();
        }
    }
    /**
     * @private
     * @param {?} clockFaceTime
     * @return {?}
     */
    _changeDefaultTimeValue(clockFaceTime) {
        if (!this._isDefaultTime && this._isFirstTimeChange) {
            return Object.assign(Object.assign({}, clockFaceTime), { time: null });
        }
        return clockFaceTime;
    }
    /**
     * @private
     * @return {?}
     */
    _changeTime() {
        /** @type {?} */
        const time = this._timepickerService.getFullTime(this.format);
        this.timepickerTime = time;
        this._emitLocalTimeChange(time);
    }
    /**
     * @private
     * @param {?} time
     * @return {?}
     */
    _emitLocalTimeChange(time) {
        /** @type {?} */
        const localTime = NgxMatTimepickerAdapter.toLocaleTimeString(time, { format: this.format, locale: this._locale });
        this._onChange(localTime);
        this.timeChanged.emit(localTime);
    }
    /**
     * @private
     * @param {?} time
     * @return {?}
     */
    _initTime(time) {
        /** @type {?} */
        const isDefaultTimeAvailable = NgxMatTimepickerAdapter
            .isTimeAvailable(time, (/** @type {?} */ (this.min)), (/** @type {?} */ (this.max)), "minutes", null, this.format);
        if (!isDefaultTimeAvailable) {
            if (this.min) {
                this._updateTime(NgxMatTimepickerAdapter.fromDateTimeToString((/** @type {?} */ (this.min)), this.format));
                return;
            }
            if (this.max) {
                this._updateTime(NgxMatTimepickerAdapter.fromDateTimeToString((/** @type {?} */ (this.max)), this.format));
                return;
            }
        }
        this._updateTime(time);
    }
    /**
     * @private
     * @param {?} period
     * @return {?}
     */
    _isPeriodDisabled(period) {
        return NgxMatTimepickerUtils.disableHours(NgxMatTimepickerUtils.getHours(12), {
            min: (/** @type {?} */ (this.min)),
            max: (/** @type {?} */ (this.max)),
            format: 12,
            period: period === NgxMatTimepickerPeriods.AM ? NgxMatTimepickerPeriods.PM : NgxMatTimepickerPeriods.AM
        }).every((/**
         * @param {?} time
         * @return {?}
         */
        time => time.disabled));
    }
    /**
     * @private
     * @return {?}
     */
    _resetTime() {
        this._timepickerService.hour = { angle: 0, time: null };
        this._timepickerService.minute = { angle: 0, time: null };
    }
    /**
     * @private
     * @return {?}
     */
    _updateAvailableHours() {
        this.hoursList = NgxMatTimepickerUtils.disableHours(this.hoursList, {
            min: (/** @type {?} */ (this.min)),
            max: (/** @type {?} */ (this.max)),
            format: this.format,
            period: this.period
        });
    }
    /**
     * @private
     * @return {?}
     */
    _updateAvailableMinutes() {
        this.minutesList = NgxMatTimepickerUtils.disableMinutes(this.minutesList, this._selectedHour, {
            min: (/** @type {?} */ (this.min)),
            max: (/** @type {?} */ (this.max)),
            format: this.format,
            period: this.period
        });
    }
    /**
     * @private
     * @return {?}
     */
    _updateAvailableTime() {
        this._updateAvailableHours();
        if (this._selectedHour) {
            this._updateAvailableMinutes();
        }
    }
    /**
     * @private
     * @param {?} time
     * @return {?}
     */
    _updateTime(time) {
        if (time) {
            /** @type {?} */
            const formattedTime = NgxMatTimepickerAdapter.formatTime(time, { locale: this._locale, format: this.format });
            this._timepickerService.setDefaultTimeIfAvailable(formattedTime, (/** @type {?} */ (this.min)), (/** @type {?} */ (this.max)), this.format);
            this.timepickerTime = formattedTime;
        }
    }
}
NgxMatTimepickerFieldComponent.ɵfac = function NgxMatTimepickerFieldComponent_Factory(t) { return new (t || NgxMatTimepickerFieldComponent)(ɵngcc0.ɵɵdirectiveInject(NgxMatTimepickerService), ɵngcc0.ɵɵdirectiveInject(NGX_MAT_TIMEPICKER_LOCALE)); };
NgxMatTimepickerFieldComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NgxMatTimepickerFieldComponent, selectors: [["ngx-mat-timepicker-field"]], inputs: { color: "color", defaultTime: "defaultTime", floatLabel: "floatLabel", format: "format", max: "max", min: "min", disabled: "disabled", cancelBtnTmpl: "cancelBtnTmpl", clockTheme: "clockTheme", confirmBtnTmpl: "confirmBtnTmpl", controlOnly: "controlOnly", toggleIcon: "toggleIcon" }, outputs: { timeChanged: "timeChanged" }, features: [ɵngcc0.ɵɵProvidersFeature([
            NgxMatTimepickerService,
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: NgxMatTimepickerFieldComponent,
                multi: true
            }
        ])], decls: 13, vars: 37, consts: [[1, "ngx-mat-timepicker", 3, "ngClass"], [1, "ngx-mat-timepicker__control--first", 3, "color", "floatLabel", "placeholder", "time", "min", "max", "timeUnit", "disabled", "timeList", "preventTyping", "timeChanged"], [1, "separator-colon", "ngx-mat-timepicker__control--second"], [1, "ngx-mat-timepicker__control--third", 3, "color", "floatLabel", "placeholder", "time", "min", "max", "timeUnit", "disabled", "timeList", "preventTyping", "timeChanged"], ["class", "period-select ngx-mat-timepicker__control--forth", 3, "color", 4, "ngIf"], ["class", "ngx-mat-timepicker__toggle", 3, "for", "disabled", 4, "ngIf"], [3, "color", "min", "max", "theme", "defaultTime", "format", "cancelBtnTmpl", "confirmBtnTmpl", "timeSet"], ["timepicker", ""], ["defaultIcon", ""], [1, "period-select", "ngx-mat-timepicker__control--forth", 3, "color"], [3, "disabled", "ngModel", "selectionChange"], [3, "value", 4, "ngFor", "ngForOf"], [3, "value"], [1, "ngx-mat-timepicker__toggle", 3, "for", "disabled"], ["ngxMatTimepickerToggleIcon", ""], [4, "ngTemplateOutlet"]], template: function NgxMatTimepickerFieldComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "ngx-mat-timepicker-time-control", 1);
        ɵngcc0.ɵɵlistener("timeChanged", function NgxMatTimepickerFieldComponent_Template_ngx_mat_timepicker_time_control_timeChanged_1_listener($event) { return ctx.changeHour($event); });
        ɵngcc0.ɵɵpipe(2, "async");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "span", 2);
        ɵngcc0.ɵɵtext(4, ":");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(5, "ngx-mat-timepicker-time-control", 3);
        ɵngcc0.ɵɵlistener("timeChanged", function NgxMatTimepickerFieldComponent_Template_ngx_mat_timepicker_time_control_timeChanged_5_listener($event) { return ctx.changeMinute($event); });
        ɵngcc0.ɵɵpipe(6, "async");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(7, NgxMatTimepickerFieldComponent_mat_form_field_7_Template, 3, 4, "mat-form-field", 4);
        ɵngcc0.ɵɵtemplate(8, NgxMatTimepickerFieldComponent_ngx_mat_timepicker_toggle_8_Template, 3, 3, "ngx-mat-timepicker-toggle", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(9, "ngx-mat-timepicker", 6, 7);
        ɵngcc0.ɵɵlistener("timeSet", function NgxMatTimepickerFieldComponent_Template_ngx_mat_timepicker_timeSet_9_listener($event) { return ctx.onTimeSet($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(11, NgxMatTimepickerFieldComponent_ng_template_11_Template, 2, 0, "ng-template", null, 8, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        let tmp_4_0;
        let tmp_14_0;
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(35, _c0, ctx.disabled));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("color", ctx.color)("floatLabel", ctx.floatLabel)("placeholder", "HH")("time", (tmp_4_0 = ɵngcc0.ɵɵpipeBind1(2, 31, ctx.hour$)) == null ? null : tmp_4_0.time)("min", ctx.minHour)("max", ctx.maxHour)("timeUnit", ctx.timeUnit.HOUR)("disabled", ctx.disabled)("timeList", ctx.hoursList)("preventTyping", ctx.isTimeRangeSet);
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵproperty("color", ctx.color)("floatLabel", ctx.floatLabel)("placeholder", "MM")("time", (tmp_14_0 = ɵngcc0.ɵɵpipeBind1(6, 33, ctx.minute$)) == null ? null : tmp_14_0.time)("min", 0)("max", 59)("timeUnit", ctx.timeUnit.MINUTE)("disabled", ctx.disabled)("timeList", ctx.minutesList)("preventTyping", ctx.isTimeRangeSet);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.format !== 24);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.controlOnly);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("color", ctx.color)("min", ctx.min)("max", ctx.max)("theme", ctx.clockTheme)("defaultTime", ctx.timepickerTime)("format", ctx.format)("cancelBtnTmpl", ctx.cancelBtnTmpl)("confirmBtnTmpl", ctx.confirmBtnTmpl);
    } }, directives: function () { return [ɵngcc1.NgClass, NgxMatTimepickerControlComponent, ɵngcc1.NgIf, NgxMatTimepickerComponent, ɵngcc2.MatFormField, ɵngcc3.MatSelect, ɵngcc4.NgControlStatus, ɵngcc4.NgModel, ɵngcc1.NgForOf, ɵngcc5.MatOption, NgxMatTimepickerToggleComponent, NgxMatTimepickerToggleIconDirective, ɵngcc1.NgTemplateOutlet, ɵngcc6.MatIcon]; }, pipes: function () { return [ɵngcc1.AsyncPipe]; }, styles: [".ngx-mat-timepicker{display:flex;align-items:center;height:100%}.ngx-mat-timepicker--disabled{background:rgba(0,0,0,.07);pointer-events:none}.ngx-mat-timepicker .separator-colon{margin-left:5px;margin-right:5px}.ngx-mat-timepicker .period-select{width:60px;min-width:60px;margin-left:8px;text-align:center}.ngx-mat-timepicker__control--first{order:1}.ngx-mat-timepicker__control--second{order:2}.ngx-mat-timepicker__control--third{order:3}.ngx-mat-timepicker__control--forth,.ngx-mat-timepicker__toggle{order:4}"], encapsulation: 2, changeDetection: 0 });
/** @nocollapse */
NgxMatTimepickerFieldComponent.ctorParameters = () => [
    { type: NgxMatTimepickerService },
    { type: String, decorators: [{ type: Inject, args: [NGX_MAT_TIMEPICKER_LOCALE,] }] }
];
NgxMatTimepickerFieldComponent.propDecorators = {
    color: [{ type: Input }],
    defaultTime: [{ type: Input }],
    floatLabel: [{ type: Input }],
    format: [{ type: Input }],
    max: [{ type: Input }],
    min: [{ type: Input }],
    cancelBtnTmpl: [{ type: Input }],
    clockTheme: [{ type: Input }],
    confirmBtnTmpl: [{ type: Input }],
    controlOnly: [{ type: Input }],
    disabled: [{ type: Input }],
    timeChanged: [{ type: Output }],
    toggleIcon: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxMatTimepickerFieldComponent, [{
        type: Component,
        args: [{
                selector: "ngx-mat-timepicker-field",
                template: "<div class=\"ngx-mat-timepicker\"\n     [ngClass]=\"{'ngx-mat-timepicker--disabled': disabled}\">\n    <ngx-mat-timepicker-time-control\n            class=\"ngx-mat-timepicker__control--first\"\n            [color]=\"color\"\n            [floatLabel]=\"floatLabel\"\n            [placeholder]=\"'HH'\"\n            [time]=\"(hour$ | async)?.time\"\n            [min]=\"minHour\"\n            [max]=\"maxHour\"\n            [timeUnit]=\"timeUnit.HOUR\"\n            [disabled]=\"disabled\"\n            [timeList]=\"hoursList\"\n            [preventTyping]=\"isTimeRangeSet\"\n            (timeChanged)=\"changeHour($event)\"></ngx-mat-timepicker-time-control>\n    <span class=\"separator-colon ngx-mat-timepicker__control--second\">:</span>\n    <ngx-mat-timepicker-time-control\n            class=\"ngx-mat-timepicker__control--third\"\n            [color]=\"color\"\n            [floatLabel]=\"floatLabel\"\n            [placeholder]=\"'MM'\"\n            [time]=\"(minute$ | async)?.time\"\n            [min]=\"0\"\n            [max]=\"59\"\n            [timeUnit]=\"timeUnit.MINUTE\"\n            [disabled]=\"disabled\"\n            [timeList]=\"minutesList\"\n            [preventTyping]=\"isTimeRangeSet\"\n            (timeChanged)=\"changeMinute($event)\"></ngx-mat-timepicker-time-control>\n    <mat-form-field class=\"period-select ngx-mat-timepicker__control--forth\"\n                    *ngIf=\"format !== 24\"\n                    [color]=\"color\">\n        <mat-select [disabled]=\"disabled || isChangePeriodDisabled\"\n                    (selectionChange)=\"changePeriod($event)\"\n                    [ngModel]=\"period\">\n            <mat-option *ngFor=\"let option of periods\"\n                        [value]=\"option\">{{option}}</mat-option>\n        </mat-select>\n    </mat-form-field>\n    <ngx-mat-timepicker-toggle\n            class=\"ngx-mat-timepicker__toggle\"\n            *ngIf=\"!controlOnly\"\n            [for]=\"timepicker\"\n            [disabled]=\"disabled\">\n        <span ngxMatTimepickerToggleIcon>\n            <ng-container *ngTemplateOutlet=\"toggleIcon || defaultIcon\"></ng-container>\n        </span>\n    </ngx-mat-timepicker-toggle>\n</div>\n<ngx-mat-timepicker\n        [color]=\"color\"\n        [min]=\"min\"\n        [max]=\"max\"\n        [theme]=\"clockTheme\"\n        [defaultTime]=\"timepickerTime\"\n        [format]=\"format\"\n        [cancelBtnTmpl]=\"cancelBtnTmpl\"\n        [confirmBtnTmpl]=\"confirmBtnTmpl\"\n        (timeSet)=\"onTimeSet($event)\"\n        #timepicker></ngx-mat-timepicker>\n\n<ng-template #defaultIcon>\n    <mat-icon>watch_later</mat-icon>\n</ng-template>\n",
                providers: [
                    NgxMatTimepickerService,
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: NgxMatTimepickerFieldComponent,
                        multi: true
                    }
                ],
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                styles: [".ngx-mat-timepicker{display:flex;align-items:center;height:100%}.ngx-mat-timepicker--disabled{background:rgba(0,0,0,.07);pointer-events:none}.ngx-mat-timepicker .separator-colon{margin-left:5px;margin-right:5px}.ngx-mat-timepicker .period-select{width:60px;min-width:60px;margin-left:8px;text-align:center}.ngx-mat-timepicker__control--first{order:1}.ngx-mat-timepicker__control--second{order:2}.ngx-mat-timepicker__control--third{order:3}.ngx-mat-timepicker__control--forth,.ngx-mat-timepicker__toggle{order:4}"]
            }]
    }], function () { return [{ type: NgxMatTimepickerService }, { type: String, decorators: [{
                type: Inject,
                args: [NGX_MAT_TIMEPICKER_LOCALE]
            }] }]; }, { timeChanged: [{
            type: Output
        }], color: [{
            type: Input
        }], defaultTime: [{
            type: Input
        }], floatLabel: [{
            type: Input
        }], format: [{
            type: Input
        }], max: [{
            type: Input
        }], min: [{
            type: Input
        }], disabled: [{
            type: Input
        }], cancelBtnTmpl: [{
            type: Input
        }], clockTheme: [{
            type: Input
        }], confirmBtnTmpl: [{
            type: Input
        }], controlOnly: [{
            type: Input
        }], toggleIcon: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/ngx-mat-timepicker-toggle-icon.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/* To override a default toggle icon */
class NgxMatTimepickerToggleIconDirective {
}
NgxMatTimepickerToggleIconDirective.ɵfac = function NgxMatTimepickerToggleIconDirective_Factory(t) { return new (t || NgxMatTimepickerToggleIconDirective)(); };
NgxMatTimepickerToggleIconDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NgxMatTimepickerToggleIconDirective, selectors: [["", "ngxMatTimepickerToggleIcon", ""]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxMatTimepickerToggleIconDirective, [{
        type: Directive,
        args: [{ selector: "[ngxMatTimepickerToggleIcon]" }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * Generated from: lib/services/ngx-mat-timepicker-event.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxMatTimepickerEventService {
    constructor() {
        this._backdropClick$ = new Subject();
        this._keydownEvent$ = new Subject();
    }
    /**
     * @return {?}
     */
    get backdropClick() {
        return this._backdropClick$.asObservable().pipe(shareReplay({ bufferSize: 1, refCount: true }));
    }
    /**
     * @return {?}
     */
    get keydownEvent() {
        return this._keydownEvent$.asObservable().pipe(shareReplay({ bufferSize: 1, refCount: true }));
    }
    /**
     * @param {?} event
     * @return {?}
     */
    dispatchEvent(event) {
        switch (event.type) {
            case "click":
                this._backdropClick$.next((/** @type {?} */ (event)));
                break;
            case "keydown":
                this._keydownEvent$.next((/** @type {?} */ (event)));
                break;
            default:
                throw new Error("no such event type");
        }
    }
}
NgxMatTimepickerEventService.ɵfac = function NgxMatTimepickerEventService_Factory(t) { return new (t || NgxMatTimepickerEventService)(); };
/** @nocollapse */
NgxMatTimepickerEventService.ctorParameters = () => [];
/** @nocollapse */ NgxMatTimepickerEventService.ɵprov = ɵɵdefineInjectable({ factory: function NgxMatTimepickerEventService_Factory() { return new NgxMatTimepickerEventService(); }, token: NgxMatTimepickerEventService, providedIn: "root" });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxMatTimepickerEventService, [{
        type: Injectable,
        args: [{
                providedIn: "root"
            }]
    }], function () { return []; }, null); })();

/**
 * @fileoverview added by tsickle
 * Generated from: lib/tokens/ngx-mat-timepicker-config.token.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const NGX_MAT_TIMEPICKER_CONFIG = new InjectionToken("NGX_MAT_TIMEPICKER_CONFIG");

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/ngx-mat-timepicker-base.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxMatTimepickerBaseDirective {
    /**
     * @param {?} _timepickerSrv
     * @param {?} _eventSrv
     * @param {?} _locale
     * @param {?} data
     */
    constructor(_timepickerSrv, _eventSrv, _locale, data) {
        this._timepickerSrv = _timepickerSrv;
        this._eventSrv = _eventSrv;
        this._locale = _locale;
        this.data = data;
        this.activeTimeUnit = NgxMatTimepickerUnits.HOUR;
        this.timeUnit = NgxMatTimepickerUnits;
        this._color = "primary";
        this._subsCtrl$ = new Subject();
        this.color = data.color;
        this.defaultTime = data.defaultTime;
    }
    /**
     * @param {?} newValue
     * @return {?}
     */
    set color(newValue) {
        this._color = newValue;
    }
    /**
     * @return {?}
     */
    get color() {
        return this._color;
    }
    /**
     * @return {?}
     */
    get defaultTime() {
        return this._defaultTime;
    }
    /**
     * @param {?} time
     * @return {?}
     */
    set defaultTime(time) {
        this._defaultTime = time;
        this._setDefaultTime(time);
    }
    /**
     * @param {?} period
     * @return {?}
     */
    changePeriod(period) {
        this._timepickerSrv.period = period;
        this._onTimeChange();
    }
    /**
     * @param {?} unit
     * @return {?}
     */
    changeTimeUnit(unit) {
        this.activeTimeUnit = unit;
    }
    /**
     * @return {?}
     */
    close() {
        this.data.timepickerBaseRef.close();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._subsCtrl$.next();
        this._subsCtrl$.complete();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._defineTime();
        this.selectedHour = this._timepickerSrv.selectedHour
            .pipe(shareReplay({ bufferSize: 1, refCount: true }));
        this.selectedMinute = this._timepickerSrv.selectedMinute
            .pipe(shareReplay({ bufferSize: 1, refCount: true }));
        this.selectedPeriod = this._timepickerSrv.selectedPeriod
            .pipe(shareReplay({ bufferSize: 1, refCount: true }));
        this.data.timepickerBaseRef.timeUpdated.pipe(takeUntil(this._subsCtrl$))
            .subscribe(this._setDefaultTime.bind(this));
    }
    /**
     * @param {?} hour
     * @return {?}
     */
    onHourChange(hour) {
        this._timepickerSrv.hour = hour;
        this._onTimeChange();
    }
    /**
     * @param {?} hour
     * @return {?}
     */
    onHourSelected(hour) {
        if (!this.data.hoursOnly) {
            this.changeTimeUnit(NgxMatTimepickerUnits.MINUTE);
        }
        this.data.timepickerBaseRef.hourSelected.next(hour);
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onKeydown(e) {
        this._eventSrv.dispatchEvent(e);
        e.stopPropagation();
    }
    /**
     * @param {?} minute
     * @return {?}
     */
    onMinuteChange(minute) {
        this._timepickerSrv.minute = minute;
        this._onTimeChange();
    }
    /**
     * @return {?}
     */
    setTime() {
        this.data.timepickerBaseRef.timeSet.next(this._timepickerSrv.getFullTime(this.data.format));
        this.close();
    }
    /**
     * @protected
     * @return {?}
     */
    _defineTime() {
        /** @type {?} */
        const minTime = this.data.minTime;
        if (minTime && (!this.data.time && !this.data.defaultTime)) {
            /** @type {?} */
            const time = NgxMatTimepickerAdapter.fromDateTimeToString(minTime, this.data.format);
            this._setDefaultTime(time);
        }
    }
    /**
     * @protected
     * @return {?}
     */
    _onTimeChange() {
        /** @type {?} */
        const time = NgxMatTimepickerAdapter.toLocaleTimeString(this._timepickerSrv.getFullTime(this.data.format), {
            locale: this._locale,
            format: this.data.format
        });
        this.data.timepickerBaseRef.timeChanged.emit(time);
    }
    /**
     * @protected
     * @param {?} time
     * @return {?}
     */
    _setDefaultTime(time) {
        this._timepickerSrv.setDefaultTimeIfAvailable(time, this.data.minTime, this.data.maxTime, this.data.format, this.data.minutesGap);
    }
}
NgxMatTimepickerBaseDirective.ɵfac = function NgxMatTimepickerBaseDirective_Factory(t) { return new (t || NgxMatTimepickerBaseDirective)(ɵngcc0.ɵɵdirectiveInject(NgxMatTimepickerService), ɵngcc0.ɵɵdirectiveInject(NgxMatTimepickerEventService), ɵngcc0.ɵɵdirectiveInject(NGX_MAT_TIMEPICKER_LOCALE), ɵngcc0.ɵɵdirectiveInject(NGX_MAT_TIMEPICKER_CONFIG, 8)); };
NgxMatTimepickerBaseDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NgxMatTimepickerBaseDirective, selectors: [["", "ngxMatTimepickerBase", ""]], hostBindings: function NgxMatTimepickerBaseDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown", function NgxMatTimepickerBaseDirective_keydown_HostBindingHandler($event) { return ctx.onKeydown($event); });
    } }, inputs: { color: "color", defaultTime: "defaultTime" } });
/** @nocollapse */
NgxMatTimepickerBaseDirective.ctorParameters = () => [
    { type: NgxMatTimepickerService },
    { type: NgxMatTimepickerEventService },
    { type: String, decorators: [{ type: Inject, args: [NGX_MAT_TIMEPICKER_LOCALE,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [NGX_MAT_TIMEPICKER_CONFIG,] }, { type: Optional }] }
];
NgxMatTimepickerBaseDirective.propDecorators = {
    color: [{ type: Input }],
    defaultTime: [{ type: Input }],
    onKeydown: [{ type: HostListener, args: ["keydown", ["$event"],] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxMatTimepickerBaseDirective, [{
        type: Directive,
        args: [{
                selector: "[ngxMatTimepickerBase]"
            }]
    }], function () { return [{ type: NgxMatTimepickerService }, { type: NgxMatTimepickerEventService }, { type: String, decorators: [{
                type: Inject,
                args: [NGX_MAT_TIMEPICKER_LOCALE]
            }] }, { type: undefined, decorators: [{
                type: Inject,
                args: [NGX_MAT_TIMEPICKER_CONFIG]
            }, {
                type: Optional
            }] }]; }, { color: [{
            type: Input
        }], defaultTime: [{
            type: Input
        }], 
    /**
     * @param {?} e
     * @return {?}
     */
    onKeydown: [{
            type: HostListener,
            args: ["keydown", ["$event"]]
        }] }); })();

/**
 * @fileoverview added by tsickle
 * Generated from: lib/components/ngx-mat-timepicker-dialog/ngx-mat-timepicker-dialog.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
//
class NgxMatTimepickerDialogComponent extends NgxMatTimepickerBaseDirective {
    /**
     * @param {?} data
     * @param {?} _dialogRef
     * @param {?} timepickerSrv
     * @param {?} eventSrv
     * @param {?} locale
     */
    constructor(data, _dialogRef, timepickerSrv, eventSrv, locale) {
        super(timepickerSrv, eventSrv, locale, data);
        this.data = data;
        this._dialogRef = _dialogRef;
    }
    /**
     * @return {?}
     */
    close() {
        this._dialogRef.close();
    }
}
NgxMatTimepickerDialogComponent.ɵfac = function NgxMatTimepickerDialogComponent_Factory(t) { return new (t || NgxMatTimepickerDialogComponent)(ɵngcc0.ɵɵdirectiveInject(MAT_DIALOG_DATA), ɵngcc0.ɵɵdirectiveInject(ɵngcc7.MatDialogRef), ɵngcc0.ɵɵdirectiveInject(NgxMatTimepickerService), ɵngcc0.ɵɵdirectiveInject(NgxMatTimepickerEventService), ɵngcc0.ɵɵdirectiveInject(NGX_MAT_TIMEPICKER_LOCALE)); };
NgxMatTimepickerDialogComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NgxMatTimepickerDialogComponent, selectors: [["ngx-mat-timepicker-dialog"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 21, vars: 28, consts: [["cancelBtnDefault", ""], ["confirmBtnDefault", ""], ["mat-dialog-content", ""], [3, "appendToInput", "inputElement", "ngxMatTimepickerTheme"], [1, "timepicker", 3, "ngClass"], [1, "timepicker-header", 3, "color"], [3, "color", "format", "hour", "minute", "period", "activeTimeUnit", "minTime", "maxTime", "isEditable", "editableHintTmpl", "minutesGap", "hoursOnly", "periodChanged", "timeUnitChanged", "hourChanged", "minuteChanged"], [1, "timepicker__main-content"], [1, "timepicker__body", 3, "ngSwitch"], [4, "ngSwitchCase"], [3, "color", "selectedMinute", "selectedHour", "minTime", "maxTime", "format", "period", "minutesGap", "minuteChange", 4, "ngSwitchCase"], ["mat-dialog-actions", ""], [3, "click"], [4, "ngTemplateOutlet"], ["mat-button", "", 3, "color"], [3, "color", "selectedHour", "minTime", "maxTime", "format", "hourChange", "hourSelected", 4, "ngIf", "ngIfElse"], ["ampmHours", ""], [3, "color", "selectedHour", "minTime", "maxTime", "format", "hourChange", "hourSelected"], [3, "color", "selectedHour", "period", "minTime", "maxTime", "hourChange", "hourSelected"], [3, "color", "selectedMinute", "selectedHour", "minTime", "maxTime", "format", "period", "minutesGap", "minuteChange"]], template: function NgxMatTimepickerDialogComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NgxMatTimepickerDialogComponent_ng_template_0_Template, 2, 1, "ng-template", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(2, NgxMatTimepickerDialogComponent_ng_template_2_Template, 2, 1, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵelementStart(4, "div", 2);
        ɵngcc0.ɵɵelementStart(5, "ngx-mat-timepicker-content", 3);
        ɵngcc0.ɵɵelementStart(6, "div", 4);
        ɵngcc0.ɵɵelementStart(7, "mat-toolbar", 5);
        ɵngcc0.ɵɵelementStart(8, "ngx-mat-timepicker-dial", 6);
        ɵngcc0.ɵɵlistener("periodChanged", function NgxMatTimepickerDialogComponent_Template_ngx_mat_timepicker_dial_periodChanged_8_listener($event) { return ctx.changePeriod($event); })("timeUnitChanged", function NgxMatTimepickerDialogComponent_Template_ngx_mat_timepicker_dial_timeUnitChanged_8_listener($event) { return ctx.changeTimeUnit($event); })("hourChanged", function NgxMatTimepickerDialogComponent_Template_ngx_mat_timepicker_dial_hourChanged_8_listener($event) { return ctx.onHourChange($event); })("minuteChanged", function NgxMatTimepickerDialogComponent_Template_ngx_mat_timepicker_dial_minuteChanged_8_listener($event) { return ctx.onMinuteChange($event); });
        ɵngcc0.ɵɵpipe(9, "async");
        ɵngcc0.ɵɵpipe(10, "async");
        ɵngcc0.ɵɵpipe(11, "async");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(12, "div", 7);
        ɵngcc0.ɵɵelementStart(13, "div", 8);
        ɵngcc0.ɵɵtemplate(14, NgxMatTimepickerDialogComponent_div_14_Template, 4, 2, "div", 9);
        ɵngcc0.ɵɵtemplate(15, NgxMatTimepickerDialogComponent_ngx_mat_timepicker_minutes_face_15_Template, 4, 14, "ngx-mat-timepicker-minutes-face", 10);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(16, "div", 11);
        ɵngcc0.ɵɵelementStart(17, "div", 12);
        ɵngcc0.ɵɵlistener("click", function NgxMatTimepickerDialogComponent_Template_div_click_17_listener() { return ctx.close(); });
        ɵngcc0.ɵɵtemplate(18, NgxMatTimepickerDialogComponent_ng_container_18_Template, 1, 0, "ng-container", 13);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(19, "div", 12);
        ɵngcc0.ɵɵlistener("click", function NgxMatTimepickerDialogComponent_Template_div_click_19_listener() { return ctx.setTime(); });
        ɵngcc0.ɵɵtemplate(20, NgxMatTimepickerDialogComponent_ng_container_20_Template, 1, 0, "ng-container", 13);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        const _r0 = ɵngcc0.ɵɵreference(1);
        const _r2 = ɵngcc0.ɵɵreference(3);
        let tmp_7_0;
        let tmp_8_0;
        ɵngcc0.ɵɵadvance(5);
        ɵngcc0.ɵɵproperty("appendToInput", ctx.data.appendToInput)("inputElement", ctx.data.inputElement)("ngxMatTimepickerTheme", ctx.data.theme);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngClass", ctx.data.timepickerClass);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("color", ctx.color);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("color", ctx.color)("format", ctx.data.format)("hour", (tmp_7_0 = ɵngcc0.ɵɵpipeBind1(9, 22, ctx.selectedHour)) == null ? null : tmp_7_0.time)("minute", (tmp_8_0 = ɵngcc0.ɵɵpipeBind1(10, 24, ctx.selectedMinute)) == null ? null : tmp_8_0.time)("period", ɵngcc0.ɵɵpipeBind1(11, 26, ctx.selectedPeriod))("activeTimeUnit", ctx.activeTimeUnit)("minTime", ctx.data.minTime)("maxTime", ctx.data.maxTime)("isEditable", ctx.data.enableKeyboardInput)("editableHintTmpl", ctx.data.editableHintTmpl)("minutesGap", ctx.data.minutesGap)("hoursOnly", ctx.data.hoursOnly);
        ɵngcc0.ɵɵadvance(5);
        ɵngcc0.ɵɵproperty("ngSwitch", ctx.activeTimeUnit);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", ctx.timeUnit.HOUR);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", ctx.timeUnit.MINUTE);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.data.cancelBtnTmpl ? ctx.data.cancelBtnTmpl : _r0);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.data.confirmBtnTmpl ? ctx.data.confirmBtnTmpl : _r2);
    } }, directives: function () { return [ɵngcc7.MatDialogContent, NgxMatTimepickerContentComponent, NgxMatTimepickerThemeDirective, ɵngcc1.NgClass, ɵngcc8.MatToolbar, NgxMatTimepickerDialComponent, ɵngcc1.NgSwitch, ɵngcc1.NgSwitchCase, ɵngcc7.MatDialogActions, ɵngcc1.NgTemplateOutlet, ɵngcc9.MatButton, ɵngcc1.NgIf, NgxMatTimepicker24HoursFaceComponent, NgxMatTimepicker12HoursFaceComponent, NgxMatTimepickerMinutesFaceComponent]; }, pipes: function () { return [ɵngcc1.AsyncPipe]; }, styles: ["div.ngx-mat-timepicker-dialog>mat-dialog-container.mat-dialog-container{padding-top:0}div.ngx-mat-timepicker-dialog>mat-dialog-container.mat-dialog-container .mat-dialog-content{padding:0;max-height:85vh}div.ngx-mat-timepicker-dialog>mat-dialog-container.mat-dialog-container .mat-dialog-content mat-toolbar.timepicker-header{display:flex;justify-content:center;align-items:center}div.ngx-mat-timepicker-dialog>mat-dialog-container.mat-dialog-container .mat-dialog-content .clock-face{margin:16px}div.ngx-mat-timepicker-dialog>mat-dialog-container.mat-dialog-container div[mat-dialog-actions]{justify-content:flex-end;display:flex}"], encapsulation: 2 });
/** @nocollapse */
NgxMatTimepickerDialogComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [MAT_DIALOG_DATA,] }] },
    { type: MatDialogRef },
    { type: NgxMatTimepickerService },
    { type: NgxMatTimepickerEventService },
    { type: String, decorators: [{ type: Inject, args: [NGX_MAT_TIMEPICKER_LOCALE,] }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxMatTimepickerDialogComponent, [{
        type: Component,
        args: [{
                selector: "ngx-mat-timepicker-dialog",
                template: "<ng-template #cancelBtnDefault>\n    <button mat-button\n            [color]=\"color\">CANCEL\n    </button>\n</ng-template>\n<ng-template #confirmBtnDefault>\n    <button mat-button\n            [color]=\"color\">OK\n    </button>\n</ng-template>\n<div mat-dialog-content>\n    <ngx-mat-timepicker-content [appendToInput]=\"data.appendToInput\"\n                                [inputElement]=\"data.inputElement\"\n                                [ngxMatTimepickerTheme]=\"data.theme\">\n        <div class=\"timepicker\"\n             [ngClass]=\"data.timepickerClass\">\n            <mat-toolbar [color]=\"color\"\n                         class=\"timepicker-header\">\n                <ngx-mat-timepicker-dial [color]=\"color\"\n                                         [format]=\"data.format\"\n                                         [hour]=\"(selectedHour | async)?.time\"\n                                         [minute]=\"(selectedMinute | async)?.time\"\n                                         [period]=\"selectedPeriod | async\"\n                                         [activeTimeUnit]=\"activeTimeUnit\"\n                                         [minTime]=\"data.minTime\"\n                                         [maxTime]=\"data.maxTime\"\n                                         [isEditable]=\"data.enableKeyboardInput\"\n                                         [editableHintTmpl]=\"data.editableHintTmpl\"\n                                         [minutesGap]=\"data.minutesGap\"\n                                         [hoursOnly]=\"data.hoursOnly\"\n                                         (periodChanged)=\"changePeriod($event)\"\n                                         (timeUnitChanged)=\"changeTimeUnit($event)\"\n                                         (hourChanged)=\"onHourChange($event)\"\n                                         (minuteChanged)=\"onMinuteChange($event)\"\n                ></ngx-mat-timepicker-dial>\n            </mat-toolbar>\n            <div class=\"timepicker__main-content\">\n                <div class=\"timepicker__body\"\n                     [ngSwitch]=\"activeTimeUnit\">\n                    <div *ngSwitchCase=\"timeUnit.HOUR\">\n                        <ngx-mat-timepicker-24-hours-face *ngIf=\"data.format === 24;else ampmHours\"\n                                                          [color]=\"color\"\n                                                          (hourChange)=\"onHourChange($event)\"\n                                                          [selectedHour]=\"selectedHour | async\"\n                                                          [minTime]=\"data.minTime\"\n                                                          [maxTime]=\"data.maxTime\"\n                                                          [format]=\"data.format\"\n                                                          (hourSelected)=\"onHourSelected($event)\"></ngx-mat-timepicker-24-hours-face>\n                        <ng-template #ampmHours>\n                            <ngx-mat-timepicker-12-hours-face\n                                    [color]=\"color\"\n                                    (hourChange)=\"onHourChange($event)\"\n                                    [selectedHour]=\"selectedHour | async\"\n                                    [period]=\"selectedPeriod | async\"\n                                    [minTime]=\"data.minTime\"\n                                    [maxTime]=\"data.maxTime\"\n                                    (hourSelected)=\"onHourSelected($event)\"></ngx-mat-timepicker-12-hours-face>\n                        </ng-template>\n                    </div>\n                    <ngx-mat-timepicker-minutes-face *ngSwitchCase=\"timeUnit.MINUTE\"\n                                                     [color]=\"color\"\n                                                     [selectedMinute]=\"selectedMinute | async\"\n                                                     [selectedHour]=\"(selectedHour | async)?.time\"\n                                                     [minTime]=\"data.minTime\"\n                                                     [maxTime]=\"data.maxTime\"\n                                                     [format]=\"data.format\"\n                                                     [period]=\"selectedPeriod | async\"\n                                                     [minutesGap]=\"data.minutesGap\"\n                                                     (minuteChange)=\"onMinuteChange($event)\"></ngx-mat-timepicker-minutes-face>\n                </div>\n            </div>\n        </div>\n    </ngx-mat-timepicker-content>\n</div>\n<div mat-dialog-actions>\n    <div (click)=\"close()\">\n        <ng-container\n                *ngTemplateOutlet=\"data.cancelBtnTmpl ? data.cancelBtnTmpl : cancelBtnDefault\"></ng-container>\n    </div>\n    <div (click)=\"setTime()\">\n        <ng-container\n                *ngTemplateOutlet=\"data.confirmBtnTmpl ? data.confirmBtnTmpl : confirmBtnDefault\"></ng-container>\n    </div>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                styles: ["div.ngx-mat-timepicker-dialog>mat-dialog-container.mat-dialog-container{padding-top:0}div.ngx-mat-timepicker-dialog>mat-dialog-container.mat-dialog-container .mat-dialog-content{padding:0;max-height:85vh}div.ngx-mat-timepicker-dialog>mat-dialog-container.mat-dialog-container .mat-dialog-content mat-toolbar.timepicker-header{display:flex;justify-content:center;align-items:center}div.ngx-mat-timepicker-dialog>mat-dialog-container.mat-dialog-container .mat-dialog-content .clock-face{margin:16px}div.ngx-mat-timepicker-dialog>mat-dialog-container.mat-dialog-container div[mat-dialog-actions]{justify-content:flex-end;display:flex}"]
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [MAT_DIALOG_DATA]
            }] }, { type: ɵngcc7.MatDialogRef }, { type: NgxMatTimepickerService }, { type: NgxMatTimepickerEventService }, { type: String, decorators: [{
                type: Inject,
                args: [NGX_MAT_TIMEPICKER_LOCALE]
            }] }]; }, null); })();

/**
 * @fileoverview added by tsickle
 * Generated from: lib/components/ngx-mat-timepicker/ngx-mat-timepicker.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let config;
class NgxMatTimepickerComponent {
    /**
     * @param {?} _vcr
     * @param {?} _eventService
     * @param {?} _dialog
     * @param {?} _overlay
     * @param {?} _domService
     */
    constructor(_vcr, _eventService, _dialog, _overlay, _domService) {
        this._vcr = _vcr;
        this._eventService = _eventService;
        this._dialog = _dialog;
        this._overlay = _overlay;
        this._domService = _domService;
        this.closed = new EventEmitter();
        this.hourSelected = new EventEmitter();
        this.hoursOnly = false;
        this.id = `ngx_mat_timepicker_${++NgxMatTimepickerComponent.nextId}`;
        this.isEsc = !0;
        this.opened = new EventEmitter();
        this.overlayPositions = [
            {
                originX: "center",
                originY: "bottom",
                overlayX: "center",
                overlayY: "top",
                offsetY: 0
            },
            {
                originX: "center",
                originY: "top",
                overlayX: "center",
                overlayY: "bottom",
                offsetY: 0
            }
        ];
        this.showPicker = !1;
        this.timeChanged = new EventEmitter();
        this.timeSet = new EventEmitter();
        this.timeUpdated = new Subject(); // used in the dialog, check if a better approach can be used
        // used in the dialog, check if a better approach can be used
        this._color = "primary";
    }
    /**
     * @param {?} newValue
     * @return {?}
     */
    set color(newValue) {
        this._color = newValue;
    }
    /**
     * @return {?}
     */
    get color() {
        return this._color;
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._timepickerInput && this._timepickerInput.disabled;
    }
    /**
     * @return {?}
     */
    get format() {
        return this._timepickerInput ? this._timepickerInput.format : this._format;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set format(value) {
        this._format = value === 24 ? 24 : 12;
    }
    /**
     * @return {?}
     */
    get inputElement() {
        return this._timepickerInput && this._timepickerInput.element;
    }
    /**
     * @return {?}
     */
    get maxTime() {
        return this._timepickerInput ? ((/** @type {?} */ (this._timepickerInput.max))) : this.max;
    }
    /**
     * @return {?}
     */
    get minTime() {
        return this._timepickerInput ? ((/** @type {?} */ (this._timepickerInput.min))) : this.min;
    }
    /**
     * @return {?}
     */
    get minutesGap() {
        return this._minutesGap;
    }
    /**
     * @param {?} gap
     * @return {?}
     */
    set minutesGap(gap) {
        if (gap == null) {
            return;
        }
        gap = Math.floor(gap);
        this._minutesGap = gap <= 59 ? gap : 1;
    }
    /**
     * @return {?}
     */
    get overlayOrigin() {
        return this._timepickerInput ? this._timepickerInput.cdkOverlayOrigin : void 0;
    }
    /**
     * @return {?}
     */
    get time() {
        return this._timepickerInput && this._timepickerInput.value;
    }
    /**
     * @param {?} newValue
     * @return {?}
     */
    set ngxMatTimepickerTheme(newValue) {
        this._ngxMatTimepickerTheme = newValue;
    }
    /**
     * @return {?}
     */
    close() {
        if (this.appendToInput) {
            this._overlayRef && this._overlayRef.dispose();
        }
        else {
            this._dialogRef && this._dialogRef.close();
        }
        this.showPicker = !1;
        this.closed.emit();
    }
    /**
     * @return {?}
     */
    open() {
        config = {
            timepickerBaseRef: this,
            time: this.time,
            defaultTime: this.defaultTime,
            maxTime: this.maxTime,
            minTime: this.minTime,
            format: this.format,
            minutesGap: this.minutesGap,
            disableAnimation: this.disableAnimation,
            cancelBtnTmpl: this.cancelBtnTmpl,
            confirmBtnTmpl: this.confirmBtnTmpl,
            editableHintTmpl: this.editableHintTmpl,
            disabled: this.disabled,
            enableKeyboardInput: this.enableKeyboardInput,
            preventOverlayClick: this.preventOverlayClick,
            appendToInput: this.appendToInput,
            hoursOnly: this.hoursOnly,
            theme: this.theme || this._ngxMatTimepickerTheme,
            timepickerClass: this.timepickerClass,
            inputElement: this.inputElement,
            color: this.color
        };
        if (this.appendToInput) {
            this.showPicker = !0;
        }
        else {
            this._dialogRef = this._dialog.open(NgxMatTimepickerDialogComponent, {
                panelClass: "ngx-mat-timepicker-dialog",
                data: Object.assign({}, config)
            });
            this._dialogRef
                .afterClosed()
                .subscribe((/**
             * @return {?}
             */
            () => {
                this.closed.emit();
            }));
        }
        this.opened.emit();
    }
    /**
     *
     * Register an input with this timepicker.
     * input - The timepicker input to register with this timepicker
     * @param {?} input
     * @return {?}
     */
    registerInput(input) {
        if (this._timepickerInput) {
            throw Error("A Timepicker can only be associated with a single input.");
        }
        this._timepickerInput = input;
    }
    /**
     * @return {?}
     */
    unregisterInput() {
        this._timepickerInput = void 0;
    }
    /**
     * @param {?} time
     * @return {?}
     */
    updateTime(time) {
        this.timeUpdated.next(time);
    }
}
NgxMatTimepickerComponent.ɵfac = function NgxMatTimepickerComponent_Factory(t) { return new (t || NgxMatTimepickerComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(NgxMatTimepickerEventService), ɵngcc0.ɵɵdirectiveInject(ɵngcc7.MatDialog), ɵngcc0.ɵɵdirectiveInject(ɵngcc10.Overlay), ɵngcc0.ɵɵdirectiveInject(ɵngcc11.SmpDomService)); };
NgxMatTimepickerComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NgxMatTimepickerComponent, selectors: [["ngx-mat-timepicker"]], hostVars: 1, hostBindings: function NgxMatTimepickerComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵhostProperty("id", ctx.id);
    } }, inputs: { hoursOnly: "hoursOnly", isEsc: "isEsc", color: "color", format: "format", minutesGap: "minutesGap", appendToInput: "appendToInput", cancelBtnTmpl: "cancelBtnTmpl", confirmBtnTmpl: "confirmBtnTmpl", defaultTime: "defaultTime", disableAnimation: "disableAnimation", editableHintTmpl: "editableHintTmpl", enableKeyboardInput: "enableKeyboardInput", max: "max", min: "min", preventOverlayClick: "preventOverlayClick", theme: "theme", timepickerClass: "timepickerClass" }, outputs: { closed: "closed", hourSelected: "hourSelected", opened: "opened", timeChanged: "timeChanged", timeSet: "timeSet" }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: NGX_MAT_TIMEPICKER_CONFIG,
                useFactory() {
                    return config;
                }
            }
        ])], decls: 1, vars: 4, consts: [["cdkConnectedOverlay", "", "cdkConnectedOverlayBackdropClass", "cdk-overlay-transparent-backdrop", 3, "cdkConnectedOverlayPositions", "cdkConnectedOverlayHasBackdrop", "cdkConnectedOverlayOrigin", "cdkConnectedOverlayOpen", "backdropClick"]], template: function NgxMatTimepickerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NgxMatTimepickerComponent_ng_template_0_Template, 1, 0, "ng-template", 0);
        ɵngcc0.ɵɵlistener("backdropClick", function NgxMatTimepickerComponent_Template_ng_template_backdropClick_0_listener() { return ctx.close(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("cdkConnectedOverlayPositions", ctx.overlayPositions)("cdkConnectedOverlayHasBackdrop", !0)("cdkConnectedOverlayOrigin", ctx.overlayOrigin)("cdkConnectedOverlayOpen", ctx.showPicker);
    } }, directives: function () { return [ɵngcc10.CdkConnectedOverlay, NgxMatTimepickerStandaloneComponent]; }, encapsulation: 2 });
NgxMatTimepickerComponent.nextId = 0;
/** @nocollapse */
NgxMatTimepickerComponent.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: NgxMatTimepickerEventService },
    { type: MatDialog },
    { type: Overlay },
    { type: SmpDomService }
];
NgxMatTimepickerComponent.propDecorators = {
    color: [{ type: Input }],
    format: [{ type: Input }],
    minutesGap: [{ type: Input }],
    appendToInput: [{ type: Input }],
    cancelBtnTmpl: [{ type: Input }],
    closed: [{ type: Output }],
    confirmBtnTmpl: [{ type: Input }],
    defaultTime: [{ type: Input }],
    disableAnimation: [{ type: Input }],
    editableHintTmpl: [{ type: Input }],
    enableKeyboardInput: [{ type: Input }],
    hourSelected: [{ type: Output }],
    hoursOnly: [{ type: Input }],
    id: [{ type: HostBinding, args: ["id",] }],
    isEsc: [{ type: Input }],
    max: [{ type: Input }],
    min: [{ type: Input }],
    opened: [{ type: Output }],
    preventOverlayClick: [{ type: Input }],
    theme: [{ type: Input }],
    timeChanged: [{ type: Output }],
    timepickerClass: [{ type: Input }],
    timeSet: [{ type: Output }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxMatTimepickerComponent, [{
        type: Component,
        args: [{
                selector: "ngx-mat-timepicker",
                template: `
		<ng-template
				cdkConnectedOverlay
				[cdkConnectedOverlayPositions]="overlayPositions"
				[cdkConnectedOverlayHasBackdrop]="!0"
				cdkConnectedOverlayBackdropClass="cdk-overlay-transparent-backdrop"
				(backdropClick)="close()"
				[cdkConnectedOverlayOrigin]="overlayOrigin"
				[cdkConnectedOverlayOpen]="showPicker">
			<ngx-mat-timepicker-standalone></ngx-mat-timepicker-standalone>
		</ng-template>`,
                providers: [
                    {
                        provide: NGX_MAT_TIMEPICKER_CONFIG,
                        useFactory() {
                            return config;
                        }
                    }
                ]
            }]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }, { type: NgxMatTimepickerEventService }, { type: ɵngcc7.MatDialog }, { type: ɵngcc10.Overlay }, { type: ɵngcc11.SmpDomService }]; }, { closed: [{
            type: Output
        }], hourSelected: [{
            type: Output
        }], hoursOnly: [{
            type: Input
        }], id: [{
            type: HostBinding,
            args: ["id"]
        }], isEsc: [{
            type: Input
        }], opened: [{
            type: Output
        }], timeChanged: [{
            type: Output
        }], timeSet: [{
            type: Output
        }], color: [{
            type: Input
        }], format: [{
            type: Input
        }], minutesGap: [{
            type: Input
        }], appendToInput: [{
            type: Input
        }], cancelBtnTmpl: [{
            type: Input
        }], confirmBtnTmpl: [{
            type: Input
        }], defaultTime: [{
            type: Input
        }], disableAnimation: [{
            type: Input
        }], editableHintTmpl: [{
            type: Input
        }], enableKeyboardInput: [{
            type: Input
        }], max: [{
            type: Input
        }], min: [{
            type: Input
        }], preventOverlayClick: [{
            type: Input
        }], theme: [{
            type: Input
        }], timepickerClass: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * Generated from: lib/components/ngx-mat-timepicker-toggle/ngx-mat-timepicker-toggle.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxMatTimepickerToggleComponent {
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled === undefined ? this.timepicker.disabled : this._disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this._disabled = value;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    open(event) {
        if (this.timepicker) {
            this.timepicker.open();
            event.stopPropagation();
        }
    }
}
NgxMatTimepickerToggleComponent.ɵfac = function NgxMatTimepickerToggleComponent_Factory(t) { return new (t || NgxMatTimepickerToggleComponent)(); };
NgxMatTimepickerToggleComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NgxMatTimepickerToggleComponent, selectors: [["ngx-mat-timepicker-toggle"]], contentQueries: function NgxMatTimepickerToggleComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgxMatTimepickerToggleIconDirective, 7);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.customIcon = _t.first);
    } }, inputs: { disabled: "disabled", timepicker: ["for", "timepicker"] }, ngContentSelectors: _c2, decls: 3, vars: 2, consts: [["color", "", "mat-mini-fab", "", "type", "button", 1, "ngx-mat-timepicker-toggle", "mat-elevation-z0", 3, "disabled", "click"], ["xmlns", "http://www.w3.org/2000/svg", "viewBox", "0 0 24 24", "width", "24px", "height", "24px", 4, "ngIf"], ["xmlns", "http://www.w3.org/2000/svg", "viewBox", "0 0 24 24", "width", "24px", "height", "24px"], ["d", "M 12 2 C 6.4889971 2 2 6.4889971 2 12 C 2 17.511003                   6.4889971 22 12 22 C 17.511003 22 22 17.511003 22 12 C 22 6.4889971 17.511003 2 12 2 z M 12 4 C 16.430123 4 20 7.5698774 20 12 C 20 16.430123 16.430123 20 12 20 C 7.5698774 20 4 16.430123 4 12 C 4 7.5698774 7.5698774 4 12 4 z M 11 6 L 11 12.414062 L 15.292969 16.707031 L 16.707031 15.292969 L 13 11.585938 L 13 6 L 11 6 z"]], template: function NgxMatTimepickerToggleComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c1);
        ɵngcc0.ɵɵelementStart(0, "button", 0);
        ɵngcc0.ɵɵlistener("click", function NgxMatTimepickerToggleComponent_Template_button_click_0_listener($event) { return ctx.open($event); });
        ɵngcc0.ɵɵtemplate(1, NgxMatTimepickerToggleComponent__svg_svg_1_Template, 2, 0, "svg", 1);
        ɵngcc0.ɵɵprojection(2);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("disabled", ctx.disabled);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.customIcon);
    } }, directives: [ɵngcc9.MatButton, ɵngcc1.NgIf], styles: ["button.ngx-mat-timepicker-toggle[_ngcontent-%COMP%]{background-color:transparent;text-align:center;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;box-shadow:none}"] });
NgxMatTimepickerToggleComponent.propDecorators = {
    disabled: [{ type: Input }],
    customIcon: [{ type: ContentChild, args: [NgxMatTimepickerToggleIconDirective, { static: true },] }],
    timepicker: [{ type: Input, args: ["for",] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxMatTimepickerToggleComponent, [{
        type: Component,
        args: [{
                selector: "ngx-mat-timepicker-toggle",
                template: "<button class=\"ngx-mat-timepicker-toggle mat-elevation-z0\"\n        color=\"\"\n        mat-mini-fab\n        (click)=\"open($event)\"\n        [disabled]=\"disabled\"\n        type=\"button\">\n    <svg xmlns=\"http://www.w3.org/2000/svg\"\n         viewBox=\"0 0 24 24\"\n         width=\"24px\"\n         height=\"24px\"\n         *ngIf=\"!customIcon\">\n        <path d=\"M 12 2 C 6.4889971 2 2 6.4889971 2 12 C 2 17.511003                   6.4889971 22 12 22 C 17.511003 22 22 17.511003 22 12 C 22 6.4889971 17.511003 2 12 2 z M 12 4 C 16.430123 4 20 7.5698774 20 12 C 20 16.430123 16.430123 20 12 20 C 7.5698774 20 4 16.430123 4 12 C 4 7.5698774 7.5698774 4 12 4 z M 11 6 L 11 12.414062 L 15.292969 16.707031 L 16.707031 15.292969 L 13 11.585938 L 13 6 L 11 6 z\" />\n    </svg>\n\n    <ng-content select=\"[ngxMatTimepickerToggleIcon]\"></ng-content>\n</button>\n",
                styles: ["button.ngx-mat-timepicker-toggle{background-color:transparent;text-align:center;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;box-shadow:none}"]
            }]
    }], null, { disabled: [{
            type: Input
        }], customIcon: [{
            type: ContentChild,
            args: [NgxMatTimepickerToggleIconDirective, { static: true }]
        }], timepicker: [{
            type: Input,
            args: ["for"]
        }] }); })();

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/ngx-mat-timepicker.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxMatTimepickerDirective {
    /**
     * @param {?} _elementRef
     * @param {?} _matFormField
     * @param {?} _locale
     */
    constructor(_elementRef, _matFormField, _locale) {
        this._elementRef = _elementRef;
        this._matFormField = _matFormField;
        this._locale = _locale;
        // TODO: IMPROVE DETECTING (INJECT) MAT-FORM-FIELD IF PRESENT
        this.cdkOverlayOrigin = new CdkOverlayOrigin(this._matFormField ? this._matFormField.getConnectedOverlayOrigin() : this._elementRef);
        this._format = 12;
        this._subsCtrl$ = new Subject();
        this._value = "";
        this.onTouched = (/**
         * @return {?}
         */
        () => {
        });
        this._onChange = (/**
         * @return {?}
         */
        () => {
        });
    }
    /**
     * @return {?}
     */
    get element() {
        return this._elementRef && this._elementRef.nativeElement;
    }
    /**
     * @return {?}
     */
    get format() {
        return this._format;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set format(value) {
        this._format = +value === 24 ? 24 : 12;
        /** @type {?} */
        const isDynamicallyChanged = value && (this._previousFormat && this._previousFormat !== this._format);
        if (isDynamicallyChanged) {
            this.value = this._value;
            this._timepicker.updateTime(this._value);
        }
        this._previousFormat = this._format;
    }
    /**
     * @return {?}
     */
    get max() {
        return this._max;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set max(value) {
        if (typeof value === "string") {
            this._max = NgxMatTimepickerAdapter.parseTime(value, { locale: this._locale, format: this.format });
            return;
        }
        this._max = value;
    }
    /**
     * @return {?}
     */
    get min() {
        return this._min;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set min(value) {
        if (typeof value === "string") {
            this._min = NgxMatTimepickerAdapter.parseTime(value, { locale: this._locale, format: this.format });
            return;
        }
        this._min = value;
    }
    /**
     * @param {?} picker
     * @return {?}
     */
    set timepicker(picker) {
        this._registerTimepicker(picker);
    }
    /**
     * @return {?}
     */
    get value() {
        if (!this._value) {
            return "";
        }
        return NgxMatTimepickerAdapter.toLocaleTimeString(this._value, { format: this.format, locale: this._locale });
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set value(value) {
        if (!value) {
            this._value = "";
            this._updateInputValue();
            return;
        }
        /** @type {?} */
        const time = NgxMatTimepickerAdapter.formatTime(value, { locale: this._locale, format: this.format });
        /** @type {?} */
        const isAvailable = NgxMatTimepickerAdapter.isTimeAvailable(time, (/** @type {?} */ (this._min)), (/** @type {?} */ (this._max)), "minutes", this._timepicker.minutesGap, this._format);
        if (isAvailable) {
            this._value = time;
            this._updateInputValue();
            return;
        }
        console.warn("Selected time doesn't match min or max value");
    }
    /**
     * @private
     * @param {?} time
     * @return {?}
     */
    set _defaultTime(time) {
        this._timepicker.defaultTime = NgxMatTimepickerAdapter.formatTime(time, {
            locale: this._locale,
            format: this.format
        });
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.value && changes.value.currentValue) {
            this._defaultTime = changes.value.currentValue;
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._unregisterTimepicker();
        this._subsCtrl$.next();
        this._subsCtrl$.complete();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onClick(event) {
        if (!this.disableClick) {
            this._timepicker.open();
            event.stopPropagation();
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this._onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    updateValue(value) {
        this.value = value;
        this._onChange(value);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.value = value;
        if (value) {
            this._defaultTime = value;
        }
    }
    /**
     * @private
     * @param {?} picker
     * @return {?}
     */
    _registerTimepicker(picker) {
        if (picker) {
            this._timepicker = picker;
            this._timepicker.registerInput(this);
            this._timepicker.timeSet
                .pipe(takeUntil(this._subsCtrl$))
                .subscribe((/**
             * @param {?} time
             * @return {?}
             */
            (time) => {
                this.value = time;
                this._onChange(this.value);
                this.onTouched();
                this._defaultTime = this._value;
            }));
        }
        else {
            throw new Error("NgxMatTimepickerComponent is not defined." +
                " Please make sure you passed the timepicker to ngxMatTimepicker directive");
        }
    }
    /**
     * @private
     * @return {?}
     */
    _unregisterTimepicker() {
        if (this._timepicker) {
            this._timepicker.unregisterInput();
        }
    }
    /**
     * @private
     * @return {?}
     */
    _updateInputValue() {
        this._elementRef.nativeElement.value = this.value;
    }
}
NgxMatTimepickerDirective.ɵfac = function NgxMatTimepickerDirective_Factory(t) { return new (t || NgxMatTimepickerDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MatFormField, 8), ɵngcc0.ɵɵdirectiveInject(NGX_MAT_TIMEPICKER_LOCALE)); };
NgxMatTimepickerDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NgxMatTimepickerDirective, selectors: [["", "ngxMatTimepicker", ""]], hostVars: 2, hostBindings: function NgxMatTimepickerDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("blur", function NgxMatTimepickerDirective_blur_HostBindingHandler() { return ctx.onTouched(); })("click", function NgxMatTimepickerDirective_click_HostBindingHandler($event) { return ctx.onClick($event); })("change", function NgxMatTimepickerDirective_change_HostBindingHandler($event) { return ctx.updateValue($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵhostProperty("disabled", ctx.disabled);
        ɵngcc0.ɵɵattribute("cdkOverlayOrigin", ctx.cdkOverlayOrigin);
    } }, inputs: { format: "format", value: "value", max: "max", min: "min", timepicker: ["ngxMatTimepicker", "timepicker"], disabled: "disabled", disableClick: "disableClick" }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: NgxMatTimepickerDirective,
                multi: true
            }
        ]), ɵngcc0.ɵɵNgOnChangesFeature] });
/** @nocollapse */
NgxMatTimepickerDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: MatFormField, decorators: [{ type: Optional }, { type: Inject, args: [MatFormField,] }] },
    { type: String, decorators: [{ type: Inject, args: [NGX_MAT_TIMEPICKER_LOCALE,] }] }
];
NgxMatTimepickerDirective.propDecorators = {
    format: [{ type: Input }],
    max: [{ type: Input }],
    min: [{ type: Input }],
    timepicker: [{ type: Input, args: ["ngxMatTimepicker",] }],
    value: [{ type: Input }],
    cdkOverlayOrigin: [{ type: HostBinding, args: ["attr.cdkOverlayOrigin",] }],
    disableClick: [{ type: Input }],
    disabled: [{ type: Input }],
    onClick: [{ type: HostListener, args: ["click", ["$event"],] }],
    updateValue: [{ type: HostListener, args: ["change", ["$event"],] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxMatTimepickerDirective, [{
        type: Directive,
        args: [{
                selector: "[ngxMatTimepicker]",
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: NgxMatTimepickerDirective,
                        multi: true
                    }
                ],
                // tslint:disable-next-line:no-host-metadata-property
                host: {
                    "[disabled]": "disabled",
                    "(blur)": "onTouched()"
                }
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc2.MatFormField, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [MatFormField]
            }] }, { type: String, decorators: [{
                type: Inject,
                args: [NGX_MAT_TIMEPICKER_LOCALE]
            }] }]; }, { cdkOverlayOrigin: [{
            type: HostBinding,
            args: ["attr.cdkOverlayOrigin"]
        }], format: [{
            type: Input
        }], value: [{
            type: Input
        }], max: [{
            type: Input
        }], min: [{
            type: Input
        }], timepicker: [{
            type: Input,
            args: ["ngxMatTimepicker"]
        }], 
    /**
     * @param {?} event
     * @return {?}
     */
    onClick: [{
            type: HostListener,
            args: ["click", ["$event"]]
        }], disabled: [{
            type: Input
        }], 
    /**
     * @param {?} value
     * @return {?}
     */
    updateValue: [{
            type: HostListener,
            args: ["change", ["$event"]]
        }], disableClick: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/ngx-mat-timepicker-theme.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxMatTimepickerThemeDirective {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this._element = elementRef.nativeElement;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this.theme) {
            this.setTheme(this.theme);
        }
    }
    /**
     * @private
     * @param {?} theme
     * @return {?}
     */
    setTheme(theme) {
        for (const val in theme) {
            if (theme.hasOwnProperty(val)) {
                if (typeof theme[val] === "string") {
                    for (const prop in theme) {
                        if (theme.hasOwnProperty(prop)) {
                            this._element.style.setProperty(`--${camelCaseToDash(prop)}`, theme[prop]);
                        }
                    }
                    return;
                }
                this.setTheme(theme[val]);
            }
        }
    }
}
NgxMatTimepickerThemeDirective.ɵfac = function NgxMatTimepickerThemeDirective_Factory(t) { return new (t || NgxMatTimepickerThemeDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
NgxMatTimepickerThemeDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NgxMatTimepickerThemeDirective, selectors: [["", "ngxMatTimepickerTheme", ""]], inputs: { theme: ["ngxMatTimepickerTheme", "theme"] } });
/** @nocollapse */
NgxMatTimepickerThemeDirective.ctorParameters = () => [
    { type: ElementRef }
];
NgxMatTimepickerThemeDirective.propDecorators = {
    theme: [{ type: Input, args: ["ngxMatTimepickerTheme",] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxMatTimepickerThemeDirective, [{
        type: Directive,
        args: [{ selector: "[ngxMatTimepickerTheme]" }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { theme: [{
            type: Input,
            args: ["ngxMatTimepickerTheme"]
        }] }); })();
/**
 * @param {?} myStr
 * @return {?}
 */
function camelCaseToDash(myStr) {
    return myStr.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/components/ngx-mat-timepicker-hours-face/ngx-mat-timepicker-hours-face.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxMatTimepickerHoursFaceDirective {
    constructor() {
        this.hourChange = new EventEmitter();
        this.hourSelected = new EventEmitter();
        this.hoursList = [];
        this._color = "primary";
        this._format = 24;
    }
    /**
     * @param {?} newValue
     * @return {?}
     */
    set color(newValue) {
        this._color = newValue;
    }
    /**
     * @return {?}
     */
    get color() {
        return this._color;
    }
    /**
     * @param {?} newValue
     * @return {?}
     */
    set format(newValue) {
        this._format = newValue;
        this.hoursList = NgxMatTimepickerUtils.getHours(this._format);
    }
    /**
     * @return {?}
     */
    get format() {
        return this._format;
    }
    /**
     * @param {?} time
     * @return {?}
     */
    onTimeSelected(time) {
        this.hourSelected.next(time);
    }
}
NgxMatTimepickerHoursFaceDirective.ɵfac = function NgxMatTimepickerHoursFaceDirective_Factory(t) { return new (t || NgxMatTimepickerHoursFaceDirective)(); };
NgxMatTimepickerHoursFaceDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NgxMatTimepickerHoursFaceDirective, selectors: [["", "ngxMatTimepickerHoursFace", ""]], inputs: { color: "color", format: "format", maxTime: "maxTime", minTime: "minTime", selectedHour: "selectedHour" }, outputs: { hourChange: "hourChange", hourSelected: "hourSelected" } });
/** @nocollapse */
NgxMatTimepickerHoursFaceDirective.ctorParameters = () => [];
NgxMatTimepickerHoursFaceDirective.propDecorators = {
    color: [{ type: Input }],
    format: [{ type: Input }],
    hourChange: [{ type: Output }],
    hourSelected: [{ type: Output }],
    maxTime: [{ type: Input }],
    minTime: [{ type: Input }],
    selectedHour: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxMatTimepickerHoursFaceDirective, [{
        type: Directive,
        args: [{
                selector: "[ngxMatTimepickerHoursFace]"
            }]
    }], function () { return []; }, { hourChange: [{
            type: Output
        }], hourSelected: [{
            type: Output
        }], color: [{
            type: Input
        }], format: [{
            type: Input
        }], maxTime: [{
            type: Input
        }], minTime: [{
            type: Input
        }], selectedHour: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * Generated from: lib/components/ngx-mat-timepicker-24-hours-face/ngx-mat-timepicker-24-hours-face.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxMatTimepicker24HoursFaceComponent extends NgxMatTimepickerHoursFaceDirective {
    constructor() {
        super();
        this.format = 24;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.hoursList = NgxMatTimepickerUtils.disableHours(this.hoursList, {
            min: this.minTime,
            max: this.maxTime,
            format: this.format
        });
    }
}
NgxMatTimepicker24HoursFaceComponent.ɵfac = function NgxMatTimepicker24HoursFaceComponent_Factory(t) { return new (t || NgxMatTimepicker24HoursFaceComponent)(); };
NgxMatTimepicker24HoursFaceComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NgxMatTimepicker24HoursFaceComponent, selectors: [["ngx-mat-timepicker-24-hours-face"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 1, vars: 4, consts: [[3, "color", "selectedTime", "faceTime", "format", "timeChange", "timeSelected"]], template: function NgxMatTimepicker24HoursFaceComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-mat-timepicker-face", 0);
        ɵngcc0.ɵɵlistener("timeChange", function NgxMatTimepicker24HoursFaceComponent_Template_ngx_mat_timepicker_face_timeChange_0_listener($event) { return ctx.hourChange.next($event); })("timeSelected", function NgxMatTimepicker24HoursFaceComponent_Template_ngx_mat_timepicker_face_timeSelected_0_listener($event) { return ctx.onTimeSelected($event); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("color", ctx.color)("selectedTime", ctx.selectedHour)("faceTime", ctx.hoursList)("format", ctx.format);
    } }, directives: function () { return [NgxMatTimepickerFaceComponent]; }, encapsulation: 2, changeDetection: 0 });
/** @nocollapse */
NgxMatTimepicker24HoursFaceComponent.ctorParameters = () => [];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxMatTimepicker24HoursFaceComponent, [{
        type: Component,
        args: [{
                selector: "ngx-mat-timepicker-24-hours-face",
                template: "<ngx-mat-timepicker-face [color]=\"color\"\n                     [selectedTime]=\"selectedHour\"\n                     [faceTime]=\"hoursList\"\n                     [format]=\"format\"\n                     (timeChange)=\"hourChange.next($event)\"\n                     (timeSelected)=\"onTimeSelected($event)\"></ngx-mat-timepicker-face>\n",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, null); })();

/**
 * @fileoverview added by tsickle
 * Generated from: lib/components/ngx-mat-timepicker-12-hours-face/ngx-mat-timepicker-12-hours-face.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxMatTimepicker12HoursFaceComponent extends NgxMatTimepickerHoursFaceDirective {
    constructor() {
        super();
        this.format = 12;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.period && changes.period.currentValue) {
            this.hoursList = NgxMatTimepickerUtils.disableHours(this.hoursList, {
                min: this.minTime,
                max: this.maxTime,
                format: this.format,
                period: this.period
            });
        }
    }
}
NgxMatTimepicker12HoursFaceComponent.ɵfac = function NgxMatTimepicker12HoursFaceComponent_Factory(t) { return new (t || NgxMatTimepicker12HoursFaceComponent)(); };
NgxMatTimepicker12HoursFaceComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NgxMatTimepicker12HoursFaceComponent, selectors: [["ngx-mat-timepicker-12-hours-face"]], inputs: { period: "period" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature], decls: 1, vars: 3, consts: [[3, "color", "selectedTime", "faceTime", "timeChange", "timeSelected"]], template: function NgxMatTimepicker12HoursFaceComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-mat-timepicker-face", 0);
        ɵngcc0.ɵɵlistener("timeChange", function NgxMatTimepicker12HoursFaceComponent_Template_ngx_mat_timepicker_face_timeChange_0_listener($event) { return ctx.hourChange.next($event); })("timeSelected", function NgxMatTimepicker12HoursFaceComponent_Template_ngx_mat_timepicker_face_timeSelected_0_listener($event) { return ctx.onTimeSelected($event); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("color", ctx.color)("selectedTime", ctx.selectedHour)("faceTime", ctx.hoursList);
    } }, directives: function () { return [NgxMatTimepickerFaceComponent]; }, encapsulation: 2, changeDetection: 0 });
/** @nocollapse */
NgxMatTimepicker12HoursFaceComponent.ctorParameters = () => [];
NgxMatTimepicker12HoursFaceComponent.propDecorators = {
    period: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxMatTimepicker12HoursFaceComponent, [{
        type: Component,
        args: [{
                selector: "ngx-mat-timepicker-12-hours-face",
                template: "<ngx-mat-timepicker-face [color]=\"color\"\n                     [selectedTime]=\"selectedHour\"\n                     [faceTime]=\"hoursList\"\n                     (timeChange)=\"hourChange.next($event)\"\n                     (timeSelected)=\"onTimeSelected($event)\"></ngx-mat-timepicker-face>\n",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { period: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * Generated from: lib/components/ngx-mat-timepicker-minutes-face/ngx-mat-timepicker-minutes-face.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxMatTimepickerMinutesFaceComponent {
    constructor() {
        this.minuteChange = new EventEmitter();
        this.minutesList = [];
        this.timeUnit = NgxMatTimepickerUnits;
        this._color = "primary";
    }
    /**
     * @param {?} newValue
     * @return {?}
     */
    set color(newValue) {
        this._color = newValue;
    }
    /**
     * @return {?}
     */
    get color() {
        return this._color;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.period && changes.period.currentValue) {
            /** @type {?} */
            const minutes = NgxMatTimepickerUtils.getMinutes(this.minutesGap);
            this.minutesList = NgxMatTimepickerUtils.disableMinutes(minutes, this.selectedHour, {
                min: this.minTime,
                max: this.maxTime,
                format: this.format,
                period: this.period
            });
        }
    }
}
NgxMatTimepickerMinutesFaceComponent.ɵfac = function NgxMatTimepickerMinutesFaceComponent_Factory(t) { return new (t || NgxMatTimepickerMinutesFaceComponent)(); };
NgxMatTimepickerMinutesFaceComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NgxMatTimepickerMinutesFaceComponent, selectors: [["ngx-mat-timepicker-minutes-face"]], inputs: { color: "color", format: "format", maxTime: "maxTime", minTime: "minTime", minutesGap: "minutesGap", period: "period", selectedHour: "selectedHour", selectedMinute: "selectedMinute" }, outputs: { minuteChange: "minuteChange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 1, vars: 5, consts: [[3, "color", "faceTime", "selectedTime", "minutesGap", "unit", "timeChange"]], template: function NgxMatTimepickerMinutesFaceComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-mat-timepicker-face", 0);
        ɵngcc0.ɵɵlistener("timeChange", function NgxMatTimepickerMinutesFaceComponent_Template_ngx_mat_timepicker_face_timeChange_0_listener($event) { return ctx.minuteChange.next($event); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("color", ctx.color)("faceTime", ctx.minutesList)("selectedTime", ctx.selectedMinute)("minutesGap", ctx.minutesGap)("unit", ctx.timeUnit.MINUTE);
    } }, directives: function () { return [NgxMatTimepickerFaceComponent]; }, encapsulation: 2 });
/** @nocollapse */
NgxMatTimepickerMinutesFaceComponent.ctorParameters = () => [];
NgxMatTimepickerMinutesFaceComponent.propDecorators = {
    color: [{ type: Input }],
    format: [{ type: Input }],
    maxTime: [{ type: Input }],
    minTime: [{ type: Input }],
    minuteChange: [{ type: Output }],
    minutesGap: [{ type: Input }],
    period: [{ type: Input }],
    selectedHour: [{ type: Input }],
    selectedMinute: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxMatTimepickerMinutesFaceComponent, [{
        type: Component,
        args: [{
                selector: "ngx-mat-timepicker-minutes-face",
                template: "<ngx-mat-timepicker-face [color]=\"color\"\n                     [faceTime]=\"minutesList\"\n                     [selectedTime]=\"selectedMinute\"\n                     [minutesGap]=\"minutesGap\"\n                     (timeChange)=\"minuteChange.next($event)\"\n                     [unit]=\"timeUnit.MINUTE\"></ngx-mat-timepicker-face>\n"
            }]
    }], function () { return []; }, { minuteChange: [{
            type: Output
        }], color: [{
            type: Input
        }], format: [{
            type: Input
        }], maxTime: [{
            type: Input
        }], minTime: [{
            type: Input
        }], minutesGap: [{
            type: Input
        }], period: [{
            type: Input
        }], selectedHour: [{
            type: Input
        }], selectedMinute: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * Generated from: lib/components/ngx-mat-timepicker-face/ngx-mat-timepicker-face.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} angle
 * @param {?} step
 * @return {?}
 */
function roundAngle(angle, step) {
    return Math.round(angle / step) * step;
}
/**
 * @param {?} x0
 * @param {?} y0
 * @param {?} x
 * @param {?} y
 * @param {?} currentAngle
 * @return {?}
 */
function countAngleByCords(x0, y0, x, y, currentAngle) {
    if (y > y0 && x >= x0) { // II quarter
        return 180 - currentAngle;
    }
    else if (y > y0 && x < x0) { // III quarter
        return 180 + currentAngle;
    }
    else if (y < y0 && x < x0) { // IV quarter
        return 360 - currentAngle;
    }
    else { // I quarter
        return currentAngle;
    }
}
/** @type {?} */
const CLOCK_HAND_STYLES = {
    small: {
        height: "75px",
        top: "calc(50% - 75px)"
    },
    large: {
        height: "103px",
        top: "calc(50% - 103px)"
    }
};
class NgxMatTimepickerFaceComponent {
    constructor() {
        this.color = "primary";
        this.innerClockFaceSize = 85;
        this.timeChange = new EventEmitter();
        this.timeSelected = new EventEmitter();
        this.timeUnit = NgxMatTimepickerUnits;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this._setClockHandPosition();
        this._addTouchEvents();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const faceTimeChanges = changes.faceTime;
        /** @type {?} */
        const selectedTimeChanges = changes.selectedTime;
        if ((faceTimeChanges && faceTimeChanges.currentValue)
            && (selectedTimeChanges && selectedTimeChanges.currentValue)) {
            /* Set time according to passed an input value */
            this.selectedTime = this.faceTime.find((/**
             * @param {?} time
             * @return {?}
             */
            time => time.time === this.selectedTime.time));
        }
        if (selectedTimeChanges && selectedTimeChanges.currentValue) {
            this._setClockHandPosition();
        }
        if (faceTimeChanges && faceTimeChanges.currentValue) {
            // To avoid an error ExpressionChangedAfterItHasBeenCheckedError
            setTimeout((/**
             * @return {?}
             */
            () => this._selectAvailableTime()));
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._removeTouchEvents();
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onMousedown(e) {
        e.preventDefault();
        this._isStarted = true;
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onMouseup(e) {
        e.preventDefault();
        this._isStarted = false;
    }
    /**
     * @param {?} e
     * @return {?}
     */
    selectTime(e) {
        if (!this._isStarted && (e instanceof MouseEvent && e.type !== "click")) {
            return;
        }
        /** @type {?} */
        const clockFaceCords = this.clockFace.nativeElement.getBoundingClientRect();
        /* Get x0 and y0 of the circle */
        /** @type {?} */
        const centerX = clockFaceCords.left + clockFaceCords.width / 2;
        /** @type {?} */
        const centerY = clockFaceCords.top + clockFaceCords.height / 2;
        /* Counting the arctangent and convert it to from radian to deg */
        /** @type {?} */
        const arctangent = Math.atan(Math.abs(e.clientX - centerX) / Math.abs(e.clientY - centerY)) * 180 / Math.PI;
        /* Get angle according to quadrant */
        /** @type {?} */
        const circleAngle = countAngleByCords(centerX, centerY, e.clientX, e.clientY, arctangent);
        /* Check if selected time from the inner clock face (24 hours format only) */
        /** @type {?} */
        const isInnerClockChosen = this.format && this._isInnerClockFace(centerX, centerY, e.clientX, e.clientY);
        /* Round angle according to angle step */
        /** @type {?} */
        const angleStep = this.unit === NgxMatTimepickerUnits.MINUTE ? (6 * (this.minutesGap || 1)) : 30;
        /** @type {?} */
        const roundedAngle = roundAngle(circleAngle, angleStep);
        /** @type {?} */
        const angle = (roundedAngle || 360) + (isInnerClockChosen ? 360 : 0);
        /** @type {?} */
        const selectedTime = this.faceTime.find((/**
         * @param {?} val
         * @return {?}
         */
        val => val.angle === angle));
        if (selectedTime && !selectedTime.disabled) {
            this.timeChange.next(selectedTime);
            /* To let know whether user ended interaction with clock face */
            if (!this._isStarted) {
                this.timeSelected.next(selectedTime.time);
            }
        }
    }
    /**
     * @param {?} _item_
     * @param {?} time
     * @return {?}
     */
    trackByTime(_item_, time) {
        return time.time;
    }
    /**
     * @private
     * @return {?}
     */
    _addTouchEvents() {
        this._touchStartHandler = this.onMousedown.bind(this);
        this._touchEndHandler = this.onMouseup.bind(this);
        this.clockFace.nativeElement.addEventListener("touchstart", this._touchStartHandler);
        this.clockFace.nativeElement.addEventListener("touchend", this._touchEndHandler);
    }
    /**
     * @private
     * @return {?}
     */
    _decreaseClockHand() {
        this.clockHand.nativeElement.style.height = CLOCK_HAND_STYLES.small.height;
        this.clockHand.nativeElement.style.top = CLOCK_HAND_STYLES.small.top;
    }
    /**
     * @private
     * @return {?}
     */
    _increaseClockHand() {
        this.clockHand.nativeElement.style.height = CLOCK_HAND_STYLES.large.height;
        this.clockHand.nativeElement.style.top = CLOCK_HAND_STYLES.large.top;
    }
    /**
     * @private
     * @param {?} x0
     * @param {?} y0
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    _isInnerClockFace(x0, y0, x, y) {
        /* Detect whether time from the inner clock face or not (24 format only) */
        return Math.sqrt(Math.pow(x - x0, 2) + Math.pow(y - y0, 2)) < this.innerClockFaceSize;
    }
    /**
     * @private
     * @return {?}
     */
    _removeTouchEvents() {
        this.clockFace.nativeElement.removeEventListener("touchstart", this._touchStartHandler);
        this.clockFace.nativeElement.removeEventListener("touchend", this._touchEndHandler);
    }
    /**
     * @private
     * @return {?}
     */
    _selectAvailableTime() {
        /** @type {?} */
        const currentTime = this.faceTime.find((/**
         * @param {?} time
         * @return {?}
         */
        time => this.selectedTime.time === time.time));
        this.isClockFaceDisabled = this.faceTime.every((/**
         * @param {?} time
         * @return {?}
         */
        time => time.disabled));
        if ((currentTime && currentTime.disabled) && !this.isClockFaceDisabled) {
            /** @type {?} */
            const availableTime = this.faceTime.find((/**
             * @param {?} time
             * @return {?}
             */
            time => !time.disabled));
            this.timeChange.next(availableTime);
        }
    }
    /**
     * @private
     * @return {?}
     */
    _setClockHandPosition() {
        if (this.format === 24) {
            if (this.selectedTime.time > 12 || this.selectedTime.time === 0) {
                this._decreaseClockHand();
            }
            else {
                this._increaseClockHand();
            }
        }
        this.clockHand.nativeElement.style.transform = `rotate(${this.selectedTime.angle}deg)`;
    }
}
NgxMatTimepickerFaceComponent.ɵfac = function NgxMatTimepickerFaceComponent_Factory(t) { return new (t || NgxMatTimepickerFaceComponent)(); };
NgxMatTimepickerFaceComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NgxMatTimepickerFaceComponent, selectors: [["ngx-mat-timepicker-face"]], viewQuery: function NgxMatTimepickerFaceComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c3, 7);
        ɵngcc0.ɵɵviewQuery(_c4, 7, ElementRef);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.clockFace = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.clockHand = _t.first);
    } }, hostBindings: function NgxMatTimepickerFaceComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mousedown", function NgxMatTimepickerFaceComponent_mousedown_HostBindingHandler($event) { return ctx.onMousedown($event); })("mouseup", function NgxMatTimepickerFaceComponent_mouseup_HostBindingHandler($event) { return ctx.onMouseup($event); })("click", function NgxMatTimepickerFaceComponent_click_HostBindingHandler($event) { return ctx.selectTime($event); })("touchmove", function NgxMatTimepickerFaceComponent_touchmove_HostBindingHandler($event) { return ctx.selectTime($event.changedTouches[0]); })("touchend", function NgxMatTimepickerFaceComponent_touchend_HostBindingHandler($event) { return ctx.selectTime($event.changedTouches[0]); })("mousemove", function NgxMatTimepickerFaceComponent_mousemove_HostBindingHandler($event) { return ctx.selectTime($event); });
    } }, inputs: { color: "color", selectedTime: "selectedTime", faceTime: "faceTime", format: "format", minutesGap: "minutesGap", unit: "unit" }, outputs: { timeChange: "timeChange", timeSelected: "timeSelected" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c7, decls: 11, vars: 9, consts: [["hourButton", ""], [1, "clock-face"], ["clockFace", ""], ["class", "clock-face__container", 4, "ngIf", "ngIfElse"], [1, "clock-face__clock-hand", 3, "color", "ngClass", "hidden"], ["clockHand", ""], ["mat-mini-fab", "", 3, "color", 4, "ngIf"], [1, "clock-face__center", 3, "color"], ["minutesFace", ""], ["mat-mini-fab", "", 1, "mat-elevation-z0", 3, "color", "ngStyle", "disabled"], [1, "clock-face__container"], ["class", "clock-face__number clock-face__number--outer", 3, "ngStyle", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["class", "clock-face__inner", 4, "ngIf"], [1, "clock-face__number", "clock-face__number--outer", 3, "ngStyle"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "clock-face__inner"], ["class", "clock-face__number clock-face__number--inner", 3, "top", "ngStyle", "height", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "clock-face__number", "clock-face__number--inner", 3, "ngStyle"], ["mat-mini-fab", "", 3, "color"], [1, "clock-face__clock-hand_minute_dot"], ["mat-mini-fab", "", 1, "mat-elevation-z0", 3, "disableRipple", "color", "ngStyle"]], template: function NgxMatTimepickerFaceComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c7);
        ɵngcc0.ɵɵtemplate(0, NgxMatTimepickerFaceComponent_ng_template_0_Template, 4, 13, "ng-template", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵelementStart(2, "div", 1, 2);
        ɵngcc0.ɵɵtemplate(4, NgxMatTimepickerFaceComponent_div_4_Template, 4, 7, "div", 3);
        ɵngcc0.ɵɵelementStart(5, "mat-toolbar", 4, 5);
        ɵngcc0.ɵɵtemplate(7, NgxMatTimepickerFaceComponent_button_7_Template, 2, 1, "button", 6);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(8, "mat-toolbar", 7);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(9, NgxMatTimepickerFaceComponent_ng_template_9_Template, 2, 2, "ng-template", null, 8, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        const _r6 = ɵngcc0.ɵɵreference(10);
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵproperty("ngIf", ctx.unit !== ctx.timeUnit.MINUTE)("ngIfElse", _r6);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("color", ctx.color)("ngClass", ɵngcc0.ɵɵpureFunction1(7, _c8, ctx.unit === ctx.timeUnit.MINUTE))("hidden", ctx.isClockFaceDisabled);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.unit === ctx.timeUnit.MINUTE);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("color", ctx.color);
    } }, directives: function () { return [ɵngcc1.NgIf, ɵngcc8.MatToolbar, ɵngcc1.NgClass, ɵngcc9.MatButton, ɵngcc1.NgStyle, ɵngcc1.NgForOf, ɵngcc1.NgTemplateOutlet]; }, pipes: function () { return [NgxMatTimepickerActiveHourPipe, NgxMatTimepickerTimeLocalizerPipe, ɵngcc1.SlicePipe, NgxMatTimepickerActiveMinutePipe, NgxMatTimepickerMinutesFormatterPipe]; }, styles: [".clock-face[_ngcontent-%COMP%]{width:290px;height:290px;border-radius:50%;position:relative;display:flex;justify-content:center;box-sizing:border-box;background-color:rgba(200,200,200,.5)!important}.clock-face__inner[_ngcontent-%COMP%]{position:absolute;top:0;left:0;width:100%;height:100%}.clock-face[_ngcontent-%COMP%]   [mat-mini-fab][_ngcontent-%COMP%]{box-shadow:none}.clock-face[_ngcontent-%COMP%]   [mat-mini-fab][_ngcontent-%COMP%]:not(.mat-primary):not(.mat-accent):not(.mat-warn){background:0 0}.clock-face__container[_ngcontent-%COMP%]{margin-left:-2px}.clock-face__number[_ngcontent-%COMP%]{position:absolute;transform-origin:25px 100%;width:50px;text-align:center;z-index:2;top:calc(50% - 125px);left:calc(50% - 25px)}.clock-face__number--outer[_ngcontent-%COMP%]{height:calc(290px / 2 - 20px)}.clock-face__number--outer[_ngcontent-%COMP%] > span[_ngcontent-%COMP%]{font-size:16px}.clock-face__number--inner[_ngcontent-%COMP%] > span[_ngcontent-%COMP%]{font-size:14px}.clock-face__clock-hand[_ngcontent-%COMP%]{height:103px;width:2px;padding:0;transform-origin:1px 100%;position:absolute;top:calc(50% - 103px);z-index:1}.clock-face__center[_ngcontent-%COMP%]{width:8px;height:8px;padding:0;position:absolute;border-radius:50%;top:50%;left:50%;margin:-4px}.clock-face__clock-hand_minute[_ngcontent-%COMP%] > button[_ngcontent-%COMP%]{position:absolute;top:-22px;left:calc(50% - 20px);box-sizing:content-box;display:flex;justify-content:center;align-items:center}.clock-face__clock-hand_minute[_ngcontent-%COMP%] > button[_ngcontent-%COMP%]   .clock-face__clock-hand_minute_dot[_ngcontent-%COMP%]{display:block;width:4px;height:4px;background:#fff;border-radius:50%}@media (max-device-width:1023px) and (orientation:landscape){.clock-face[_ngcontent-%COMP%]{width:250px;height:250px}}@media screen and (max-width:360px){.clock-face[_ngcontent-%COMP%]{width:250px;height:250px}}"], changeDetection: 0 });
NgxMatTimepickerFaceComponent.propDecorators = {
    clockFace: [{ type: ViewChild, args: ["clockFace", { static: true },] }],
    clockHand: [{ type: ViewChild, args: ["clockHand", { static: true, read: ElementRef },] }],
    color: [{ type: Input }],
    faceTime: [{ type: Input }],
    format: [{ type: Input }],
    minutesGap: [{ type: Input }],
    selectedTime: [{ type: Input }],
    timeChange: [{ type: Output }],
    timeSelected: [{ type: Output }],
    unit: [{ type: Input }],
    onMousedown: [{ type: HostListener, args: ["mousedown", ["$event"],] }],
    onMouseup: [{ type: HostListener, args: ["mouseup", ["$event"],] }],
    selectTime: [{ type: HostListener, args: ["click", ["$event"],] }, { type: HostListener, args: ["touchmove", ["$event.changedTouches[0]"],] }, { type: HostListener, args: ["touchend", ["$event.changedTouches[0]"],] }, { type: HostListener, args: ["mousemove", ["$event"],] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxMatTimepickerFaceComponent, [{
        type: Component,
        args: [{
                selector: "ngx-mat-timepicker-face",
                template: "<ng-template #hourButton\n             let-time>\n    <button mat-mini-fab\n            class=\"mat-elevation-z0\"\n            [color]=\"(time.time | activeHour: selectedTime?.time : isClockFaceDisabled) ? color : undefined\"\n            [ngStyle]=\"{'transform': 'rotateZ(-'+ time.angle +'deg)'}\"\n            [disabled]=\"time.disabled\">\n        {{time.time | timeLocalizer: timeUnit.HOUR}}\n    </button>\n</ng-template>\n<div class=\"clock-face\"\n     #clockFace>\n    <div *ngIf=\"unit !== timeUnit.MINUTE;else minutesFace\"\n         class=\"clock-face__container\">\n        <div class=\"clock-face__number clock-face__number--outer\"\n             [ngStyle]=\"{'transform': 'rotateZ('+ time.angle +'deg)'}\"\n             *ngFor=\"let time of faceTime | slice: 0 : 12; trackBy: trackByTime\">\n            <ng-content *ngTemplateOutlet=\"hourButton; context: {$implicit: time}\"></ng-content>\n        </div>\n        <div class=\"clock-face__inner\"\n             *ngIf=\"faceTime.length > 12\">\n            <div class=\"clock-face__number clock-face__number--inner\"\n                 [style.top]=\"'calc(50% - ' + innerClockFaceSize + 'px)'\"\n                 [ngStyle]=\"{'transform': 'rotateZ('+ time.angle +'deg)'}\"\n                 [style.height.px]=\"innerClockFaceSize\"\n                 *ngFor=\"let time of faceTime | slice: 12 : 24; trackBy: trackByTime\">\n                <ng-content *ngTemplateOutlet=\"hourButton; context: {$implicit: time}\"></ng-content>\n            </div>\n        </div>\n    </div>\n    <mat-toolbar class=\"clock-face__clock-hand\"\n                 [color]=\"color\"\n                 [ngClass]=\"{'clock-face__clock-hand_minute': unit === timeUnit.MINUTE}\"\n                 #clockHand\n                 [hidden]=\"isClockFaceDisabled\">\n        <button mat-mini-fab\n                *ngIf=\"unit === timeUnit.MINUTE\"\n                [color]=\"color\">\n            <span class=\"clock-face__clock-hand_minute_dot\"></span>\n        </button>\n    </mat-toolbar>\n    <mat-toolbar class=\"clock-face__center\"\n                 [color]=\"color\"></mat-toolbar>\n</div>\n<ng-template #minutesFace>\n    <div class=\"clock-face__container\">\n        <div class=\"clock-face__number clock-face__number--outer\"\n             [ngStyle]=\"{'transform': 'rotateZ('+ time.angle +'deg)'}\"\n             *ngFor=\"let time of faceTime; trackBy: trackByTime\">\n            <button mat-mini-fab\n                    class=\"mat-elevation-z0\"\n                    [disableRipple]=\"time.time % minutesGap !== 0\"\n                    [color]=\"(time.time | activeMinute: selectedTime?.time:minutesGap:isClockFaceDisabled) ? color : undefined\"\n                    [ngStyle]=\"{'transform': 'rotateZ(-'+ time.angle +'deg)'}\">\n                {{time.time | minutesFormatter: minutesGap | timeLocalizer: timeUnit.MINUTE}}\n            </button>\n        </div>\n    </div>\n</ng-template>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".clock-face{width:290px;height:290px;border-radius:50%;position:relative;display:flex;justify-content:center;box-sizing:border-box;background-color:rgba(200,200,200,.5)!important}.clock-face__inner{position:absolute;top:0;left:0;width:100%;height:100%}.clock-face [mat-mini-fab]{box-shadow:none}.clock-face [mat-mini-fab]:not(.mat-primary):not(.mat-accent):not(.mat-warn){background:0 0}.clock-face__container{margin-left:-2px}.clock-face__number{position:absolute;transform-origin:25px 100%;width:50px;text-align:center;z-index:2;top:calc(50% - 125px);left:calc(50% - 25px)}.clock-face__number--outer{height:calc(290px / 2 - 20px)}.clock-face__number--outer>span{font-size:16px}.clock-face__number--inner>span{font-size:14px}.clock-face__clock-hand{height:103px;width:2px;padding:0;transform-origin:1px 100%;position:absolute;top:calc(50% - 103px);z-index:1}.clock-face__center{width:8px;height:8px;padding:0;position:absolute;border-radius:50%;top:50%;left:50%;margin:-4px}.clock-face__clock-hand_minute>button{position:absolute;top:-22px;left:calc(50% - 20px);box-sizing:content-box;display:flex;justify-content:center;align-items:center}.clock-face__clock-hand_minute>button .clock-face__clock-hand_minute_dot{display:block;width:4px;height:4px;background:#fff;border-radius:50%}@media (max-device-width:1023px) and (orientation:landscape){.clock-face{width:250px;height:250px}}@media screen and (max-width:360px){.clock-face{width:250px;height:250px}}"]
            }]
    }], function () { return []; }, { color: [{
            type: Input
        }], timeChange: [{
            type: Output
        }], timeSelected: [{
            type: Output
        }], selectedTime: [{
            type: Input
        }], 
    /**
     * @param {?} e
     * @return {?}
     */
    onMousedown: [{
            type: HostListener,
            args: ["mousedown", ["$event"]]
        }], 
    /**
     * @param {?} e
     * @return {?}
     */
    onMouseup: [{
            type: HostListener,
            args: ["mouseup", ["$event"]]
        }], 
    /**
     * @param {?} e
     * @return {?}
     */
    selectTime: [{
            type: HostListener,
            args: ["click", ["$event"]]
        }, {
            type: HostListener,
            args: ["touchmove", ["$event.changedTouches[0]"]]
        }, {
            type: HostListener,
            args: ["touchend", ["$event.changedTouches[0]"]]
        }, {
            type: HostListener,
            args: ["mousemove", ["$event"]]
        }], clockFace: [{
            type: ViewChild,
            args: ["clockFace", { static: true }]
        }], clockHand: [{
            type: ViewChild,
            args: ["clockHand", { static: true, read: ElementRef }]
        }], faceTime: [{
            type: Input
        }], format: [{
            type: Input
        }], minutesGap: [{
            type: Input
        }], unit: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * Generated from: lib/components/ngx-mat-timepicker-dial/ngx-mat-timepicker-dial.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxMatTimepickerDialComponent {
    /**
     * @param {?} _locale
     */
    constructor(_locale) {
        this._locale = _locale;
        this.hourChanged = new EventEmitter();
        this.meridiems = Info.meridiems({ locale: this._locale });
        this.minuteChanged = new EventEmitter();
        this.periodChanged = new EventEmitter();
        this.timeUnit = NgxMatTimepickerUnits;
        this.timeUnitChanged = new EventEmitter();
        this._color = "primary";
    }
    /**
     * @param {?} newValue
     * @return {?}
     */
    set color(newValue) {
        this._color = newValue;
    }
    /**
     * @return {?}
     */
    get color() {
        return this._color;
    }
    /**
     * @param {?} hour
     * @return {?}
     */
    changeHour(hour) {
        this.hourChanged.next(hour);
    }
    /**
     * @param {?} minute
     * @return {?}
     */
    changeMinute(minute) {
        this.minuteChanged.next(minute);
    }
    /**
     * @param {?} period
     * @return {?}
     */
    changePeriod(period) {
        this.periodChanged.next(period);
    }
    /**
     * @param {?} unit
     * @return {?}
     */
    changeTimeUnit(unit) {
        this.timeUnitChanged.next(unit);
    }
    /**
     * @return {?}
     */
    hideHint() {
        this.isHintVisible = false;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const periodChanged = changes.period && changes.period.currentValue;
        if (periodChanged || changes.format && changes.format.currentValue) {
            /** @type {?} */
            const hours = NgxMatTimepickerUtils.getHours(this.format);
            this.hours = NgxMatTimepickerUtils.disableHours(hours, {
                min: this.minTime,
                max: this.maxTime,
                format: this.format,
                period: this.period
            });
        }
        if (periodChanged || changes.hour && changes.hour.currentValue) {
            /** @type {?} */
            const minutes = NgxMatTimepickerUtils.getMinutes(this.minutesGap);
            this.minutes = NgxMatTimepickerUtils.disableMinutes(minutes, +this.hour, {
                min: this.minTime,
                max: this.maxTime,
                format: this.format,
                period: this.period
            });
        }
    }
    /**
     * @return {?}
     */
    showHint() {
        this.isHintVisible = true;
    }
}
NgxMatTimepickerDialComponent.ɵfac = function NgxMatTimepickerDialComponent_Factory(t) { return new (t || NgxMatTimepickerDialComponent)(ɵngcc0.ɵɵdirectiveInject(NGX_MAT_TIMEPICKER_LOCALE)); };
NgxMatTimepickerDialComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NgxMatTimepickerDialComponent, selectors: [["ngx-mat-timepicker-dial"]], inputs: { color: "color", activeTimeUnit: "activeTimeUnit", editableHintTmpl: "editableHintTmpl", format: "format", hour: "hour", hoursOnly: "hoursOnly", isEditable: "isEditable", maxTime: "maxTime", minTime: "minTime", minute: "minute", minutesGap: "minutesGap", period: "period" }, outputs: { hourChanged: "hourChanged", minuteChanged: "minuteChanged", periodChanged: "periodChanged", timeUnitChanged: "timeUnitChanged" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 9, vars: 14, consts: [[1, "timepicker-dial"], [1, "timepicker-dial__container"], [1, "timepicker-dial__time"], [3, "timeList", "time", "timeUnit", "isActive", "isEditable", "timeUnitChanged", "timeChanged", "focused", "unfocused"], [3, "timeList", "time", "timeUnit", "isActive", "isEditable", "minutesGap", "disabled", "timeUnitChanged", "timeChanged", "focused", "unfocused"], ["class", "timepicker-dial__period", 3, "selectedPeriod", "activeTimeUnit", "maxTime", "minTime", "format", "hours", "minutes", "selectedHour", "meridiems", "periodChanged", 4, "ngIf"], [3, "ngClass", 4, "ngIf"], [1, "timepicker-dial__period", 3, "selectedPeriod", "activeTimeUnit", "maxTime", "minTime", "format", "hours", "minutes", "selectedHour", "meridiems", "periodChanged"], [3, "ngClass"], [4, "ngTemplateOutlet"], ["editableHintDefault", ""], [1, "timepicker-dial__hint"]], template: function NgxMatTimepickerDialComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵelementStart(2, "div", 2);
        ɵngcc0.ɵɵelementStart(3, "ngx-mat-timepicker-dial-control", 3);
        ɵngcc0.ɵɵlistener("timeUnitChanged", function NgxMatTimepickerDialComponent_Template_ngx_mat_timepicker_dial_control_timeUnitChanged_3_listener($event) { return ctx.changeTimeUnit($event); })("timeChanged", function NgxMatTimepickerDialComponent_Template_ngx_mat_timepicker_dial_control_timeChanged_3_listener($event) { return ctx.changeHour($event); })("focused", function NgxMatTimepickerDialComponent_Template_ngx_mat_timepicker_dial_control_focused_3_listener() { return ctx.showHint(); })("unfocused", function NgxMatTimepickerDialComponent_Template_ngx_mat_timepicker_dial_control_unfocused_3_listener() { return ctx.hideHint(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "span");
        ɵngcc0.ɵɵtext(5, ":");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(6, "ngx-mat-timepicker-dial-control", 4);
        ɵngcc0.ɵɵlistener("timeUnitChanged", function NgxMatTimepickerDialComponent_Template_ngx_mat_timepicker_dial_control_timeUnitChanged_6_listener($event) { return ctx.changeTimeUnit($event); })("timeChanged", function NgxMatTimepickerDialComponent_Template_ngx_mat_timepicker_dial_control_timeChanged_6_listener($event) { return ctx.changeMinute($event); })("focused", function NgxMatTimepickerDialComponent_Template_ngx_mat_timepicker_dial_control_focused_6_listener() { return ctx.showHint(); })("unfocused", function NgxMatTimepickerDialComponent_Template_ngx_mat_timepicker_dial_control_unfocused_6_listener() { return ctx.hideHint(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(7, NgxMatTimepickerDialComponent_ngx_mat_timepicker_period_7_Template, 1, 9, "ngx-mat-timepicker-period", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(8, NgxMatTimepickerDialComponent_div_8_Template, 4, 4, "div", 6);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("timeList", ctx.hours)("time", ctx.hour)("timeUnit", ctx.timeUnit.HOUR)("isActive", ctx.activeTimeUnit === ctx.timeUnit.HOUR)("isEditable", ctx.isEditable);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("timeList", ctx.minutes)("time", ctx.minute)("timeUnit", ctx.timeUnit.MINUTE)("isActive", ctx.activeTimeUnit === ctx.timeUnit.MINUTE)("isEditable", ctx.isEditable)("minutesGap", ctx.minutesGap)("disabled", ctx.hoursOnly);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.format !== 24);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isEditable || ctx.editableHintTmpl);
    } }, directives: function () { return [NgxMatTimepickerDialControlComponent, ɵngcc1.NgIf, NgxMatTimepickerPeriodComponent, ɵngcc1.NgClass, ɵngcc1.NgTemplateOutlet]; }, styles: [".timepicker-dial[_ngcontent-%COMP%]{text-align:center}.timepicker-dial__container[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:center;-webkit-tap-highlight-color:transparent}.timepicker-dial__time[_ngcontent-%COMP%]{display:flex;align-items:baseline;line-height:normal;font-size:50px}.timepicker-dial__period[_ngcontent-%COMP%]{display:block;margin-left:10px}.timepicker-dial__hint-container--hidden[_ngcontent-%COMP%]{visibility:hidden}.timepicker-dial__hint[_ngcontent-%COMP%]{display:inline-block;font-size:10px}.timepicker-dial__hint[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{font-size:14px}"], changeDetection: 0 });
/** @nocollapse */
NgxMatTimepickerDialComponent.ctorParameters = () => [
    { type: String, decorators: [{ type: Inject, args: [NGX_MAT_TIMEPICKER_LOCALE,] }] }
];
NgxMatTimepickerDialComponent.propDecorators = {
    activeTimeUnit: [{ type: Input }],
    color: [{ type: Input }],
    editableHintTmpl: [{ type: Input }],
    format: [{ type: Input }],
    hour: [{ type: Input }],
    hourChanged: [{ type: Output }],
    hoursOnly: [{ type: Input }],
    isEditable: [{ type: Input }],
    maxTime: [{ type: Input }],
    minTime: [{ type: Input }],
    minute: [{ type: Input }],
    minuteChanged: [{ type: Output }],
    minutesGap: [{ type: Input }],
    period: [{ type: Input }],
    periodChanged: [{ type: Output }],
    timeUnitChanged: [{ type: Output }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxMatTimepickerDialComponent, [{
        type: Component,
        args: [{
                selector: "ngx-mat-timepicker-dial",
                template: "<div class=\"timepicker-dial\">\n    <div class=\"timepicker-dial__container\">\n        <div class=\"timepicker-dial__time\">\n            <ngx-mat-timepicker-dial-control [timeList]=\"hours\"\n                                         [time]=\"hour\"\n                                         [timeUnit]=\"timeUnit.HOUR\"\n                                         [isActive]=\"activeTimeUnit === timeUnit.HOUR\"\n                                         [isEditable]=\"isEditable\"\n                                         (timeUnitChanged)=\"changeTimeUnit($event)\"\n                                         (timeChanged)=\"changeHour($event)\"\n                                         (focused)=\"showHint()\"\n                                         (unfocused)=\"hideHint()\">\n\n            </ngx-mat-timepicker-dial-control>\n            <span>:</span>\n            <ngx-mat-timepicker-dial-control [timeList]=\"minutes\"\n                                         [time]=\"minute\"\n                                         [timeUnit]=\"timeUnit.MINUTE\"\n                                         [isActive]=\"activeTimeUnit === timeUnit.MINUTE\"\n                                         [isEditable]=\"isEditable\"\n                                         [minutesGap]=\"minutesGap\"\n                                         [disabled]=\"hoursOnly\"\n                                         (timeUnitChanged)=\"changeTimeUnit($event)\"\n                                         (timeChanged)=\"changeMinute($event)\"\n                                         (focused)=\"showHint()\"\n                                         (unfocused)=\"hideHint()\">\n\n            </ngx-mat-timepicker-dial-control>\n        </div>\n        <ngx-mat-timepicker-period class=\"timepicker-dial__period\"\n                                   *ngIf=\"format !== 24\"\n                                   [selectedPeriod]=\"period\"\n                                   [activeTimeUnit]=\"activeTimeUnit\"\n                                   [maxTime]=\"maxTime\"\n                                   [minTime]=\"minTime\"\n                                   [format]=\"format\"\n                                   [hours]=\"hours\"\n                                   [minutes]=\"minutes\"\n                                   [selectedHour]=\"hour\"\n                                   [meridiems]=\"meridiems\"\n                                   (periodChanged)=\"changePeriod($event)\"></ngx-mat-timepicker-period>\n    </div>\n    <div *ngIf=\"isEditable || editableHintTmpl\"\n         [ngClass]=\"{'timepicker-dial__hint-container--hidden': !isHintVisible}\">\n        <ng-container *ngTemplateOutlet=\"editableHintTmpl ? editableHintTmpl : editableHintDefault\"></ng-container>\n        <ng-template #editableHintDefault>\n            <small class=\"timepicker-dial__hint\"> * use arrows (<span>&#8645;</span>) to change the time</small>\n        </ng-template>\n    </div>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".timepicker-dial{text-align:center}.timepicker-dial__container{display:flex;align-items:center;justify-content:center;-webkit-tap-highlight-color:transparent}.timepicker-dial__time{display:flex;align-items:baseline;line-height:normal;font-size:50px}.timepicker-dial__period{display:block;margin-left:10px}.timepicker-dial__hint-container--hidden{visibility:hidden}.timepicker-dial__hint{display:inline-block;font-size:10px}.timepicker-dial__hint span{font-size:14px}"]
            }]
    }], function () { return [{ type: String, decorators: [{
                type: Inject,
                args: [NGX_MAT_TIMEPICKER_LOCALE]
            }] }]; }, { hourChanged: [{
            type: Output
        }], minuteChanged: [{
            type: Output
        }], periodChanged: [{
            type: Output
        }], timeUnitChanged: [{
            type: Output
        }], color: [{
            type: Input
        }], activeTimeUnit: [{
            type: Input
        }], editableHintTmpl: [{
            type: Input
        }], format: [{
            type: Input
        }], hour: [{
            type: Input
        }], hoursOnly: [{
            type: Input
        }], isEditable: [{
            type: Input
        }], maxTime: [{
            type: Input
        }], minTime: [{
            type: Input
        }], minute: [{
            type: Input
        }], minutesGap: [{
            type: Input
        }], period: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * Generated from: lib/models/ngx-mat-timepicker-measures.enum.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const NgxMatTimepickerMeasure = {
    hour: "hour",
    minute: "minute",
};

/**
 * @fileoverview added by tsickle
 * Generated from: lib/pipes/ngx-mat-timepicker-parser.pipe.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxMatTimepickerParserPipe {
    /**
     * @param {?} _locale
     */
    constructor(_locale) {
        this._locale = _locale;
        this._numberingSystem = (/** @type {?} */ (DateTime.local().setLocale(this._locale).resolvedLocaleOpts().numberingSystem));
    }
    /**
     * @param {?} time
     * @param {?=} timeUnit
     * @return {?}
     */
    transform(time, timeUnit = NgxMatTimepickerUnits.HOUR) {
        if (time == null || time === "") {
            return "";
        }
        if (!isNaN(+time)) {
            return `${time}`;
        }
        if (timeUnit === NgxMatTimepickerUnits.MINUTE) {
            return this._parseTime(time, "mm", NgxMatTimepickerMeasure.minute).toString();
        }
        return this._parseTime(time, "HH", NgxMatTimepickerMeasure.hour).toString();
    }
    /**
     * @private
     * @param {?} time
     * @param {?} format
     * @param {?} timeMeasure
     * @return {?}
     */
    _parseTime(time, format, timeMeasure) {
        /** @type {?} */
        const parsedTime = DateTime.fromFormat(String(time), format, { numberingSystem: this._numberingSystem })[timeMeasure];
        if (!isNaN(parsedTime)) {
            return parsedTime;
        }
        throw new Error(`Cannot parse time - ${time}`);
    }
}
NgxMatTimepickerParserPipe.ɵfac = function NgxMatTimepickerParserPipe_Factory(t) { return new (t || NgxMatTimepickerParserPipe)(ɵngcc0.ɵɵdirectiveInject(NGX_MAT_TIMEPICKER_LOCALE, 16)); };
NgxMatTimepickerParserPipe.ɵpipe = /*@__PURE__*/ ɵngcc0.ɵɵdefinePipe({ name: "ngxMatTimepickerParser", type: NgxMatTimepickerParserPipe, pure: true });
NgxMatTimepickerParserPipe.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: NgxMatTimepickerParserPipe, factory: NgxMatTimepickerParserPipe.ɵfac });
/** @nocollapse */
NgxMatTimepickerParserPipe.ctorParameters = () => [
    { type: String, decorators: [{ type: Inject, args: [NGX_MAT_TIMEPICKER_LOCALE,] }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxMatTimepickerParserPipe, [{
        type: Pipe,
        args: [{
                name: "ngxMatTimepickerParser"
            }]
    }, {
        type: Injectable
    }], function () { return [{ type: String, decorators: [{
                type: Inject,
                args: [NGX_MAT_TIMEPICKER_LOCALE]
            }] }]; }, null); })();

/**
 * @fileoverview added by tsickle
 * Generated from: lib/components/ngx-mat-timepicker-dial-control/ngx-mat-timepicker-dial-control.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function retainSelection() {
    this.selectionStart = this.selectionEnd;
}
class NgxMatTimepickerDialControlComponent {
    /**
     * @param {?} _elRef
     * @param {?} _timeParserPipe
     */
    constructor(_elRef, _timeParserPipe) {
        this._elRef = _elRef;
        this._timeParserPipe = _timeParserPipe;
        this.focused = new EventEmitter();
        this.timeChanged = new EventEmitter();
        this.timeUnitChanged = new EventEmitter();
        this.unfocused = new EventEmitter();
    }
    /**
     * @private
     * @return {?}
     */
    get _selectedTime() {
        if (!!this.time) {
            return this.timeList.find((/**
             * @param {?} t
             * @return {?}
             */
            t => t.time === +this.time));
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    changeTimeByKeyboard(e) {
        /** @type {?} */
        const char = String.fromCharCode(e.keyCode);
        if (isTimeDisabledToChange(this.time, char, this.timeList)) {
            e.preventDefault();
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this._elRef.nativeElement.querySelector("input").addEventListener("select", retainSelection, false);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._elRef.nativeElement.querySelector("input").removeEventListener("select", retainSelection);
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onKeydown(e) {
        if (!NgxMatTimepickerUtils.isDigit(e)) {
            e.preventDefault();
        }
        else {
            this._changeTimeByArrow(e.keyCode);
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    onModelChange(value) {
        this.time = this._timeParserPipe.transform(value, this.timeUnit);
    }
    /**
     * @param {?} event
     * @param {?} unit
     * @return {?}
     */
    saveTimeAndChangeTimeUnit(event, unit) {
        event.preventDefault();
        this.previousTime = this.time;
        this.timeUnitChanged.next(unit);
        this.focused.next();
    }
    /**
     * @return {?}
     */
    updateTime() {
        if (this._selectedTime) {
            this.timeChanged.next(this._selectedTime);
            this.previousTime = this._selectedTime.time;
        }
    }
    /**
     * @private
     * @param {?} amount
     * @return {?}
     */
    _addTime(amount) {
        return `0${+this.time + amount}`.substr(-2);
    }
    /**
     * @private
     * @param {?} keyCode
     * @return {?}
     */
    _changeTimeByArrow(keyCode) {
        /** @type {?} */
        let time;
        // arrow up
        if (keyCode === 38) {
            time = this._addTime(this.minutesGap || 1);
        }
        // arrow down
        else if (keyCode === 40) {
            time = this._addTime(-1 * (this.minutesGap || 1));
        }
        if (!isTimeUnavailable(time, this.timeList)) {
            this.time = time;
            this.updateTime();
        }
    }
}
NgxMatTimepickerDialControlComponent.ɵfac = function NgxMatTimepickerDialControlComponent_Factory(t) { return new (t || NgxMatTimepickerDialControlComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NgxMatTimepickerParserPipe)); };
NgxMatTimepickerDialControlComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NgxMatTimepickerDialControlComponent, selectors: [["ngx-mat-timepicker-dial-control"]], inputs: { time: "time", disabled: "disabled", isActive: "isActive", isEditable: "isEditable", minutesGap: "minutesGap", timeList: "timeList", timeUnit: "timeUnit" }, outputs: { focused: "focused", timeChanged: "timeChanged", timeUnitChanged: "timeUnitChanged", unfocused: "unfocused" }, features: [ɵngcc0.ɵɵProvidersFeature([NgxMatTimepickerParserPipe])], decls: 3, vars: 2, consts: [["class", "timepicker-dial__control timepicker-dial__item", "readonly", "", 3, "ngClass", "ngModel", "disabled", "ngxMatTimepickerAutofocus", "ngModelChange", "input", "focus", 4, "ngIf", "ngIfElse"], ["editableTemplate", ""], ["readonly", "", 1, "timepicker-dial__control", "timepicker-dial__item", 3, "ngClass", "ngModel", "disabled", "ngxMatTimepickerAutofocus", "ngModelChange", "input", "focus"], [1, "timepicker-dial__control", "timepicker-dial__item", "timepicker-dial__control_editable", 3, "ngClass", "ngModel", "disabled", "ngxMatTimepickerAutofocus", "ngModelChange", "input", "focus", "keydown", "keypress"]], template: function NgxMatTimepickerDialControlComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NgxMatTimepickerDialControlComponent_input_0_Template, 2, 10, "input", 0);
        ɵngcc0.ɵɵtemplate(1, NgxMatTimepickerDialControlComponent_ng_template_1_Template, 3, 13, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        const _r1 = ɵngcc0.ɵɵreference(2);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.isEditable)("ngIfElse", _r1);
    } }, directives: function () { return [ɵngcc1.NgIf, ɵngcc4.DefaultValueAccessor, ɵngcc1.NgClass, ɵngcc4.NgControlStatus, ɵngcc4.NgModel, NgxMatTimepickerAutofocusDirective]; }, pipes: function () { return [NgxMatTimepickerTimeLocalizerPipe, NgxMatTimepickerParserPipe]; }, styles: [".timepicker-dial__control[_ngcontent-%COMP%]{border:none;background-color:transparent;font-size:50px;width:60px;padding:0;border-radius:3px;text-align:center;color:inherit}.timepicker-dial__control[_ngcontent-%COMP%]:focus{outline:0;background-color:rgba(0,0,0,.1)}.timepicker-dial__control[_ngcontent-%COMP%]:disabled{cursor:default}"] });
/** @nocollapse */
NgxMatTimepickerDialControlComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: NgxMatTimepickerParserPipe }
];
NgxMatTimepickerDialControlComponent.propDecorators = {
    disabled: [{ type: Input }],
    focused: [{ type: Output }],
    isActive: [{ type: Input }],
    isEditable: [{ type: Input }],
    minutesGap: [{ type: Input }],
    time: [{ type: Input }],
    timeChanged: [{ type: Output }],
    timeList: [{ type: Input }],
    timeUnit: [{ type: Input }],
    timeUnitChanged: [{ type: Output }],
    unfocused: [{ type: Output }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxMatTimepickerDialControlComponent, [{
        type: Component,
        args: [{
                selector: "ngx-mat-timepicker-dial-control",
                template: "<input class=\"timepicker-dial__control timepicker-dial__item\"\n       [ngClass]=\"{'active': isActive}\"\n       [ngModel]=\"time | timeLocalizer: timeUnit: true\"\n       (ngModelChange)=\"time = $event\"\n       [disabled]=\"disabled\"\n       (input)=\"updateTime()\"\n       (focus)=\"saveTimeAndChangeTimeUnit($event, timeUnit)\"\n       readonly\n       [ngxMatTimepickerAutofocus]=\"isActive\"\n       *ngIf=\"!isEditable;else editableTemplate\">\n\n<ng-template #editableTemplate>\n    <input class=\"timepicker-dial__control timepicker-dial__item timepicker-dial__control_editable\"\n           [ngClass]=\"{'active': isActive}\"\n           [ngModel]=\"time | ngxMatTimepickerParser: timeUnit | timeLocalizer: timeUnit : true\"\n           (ngModelChange)=\"onModelChange($event)\"\n           [disabled]=\"disabled\"\n           (input)=\"updateTime()\"\n           (focus)=\"saveTimeAndChangeTimeUnit($event, timeUnit)\"\n           [ngxMatTimepickerAutofocus]=\"isActive\"\n           (keydown)=\"onKeydown($event)\"\n           (keypress)=\"changeTimeByKeyboard($event)\">\n</ng-template>\n",
                providers: [NgxMatTimepickerParserPipe],
                styles: [".timepicker-dial__control{border:none;background-color:transparent;font-size:50px;width:60px;padding:0;border-radius:3px;text-align:center;color:inherit}.timepicker-dial__control:focus{outline:0;background-color:rgba(0,0,0,.1)}.timepicker-dial__control:disabled{cursor:default}"]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: NgxMatTimepickerParserPipe }]; }, { focused: [{
            type: Output
        }], timeChanged: [{
            type: Output
        }], timeUnitChanged: [{
            type: Output
        }], unfocused: [{
            type: Output
        }], time: [{
            type: Input
        }], disabled: [{
            type: Input
        }], isActive: [{
            type: Input
        }], isEditable: [{
            type: Input
        }], minutesGap: [{
            type: Input
        }], timeList: [{
            type: Input
        }], timeUnit: [{
            type: Input
        }] }); })();
/**
 * @param {?} currentTime
 * @param {?} nextTime
 * @param {?} timeList
 * @return {?}
 */
function isTimeDisabledToChange(currentTime, nextTime, timeList) {
    /** @type {?} */
    const isNumber = /\d/.test(nextTime);
    if (isNumber) {
        /** @type {?} */
        const time = currentTime + nextTime;
        return isTimeUnavailable(time, timeList);
    }
}
/**
 * @param {?} time
 * @param {?} timeList
 * @return {?}
 */
function isTimeUnavailable(time, timeList) {
    /** @type {?} */
    const selectedTime = timeList.find((/**
     * @param {?} value
     * @return {?}
     */
    value => value.time === +time));
    return !selectedTime || (selectedTime && selectedTime.disabled);
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/components/ngx-mat-timepicker-period/ngx-mat-timepicker-period.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxMatTimepickerPeriodComponent {
    constructor() {
        this.isPeriodAvailable = true;
        this.periodChanged = new EventEmitter();
        this.timePeriod = NgxMatTimepickerPeriods;
    }
    /**
     * @return {?}
     */
    animationDone() {
        this.isPeriodAvailable = true;
    }
    /**
     * @param {?} period
     * @return {?}
     */
    changePeriod(period) {
        this.isPeriodAvailable = this._isSwitchPeriodAvailable(period);
        if (this.isPeriodAvailable) {
            this.periodChanged.next(period);
        }
    }
    /**
     * @private
     * @param {?} period
     * @return {?}
     */
    _getDisabledTimeByPeriod(period) {
        switch (this.activeTimeUnit) {
            case NgxMatTimepickerUnits.HOUR:
                return NgxMatTimepickerUtils.disableHours(this.hours, {
                    min: this.minTime,
                    max: this.maxTime,
                    format: this.format,
                    period
                });
            case NgxMatTimepickerUnits.MINUTE:
                return NgxMatTimepickerUtils.disableMinutes(this.minutes, +this.selectedHour, {
                    min: this.minTime,
                    max: this.maxTime,
                    format: this.format,
                    period
                });
            default:
                throw new Error("no such NgxMatTimepickerUnits");
        }
    }
    /**
     * @private
     * @param {?} period
     * @return {?}
     */
    _isSwitchPeriodAvailable(period) {
        /** @type {?} */
        const time = this._getDisabledTimeByPeriod(period);
        return !time.every((/**
         * @param {?} t
         * @return {?}
         */
        t => t.disabled));
    }
}
NgxMatTimepickerPeriodComponent.ɵfac = function NgxMatTimepickerPeriodComponent_Factory(t) { return new (t || NgxMatTimepickerPeriodComponent)(); };
NgxMatTimepickerPeriodComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NgxMatTimepickerPeriodComponent, selectors: [["ngx-mat-timepicker-period"]], inputs: { activeTimeUnit: "activeTimeUnit", format: "format", hours: "hours", maxTime: "maxTime", meridiems: "meridiems", minTime: "minTime", minutes: "minutes", selectedHour: "selectedHour", selectedPeriod: "selectedPeriod" }, outputs: { periodChanged: "periodChanged" }, decls: 6, vars: 9, consts: [[1, "timepicker-period"], ["type", "button", 1, "timepicker-dial__item", "timepicker-period__btn", 3, "ngClass", "click"], ["class", "timepicker-period__warning", 4, "ngIf"], [1, "timepicker-period__warning"]], template: function NgxMatTimepickerPeriodComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "button", 1);
        ɵngcc0.ɵɵlistener("click", function NgxMatTimepickerPeriodComponent_Template_button_click_1_listener() { return ctx.changePeriod(ctx.timePeriod.AM); });
        ɵngcc0.ɵɵtext(2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "button", 1);
        ɵngcc0.ɵɵlistener("click", function NgxMatTimepickerPeriodComponent_Template_button_click_3_listener() { return ctx.changePeriod(ctx.timePeriod.PM); });
        ɵngcc0.ɵɵtext(4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(5, NgxMatTimepickerPeriodComponent_div_5_Template, 3, 1, "div", 2);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(5, _c10, ctx.selectedPeriod === ctx.timePeriod.AM));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.meridiems[0]);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(7, _c10, ctx.selectedPeriod === ctx.timePeriod.PM));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.meridiems[1]);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.isPeriodAvailable);
    } }, directives: [ɵngcc1.NgClass, ɵngcc1.NgIf], styles: [".timepicker-period[_ngcontent-%COMP%]{display:flex;flex-direction:column;position:relative}.timepicker-period__btn[_ngcontent-%COMP%]{opacity:.5;padding:1px 3px;border:0;background-color:transparent;font-size:18px;font-weight:500;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;outline:0;border-radius:3px;transition:background-color .5s;color:inherit}.timepicker-period__btn.active[_ngcontent-%COMP%]{opacity:1}.timepicker-period__btn[_ngcontent-%COMP%]:focus{background-color:rgba(0,0,0,.07)}.timepicker-period__warning[_ngcontent-%COMP%]{padding:5px 10px;border-radius:3px;background-color:rgba(0,0,0,.55);position:absolute;width:200px;left:-20px;top:40px}.timepicker-period__warning[_ngcontent-%COMP%] > p[_ngcontent-%COMP%]{margin:0;font-size:12px}"], data: { animation: [
            trigger("scaleInOut", [
                transition(":enter", [
                    style({ transform: "scale(0)" }),
                    animate(".2s", style({ transform: "scale(1)" })),
                    sequence([
                        animate("3s", style({ opacity: 1 })),
                        animate(".3s", style({ opacity: 0 }))
                    ])
                ])
            ])
        ] } });
NgxMatTimepickerPeriodComponent.propDecorators = {
    activeTimeUnit: [{ type: Input }],
    format: [{ type: Input }],
    hours: [{ type: Input }],
    maxTime: [{ type: Input }],
    meridiems: [{ type: Input }],
    minTime: [{ type: Input }],
    minutes: [{ type: Input }],
    periodChanged: [{ type: Output }],
    selectedHour: [{ type: Input }],
    selectedPeriod: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxMatTimepickerPeriodComponent, [{
        type: Component,
        args: [{
                selector: "ngx-mat-timepicker-period",
                template: "<div class=\"timepicker-period\">\n    <button class=\"timepicker-dial__item timepicker-period__btn\"\n            [ngClass]=\"{'active': selectedPeriod === timePeriod.AM}\"\n            (click)=\"changePeriod(timePeriod.AM)\"\n            type=\"button\">{{meridiems[0]}}</button>\n    <button class=\"timepicker-dial__item timepicker-period__btn\"\n            [ngClass]=\"{'active': selectedPeriod === timePeriod.PM}\"\n            (click)=\"changePeriod(timePeriod.PM)\"\n            type=\"button\">{{meridiems[1]}}</button>\n    <div class=\"timepicker-period__warning\"\n         [@scaleInOut]\n         (@scaleInOut.done)=\"animationDone()\"\n         *ngIf=\"!isPeriodAvailable\">\n        <p>Current time would be invalid in this period.</p>\n    </div>\n</div>\n",
                animations: [
                    trigger("scaleInOut", [
                        transition(":enter", [
                            style({ transform: "scale(0)" }),
                            animate(".2s", style({ transform: "scale(1)" })),
                            sequence([
                                animate("3s", style({ opacity: 1 })),
                                animate(".3s", style({ opacity: 0 }))
                            ])
                        ])
                    ])
                ],
                styles: [".timepicker-period{display:flex;flex-direction:column;position:relative}.timepicker-period__btn{opacity:.5;padding:1px 3px;border:0;background-color:transparent;font-size:18px;font-weight:500;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;outline:0;border-radius:3px;transition:background-color .5s;color:inherit}.timepicker-period__btn.active{opacity:1}.timepicker-period__btn:focus{background-color:rgba(0,0,0,.07)}.timepicker-period__warning{padding:5px 10px;border-radius:3px;background-color:rgba(0,0,0,.55);position:absolute;width:200px;left:-20px;top:40px}.timepicker-period__warning>p{margin:0;font-size:12px}"]
            }]
    }], function () { return []; }, { periodChanged: [{
            type: Output
        }], activeTimeUnit: [{
            type: Input
        }], format: [{
            type: Input
        }], hours: [{
            type: Input
        }], maxTime: [{
            type: Input
        }], meridiems: [{
            type: Input
        }], minTime: [{
            type: Input
        }], minutes: [{
            type: Input
        }], selectedHour: [{
            type: Input
        }], selectedPeriod: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * Generated from: lib/pipes/ngx-mat-timepicker-time-formatter.pipe.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxMatTimepickerTimeFormatterPipe {
    /**
     * @param {?} time
     * @param {?} timeUnit
     * @return {?}
     */
    transform(time, timeUnit) {
        if (time == null || time === '') {
            return time;
        }
        switch (timeUnit) {
            case NgxMatTimepickerUnits.HOUR:
                return DateTime.fromObject({ hour: +time }).toFormat("HH");
            case NgxMatTimepickerUnits.MINUTE:
                return DateTime.fromObject({ minute: +time }).toFormat("mm");
            default:
                throw new Error("no such time unit");
        }
    }
}
NgxMatTimepickerTimeFormatterPipe.ɵfac = function NgxMatTimepickerTimeFormatterPipe_Factory(t) { return new (t || NgxMatTimepickerTimeFormatterPipe)(); };
NgxMatTimepickerTimeFormatterPipe.ɵpipe = /*@__PURE__*/ ɵngcc0.ɵɵdefinePipe({ name: "timeFormatter", type: NgxMatTimepickerTimeFormatterPipe, pure: true });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxMatTimepickerTimeFormatterPipe, [{
        type: Pipe,
        args: [{
                name: "timeFormatter"
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * Generated from: lib/pipes/ngx-mat-timepicker-minutes-formatter.pipe.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxMatTimepickerMinutesFormatterPipe {
    /**
     * @param {?} minute
     * @param {?=} gap
     * @return {?}
     */
    transform(minute, gap = 5) {
        if (!minute) {
            return minute;
        }
        return minute % gap === 0 ? minute : '';
    }
}
NgxMatTimepickerMinutesFormatterPipe.ɵfac = function NgxMatTimepickerMinutesFormatterPipe_Factory(t) { return new (t || NgxMatTimepickerMinutesFormatterPipe)(); };
NgxMatTimepickerMinutesFormatterPipe.ɵpipe = /*@__PURE__*/ ɵngcc0.ɵɵdefinePipe({ name: "minutesFormatter", type: NgxMatTimepickerMinutesFormatterPipe, pure: true });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxMatTimepickerMinutesFormatterPipe, [{
        type: Pipe,
        args: [{
                name: 'minutesFormatter'
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/ngx-mat-timepicker-autofocus.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxMatTimepickerAutofocusDirective {
    /**
     * @param {?} _element
     * @param {?} document
     */
    constructor(_element, document) {
        this._element = _element;
        this.document = document;
        this._activeElement = this.document.activeElement;
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        if (this.isFocusActive) {
            // To avoid ExpressionChangedAfterItHasBeenCheckedError;
            setTimeout((/**
             * @return {?}
             */
            () => this._element.nativeElement.focus({ preventScroll: true })));
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        // To avoid ExpressionChangedAfterItHasBeenCheckedError;
        setTimeout((/**
         * @return {?}
         */
        () => this._activeElement.focus({ preventScroll: true })));
    }
}
NgxMatTimepickerAutofocusDirective.ɵfac = function NgxMatTimepickerAutofocusDirective_Factory(t) { return new (t || NgxMatTimepickerAutofocusDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DOCUMENT, 8)); };
NgxMatTimepickerAutofocusDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NgxMatTimepickerAutofocusDirective, selectors: [["", "ngxMatTimepickerAutofocus", ""]], inputs: { isFocusActive: ["ngxMatTimepickerAutofocus", "isFocusActive"] }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
/** @nocollapse */
NgxMatTimepickerAutofocusDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] }
];
NgxMatTimepickerAutofocusDirective.propDecorators = {
    isFocusActive: [{ type: Input, args: ["ngxMatTimepickerAutofocus",] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxMatTimepickerAutofocusDirective, [{
        type: Directive,
        args: [{
                selector: "[ngxMatTimepickerAutofocus]"
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [DOCUMENT]
            }] }]; }, { isFocusActive: [{
            type: Input,
            args: ["ngxMatTimepickerAutofocus"]
        }] }); })();

/**
 * @fileoverview added by tsickle
 * Generated from: lib/components/ngx-mat-timepicker-field/ngx-mat-timepicker-control/ngx-mat-timepicker-control.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} currentTime
 * @param {?} nextTime
 * @return {?}
 */
function concatTime(currentTime, nextTime) {
    /** @type {?} */
    const isNumber = /\d/.test(nextTime);
    if (isNumber) {
        /** @type {?} */
        const time = currentTime + nextTime;
        return +time;
    }
}
class NgxMatTimepickerControlComponent {
    /**
     * @param {?} _timeParser
     */
    constructor(_timeParser) {
        this._timeParser = _timeParser;
        this.id = NgxMatTimepickerControlComponent.nextId++;
        this.timeChanged = new EventEmitter();
        this._color = "primary";
        this._floatLabel = "never";
    }
    /**
     * @param {?} newValue
     * @return {?}
     */
    set color(newValue) {
        this._color = newValue;
    }
    /**
     * @return {?}
     */
    get color() {
        return this._color;
    }
    /**
     * @param {?} newValue
     * @return {?}
     */
    set floatLabel(newValue) {
        this._floatLabel = newValue;
    }
    /**
     * @return {?}
     */
    get floatLabel() {
        return this._floatLabel;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    changeTime(event) {
        event.stopPropagation();
        /** @type {?} */
        const char = String.fromCharCode(event.keyCode);
        /** @type {?} */
        const time = concatTime(String(this.time), char);
        this._changeTimeIfValid(time);
    }
    /**
     * @return {?}
     */
    decrease() {
        if (!this.disabled) {
            /** @type {?} */
            let previousTime = +this.time - 1;
            if (previousTime < this.min) {
                previousTime = this.max;
            }
            if (this._isSelectedTimeDisabled(previousTime)) {
                previousTime = this._getAvailableTime(previousTime, this._getPrevAvailableTime.bind(this));
            }
            if (previousTime !== this.time) {
                this.timeChanged.emit(previousTime);
            }
        }
    }
    /**
     * @return {?}
     */
    increase() {
        if (!this.disabled) {
            /** @type {?} */
            let nextTime = +this.time + 1;
            if (nextTime > this.max) {
                nextTime = this.min;
            }
            if (this._isSelectedTimeDisabled(nextTime)) {
                nextTime = this._getAvailableTime(nextTime, this._getNextAvailableTime.bind(this));
            }
            if (nextTime !== this.time) {
                this.timeChanged.emit(nextTime);
            }
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.timeList && this.time != null) {
            if (this._isSelectedTimeDisabled(this.time)) {
                this._setAvailableTime();
            }
        }
    }
    /**
     * @return {?}
     */
    onBlur() {
        this.isFocused = false;
        if (this._previousTime !== this.time) {
            this._changeTimeIfValid(+this.time);
        }
    }
    /**
     * @return {?}
     */
    onFocus() {
        this.isFocused = true;
        this._previousTime = this.time;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onKeydown(event) {
        event.stopPropagation();
        if (!NgxMatTimepickerUtils.isDigit(event)) {
            event.preventDefault();
        }
        switch (event.key) {
            case "ArrowUp":
                this.increase();
                break;
            case "ArrowDown":
                this.decrease();
                break;
        }
        if (this.preventTyping && event.key !== "Tab") {
            event.preventDefault();
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    onModelChange(value) {
        this.time = +this._timeParser.transform(value, this.timeUnit);
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    _changeTimeIfValid(value) {
        if (!isNaN(value)) {
            this.time = value;
            if (this.time > this.max) {
                /** @type {?} */
                const timeString = String(value);
                this.time = +timeString[timeString.length - 1];
            }
            if (this.time < this.min) {
                this.time = this.min;
            }
            this.timeChanged.emit(this.time);
        }
    }
    /**
     * @private
     * @param {?} currentTime
     * @param {?} fn
     * @return {?}
     */
    _getAvailableTime(currentTime, fn) {
        /** @type {?} */
        const currentTimeIndex = this.timeList.findIndex((/**
         * @param {?} time
         * @return {?}
         */
        time => time.time === currentTime));
        /** @type {?} */
        const availableTime = fn(currentTimeIndex);
        return availableTime != null ? availableTime : this.time;
    }
    /**
     * @private
     * @param {?} index
     * @return {?}
     */
    _getNextAvailableTime(index) {
        /** @type {?} */
        const timeCollection = this.timeList;
        /** @type {?} */
        const maxValue = timeCollection.length;
        for (let i = index + 1; i < maxValue; i++) {
            /** @type {?} */
            const time = timeCollection[i];
            if (!time.disabled) {
                return time.time;
            }
        }
    }
    /**
     * @private
     * @param {?} index
     * @return {?}
     */
    _getPrevAvailableTime(index) {
        for (let i = index; i >= 0; i--) {
            /** @type {?} */
            const time = this.timeList[i];
            if (!time.disabled) {
                return time.time;
            }
        }
    }
    /**
     * @private
     * @param {?} time
     * @return {?}
     */
    _isSelectedTimeDisabled(time) {
        return this.timeList.find((/**
         * @param {?} faceTime
         * @return {?}
         */
        (faceTime) => faceTime.time === time)).disabled;
    }
    /**
     * @private
     * @return {?}
     */
    _setAvailableTime() {
        this.time = this.timeList.find((/**
         * @param {?} t
         * @return {?}
         */
        t => !t.disabled)).time;
        this.timeChanged.emit(this.time);
    }
}
NgxMatTimepickerControlComponent.ɵfac = function NgxMatTimepickerControlComponent_Factory(t) { return new (t || NgxMatTimepickerControlComponent)(ɵngcc0.ɵɵdirectiveInject(NgxMatTimepickerParserPipe)); };
NgxMatTimepickerControlComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NgxMatTimepickerControlComponent, selectors: [["ngx-mat-timepicker-time-control"]], inputs: { color: "color", floatLabel: "floatLabel", time: "time", disabled: "disabled", max: "max", min: "min", placeholder: "placeholder", preventTyping: "preventTyping", timeList: "timeList", timeUnit: "timeUnit" }, outputs: { timeChanged: "timeChanged" }, features: [ɵngcc0.ɵɵProvidersFeature([NgxMatTimepickerParserPipe]), ɵngcc0.ɵɵNgOnChangesFeature], decls: 13, vars: 17, consts: [[1, "ngx-mat-timepicker-control", 3, "color", "floatLabel", "ngClass"], ["matInput", "", "maxlength", "2", 3, "id", "name", "ngModel", "placeholder", "disabled", "ngModelChange", "keydown", "keypress", "focus", "blur"], ["matSuffix", "", 1, "arrows-wrap"], ["role", "button", 1, "arrow", 3, "click"], ["xmlns", "http://www.w3.org/2000/svg", "height", "18", "viewBox", "0 0 24 24", "width", "18"], ["d", "M0 0h24v24H0z", "fill", "none"], ["d", "M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"], ["d", "M0 0h24v24H0V0z", "fill", "none"], ["d", "M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z"]], template: function NgxMatTimepickerControlComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "mat-form-field", 0);
        ɵngcc0.ɵɵelementStart(1, "input", 1);
        ɵngcc0.ɵɵlistener("ngModelChange", function NgxMatTimepickerControlComponent_Template_input_ngModelChange_1_listener($event) { return ctx.onModelChange($event); })("keydown", function NgxMatTimepickerControlComponent_Template_input_keydown_1_listener($event) { return ctx.onKeydown($event); })("keypress", function NgxMatTimepickerControlComponent_Template_input_keypress_1_listener($event) { return ctx.changeTime($event); })("focus", function NgxMatTimepickerControlComponent_Template_input_focus_1_listener() { return ctx.onFocus(); })("blur", function NgxMatTimepickerControlComponent_Template_input_blur_1_listener() { return ctx.onBlur(); });
        ɵngcc0.ɵɵpipe(2, "timeLocalizer");
        ɵngcc0.ɵɵpipe(3, "ngxMatTimepickerParser");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "div", 2);
        ɵngcc0.ɵɵelementStart(5, "span", 3);
        ɵngcc0.ɵɵlistener("click", function NgxMatTimepickerControlComponent_Template_span_click_5_listener() { return ctx.increase(); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(6, "svg", 4);
        ɵngcc0.ɵɵelement(7, "path", 5);
        ɵngcc0.ɵɵelement(8, "path", 6);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵnamespaceHTML();
        ɵngcc0.ɵɵelementStart(9, "span", 3);
        ɵngcc0.ɵɵlistener("click", function NgxMatTimepickerControlComponent_Template_span_click_9_listener() { return ctx.decrease(); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(10, "svg", 4);
        ɵngcc0.ɵɵelement(11, "path", 7);
        ɵngcc0.ɵɵelement(12, "path", 8);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("color", ctx.color)("floatLabel", ctx.floatLabel)("ngClass", ɵngcc0.ɵɵpureFunction1(15, _c10, ctx.isFocused));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵpropertyInterpolate1("id", "ngx_mat_timepicker_field_", ctx.id, "");
        ɵngcc0.ɵɵpropertyInterpolate1("name", "ngx_mat_timepicker_field_", ctx.id, "");
        ɵngcc0.ɵɵproperty("ngModel", ɵngcc0.ɵɵpipeBind3(2, 8, ɵngcc0.ɵɵpipeBind2(3, 12, ctx.time, ctx.timeUnit), ctx.timeUnit, true))("placeholder", ctx.placeholder)("disabled", ctx.disabled);
    } }, directives: function () { return [ɵngcc2.MatFormField, ɵngcc1.NgClass, ɵngcc12.MatInput, ɵngcc4.DefaultValueAccessor, ɵngcc4.MaxLengthValidator, ɵngcc4.NgControlStatus, ɵngcc4.NgModel, ɵngcc2.MatSuffix]; }, pipes: function () { return [NgxMatTimepickerTimeLocalizerPipe, NgxMatTimepickerParserPipe]; }, styles: [".ngx-mat-timepicker-control[_ngcontent-%COMP%]{width:60px;min-width:60px}.ngx-mat-timepicker-control[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{text-align:center}.ngx-mat-timepicker-control[_ngcontent-%COMP%]   .arrows-wrap[_ngcontent-%COMP%]{position:absolute;right:0;bottom:-8px;display:flex;flex-direction:column}.ngx-mat-timepicker-control[_ngcontent-%COMP%]   .arrows-wrap[_ngcontent-%COMP%] > .arrow[_ngcontent-%COMP%]{text-align:center;opacity:.5;height:15px;cursor:pointer;transition:opacity .2s;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.ngx-mat-timepicker-control[_ngcontent-%COMP%]   .arrows-wrap[_ngcontent-%COMP%] > .arrow[_ngcontent-%COMP%]:hover{opacity:1}"], changeDetection: 0 });
NgxMatTimepickerControlComponent.nextId = 0;
/** @nocollapse */
NgxMatTimepickerControlComponent.ctorParameters = () => [
    { type: NgxMatTimepickerParserPipe }
];
NgxMatTimepickerControlComponent.propDecorators = {
    color: [{ type: Input }],
    disabled: [{ type: Input }],
    floatLabel: [{ type: Input }],
    max: [{ type: Input }],
    min: [{ type: Input }],
    placeholder: [{ type: Input }],
    preventTyping: [{ type: Input }],
    time: [{ type: Input }],
    timeChanged: [{ type: Output }],
    timeList: [{ type: Input }],
    timeUnit: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxMatTimepickerControlComponent, [{
        type: Component,
        args: [{
                selector: "ngx-mat-timepicker-time-control",
                template: "<mat-form-field [color]=\"color\"\n                [floatLabel]=\"floatLabel\"\n                [ngClass]=\"{'active': isFocused}\"\n                class=\"ngx-mat-timepicker-control\">\n    <input id=\"ngx_mat_timepicker_field_{{id}}\"\n           name=\"ngx_mat_timepicker_field_{{id}}\"\n           matInput\n           maxlength=\"2\"\n           [ngModel]=\"time | ngxMatTimepickerParser: timeUnit | timeLocalizer: timeUnit : true\"\n           (ngModelChange)=\"onModelChange($event)\"\n           [placeholder]=\"placeholder\"\n           [disabled]=\"disabled\"\n           (keydown)=\"onKeydown($event)\"\n           (keypress)=\"changeTime($event)\"\n           (focus)=\"onFocus()\"\n           (blur)=\"onBlur()\" />\n    <div class=\"arrows-wrap\"\n         matSuffix>\n        <span class=\"arrow\"\n              role=\"button\"\n              (click)=\"increase()\">\n            <svg xmlns=\"http://www.w3.org/2000/svg\"\n                 height=\"18\"\n                 viewBox=\"0 0 24 24\"\n                 width=\"18\">\n                <path d=\"M0 0h24v24H0z\"\n                      fill=\"none\" />\n                <path d=\"M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z\" />\n            </svg>\n        </span>\n        <span class=\"arrow\"\n              role=\"button\"\n              (click)=\"decrease()\">\n            <svg xmlns=\"http://www.w3.org/2000/svg\"\n                 height=\"18\"\n                 viewBox=\"0 0 24 24\"\n                 width=\"18\">\n                <path d=\"M0 0h24v24H0V0z\"\n                      fill=\"none\" />\n                <path d=\"M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z\" />\n            </svg>\n        </span>\n    </div>\n</mat-form-field>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [NgxMatTimepickerParserPipe],
                styles: [".ngx-mat-timepicker-control{width:60px;min-width:60px}.ngx-mat-timepicker-control input{text-align:center}.ngx-mat-timepicker-control .arrows-wrap{position:absolute;right:0;bottom:-8px;display:flex;flex-direction:column}.ngx-mat-timepicker-control .arrows-wrap>.arrow{text-align:center;opacity:.5;height:15px;cursor:pointer;transition:opacity .2s;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.ngx-mat-timepicker-control .arrows-wrap>.arrow:hover{opacity:1}"]
            }]
    }], function () { return [{ type: NgxMatTimepickerParserPipe }]; }, { timeChanged: [{
            type: Output
        }], color: [{
            type: Input
        }], floatLabel: [{
            type: Input
        }], time: [{
            type: Input
        }], disabled: [{
            type: Input
        }], max: [{
            type: Input
        }], min: [{
            type: Input
        }], placeholder: [{
            type: Input
        }], preventTyping: [{
            type: Input
        }], timeList: [{
            type: Input
        }], timeUnit: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * Generated from: lib/pipes/ngx-mat-timepicker-time-localizer.pipe.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxMatTimepickerTimeLocalizerPipe {
    /**
     * @param {?} _locale
     */
    constructor(_locale) {
        this._locale = _locale;
    }
    /**
     * @param {?} time
     * @param {?} timeUnit
     * @param {?=} isKeyboardEnabled
     * @return {?}
     */
    transform(time, timeUnit, isKeyboardEnabled = false) {
        if (time == null || time === "") {
            return "";
        }
        switch (timeUnit) {
            case NgxMatTimepickerUnits.HOUR: {
                /** @type {?} */
                const format = (time === 0 || isKeyboardEnabled) ? "HH" : "H";
                return this._formatTime(NgxMatTimepickerMeasure.hour, time, format);
            }
            case NgxMatTimepickerUnits.MINUTE:
                return this._formatTime(NgxMatTimepickerMeasure.minute, time, "mm");
            default:
                throw new Error(`There is no Time Unit with type ${timeUnit}`);
        }
    }
    /**
     * @private
     * @param {?} timeMeasure
     * @param {?} time
     * @param {?} format
     * @return {?}
     */
    _formatTime(timeMeasure, time, format) {
        try {
            return DateTime.fromObject({ [timeMeasure]: +time }).setLocale(this._locale).toFormat(format);
        }
        catch (_a) {
            throw new Error(`Cannot format provided time - ${time} to locale - ${this._locale}`);
        }
    }
}
NgxMatTimepickerTimeLocalizerPipe.ɵfac = function NgxMatTimepickerTimeLocalizerPipe_Factory(t) { return new (t || NgxMatTimepickerTimeLocalizerPipe)(ɵngcc0.ɵɵdirectiveInject(NGX_MAT_TIMEPICKER_LOCALE, 16)); };
NgxMatTimepickerTimeLocalizerPipe.ɵpipe = /*@__PURE__*/ ɵngcc0.ɵɵdefinePipe({ name: "timeLocalizer", type: NgxMatTimepickerTimeLocalizerPipe, pure: true });
/** @nocollapse */
NgxMatTimepickerTimeLocalizerPipe.ctorParameters = () => [
    { type: String, decorators: [{ type: Inject, args: [NGX_MAT_TIMEPICKER_LOCALE,] }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxMatTimepickerTimeLocalizerPipe, [{
        type: Pipe,
        args: [{
                name: "timeLocalizer"
            }]
    }], function () { return [{ type: String, decorators: [{
                type: Inject,
                args: [NGX_MAT_TIMEPICKER_LOCALE]
            }] }]; }, null); })();

/**
 * @fileoverview added by tsickle
 * Generated from: lib/pipes/ngx-mat-timepicker-active-hour.pipe.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxMatTimepickerActiveHourPipe {
    /**
     * @param {?} hour
     * @param {?} currentHour
     * @param {?} isClockFaceDisabled
     * @return {?}
     */
    transform(hour, currentHour, isClockFaceDisabled) {
        if (hour == null || isClockFaceDisabled) {
            return false;
        }
        return hour === currentHour;
    }
}
NgxMatTimepickerActiveHourPipe.ɵfac = function NgxMatTimepickerActiveHourPipe_Factory(t) { return new (t || NgxMatTimepickerActiveHourPipe)(); };
NgxMatTimepickerActiveHourPipe.ɵpipe = /*@__PURE__*/ ɵngcc0.ɵɵdefinePipe({ name: "activeHour", type: NgxMatTimepickerActiveHourPipe, pure: true });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxMatTimepickerActiveHourPipe, [{
        type: Pipe,
        args: [{
                name: 'activeHour'
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * Generated from: lib/pipes/ngx-mat-timepicker-active-minute.pipe.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxMatTimepickerActiveMinutePipe {
    /**
     * @param {?} minute
     * @param {?} currentMinute
     * @param {?} gap
     * @param {?} isClockFaceDisabled
     * @return {?}
     */
    transform(minute, currentMinute, gap, isClockFaceDisabled) {
        if (minute == null || isClockFaceDisabled) {
            return false;
        }
        /** @type {?} */
        const defaultGap = 5;
        return ((currentMinute === minute) && (minute % (gap || defaultGap) === 0));
    }
}
NgxMatTimepickerActiveMinutePipe.ɵfac = function NgxMatTimepickerActiveMinutePipe_Factory(t) { return new (t || NgxMatTimepickerActiveMinutePipe)(); };
NgxMatTimepickerActiveMinutePipe.ɵpipe = /*@__PURE__*/ ɵngcc0.ɵɵdefinePipe({ name: "activeMinute", type: NgxMatTimepickerActiveMinutePipe, pure: true });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxMatTimepickerActiveMinutePipe, [{
        type: Pipe,
        args: [{
                name: 'activeMinute'
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * Generated from: lib/components/ngx-mat-timepicker-content/ngx-mat-timepicker-content.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxMatTimepickerContentComponent {
}
NgxMatTimepickerContentComponent.ɵfac = function NgxMatTimepickerContentComponent_Factory(t) { return new (t || NgxMatTimepickerContentComponent)(); };
NgxMatTimepickerContentComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NgxMatTimepickerContentComponent, selectors: [["ngx-mat-timepicker-content"]], inputs: { appendToInput: "appendToInput", inputElement: "inputElement" }, ngContentSelectors: _c11, decls: 5, vars: 2, consts: [[4, "ngIf", "ngIfElse"], ["timepickerModal", ""], ["timepickerOutlet", ""], [4, "ngTemplateOutlet"]], template: function NgxMatTimepickerContentComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, NgxMatTimepickerContentComponent_div_0_Template, 2, 1, "div", 0);
        ɵngcc0.ɵɵtemplate(1, NgxMatTimepickerContentComponent_ng_template_1_Template, 1, 1, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(3, NgxMatTimepickerContentComponent_ng_template_3_Template, 1, 0, "ng-template", null, 2, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        const _r1 = ɵngcc0.ɵɵreference(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.appendToInput)("ngIfElse", _r1);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet], encapsulation: 2 });
NgxMatTimepickerContentComponent.propDecorators = {
    appendToInput: [{ type: Input }],
    inputElement: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxMatTimepickerContentComponent, [{
        type: Component,
        args: [{
                selector: "ngx-mat-timepicker-content",
                template: "<div *ngIf=\"appendToInput;else timepickerModal\">\n\t<ng-container *ngTemplateOutlet=\"timepickerOutlet\"></ng-container>\n</div>\n<ng-template #timepickerModal>\n\t<ng-container *ngTemplateOutlet=\"timepickerOutlet\"></ng-container>\n</ng-template>\n<ng-template #timepickerOutlet>\n\t<ng-content></ng-content>\n</ng-template>\n"
            }]
    }], null, { appendToInput: [{
            type: Input
        }], inputElement: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * Generated from: lib/components/ngx-mat-timepicker-standalone/ngx-mat-timepicker-standalone.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxMatTimepickerStandaloneComponent extends NgxMatTimepickerBaseDirective {
    /**
     * @param {?} data
     * @param {?} timepickerSrv
     * @param {?} eventSrv
     * @param {?} locale
     */
    constructor(data, timepickerSrv, eventSrv, locale) {
        super(timepickerSrv, eventSrv, locale, data);
        this.data = data;
    }
    /**
     * @return {?}
     */
    close() {
        this.data.timepickerBaseRef.close();
    }
}
NgxMatTimepickerStandaloneComponent.ɵfac = function NgxMatTimepickerStandaloneComponent_Factory(t) { return new (t || NgxMatTimepickerStandaloneComponent)(ɵngcc0.ɵɵdirectiveInject(NGX_MAT_TIMEPICKER_CONFIG), ɵngcc0.ɵɵdirectiveInject(NgxMatTimepickerService), ɵngcc0.ɵɵdirectiveInject(NgxMatTimepickerEventService), ɵngcc0.ɵɵdirectiveInject(NGX_MAT_TIMEPICKER_LOCALE)); };
NgxMatTimepickerStandaloneComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NgxMatTimepickerStandaloneComponent, selectors: [["ngx-mat-timepicker-standalone"]], hostVars: 2, hostBindings: function NgxMatTimepickerStandaloneComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("mat-app-background", true);
    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 21, vars: 28, consts: [["cancelBtnDefault", ""], ["confirmBtnDefault", ""], ["cdkTrapFocus", "", "cdkTrapFocusAutoCapture", ""], [3, "appendToInput", "inputElement", "ngxMatTimepickerTheme"], [1, "timepicker", 3, "ngClass"], [1, "timepicker-header", 3, "color"], [3, "color", "format", "hour", "minute", "period", "activeTimeUnit", "minTime", "maxTime", "isEditable", "editableHintTmpl", "minutesGap", "hoursOnly", "periodChanged", "timeUnitChanged", "hourChanged", "minuteChanged"], [1, "timepicker__main-content"], [1, "timepicker__body", 3, "ngSwitch"], [4, "ngSwitchCase"], [3, "color", "selectedMinute", "selectedHour", "minTime", "maxTime", "format", "period", "minutesGap", "minuteChange", 4, "ngSwitchCase"], [1, "ngx-mat-timepicker-standalone-actions"], [3, "click"], [4, "ngTemplateOutlet"], ["mat-button", "", 3, "color"], [3, "color", "selectedHour", "minTime", "maxTime", "format", "hourChange", "hourSelected", 4, "ngIf", "ngIfElse"], ["ampmHours", ""], [3, "color", "selectedHour", "minTime", "maxTime", "format", "hourChange", "hourSelected"], [3, "color", "selectedHour", "period", "minTime", "maxTime", "hourChange", "hourSelected"], [3, "color", "selectedMinute", "selectedHour", "minTime", "maxTime", "format", "period", "minutesGap", "minuteChange"]], template: function NgxMatTimepickerStandaloneComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NgxMatTimepickerStandaloneComponent_ng_template_0_Template, 2, 1, "ng-template", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(2, NgxMatTimepickerStandaloneComponent_ng_template_2_Template, 2, 1, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵelementStart(4, "div", 2);
        ɵngcc0.ɵɵelementStart(5, "ngx-mat-timepicker-content", 3);
        ɵngcc0.ɵɵelementStart(6, "div", 4);
        ɵngcc0.ɵɵelementStart(7, "mat-toolbar", 5);
        ɵngcc0.ɵɵelementStart(8, "ngx-mat-timepicker-dial", 6);
        ɵngcc0.ɵɵlistener("periodChanged", function NgxMatTimepickerStandaloneComponent_Template_ngx_mat_timepicker_dial_periodChanged_8_listener($event) { return ctx.changePeriod($event); })("timeUnitChanged", function NgxMatTimepickerStandaloneComponent_Template_ngx_mat_timepicker_dial_timeUnitChanged_8_listener($event) { return ctx.changeTimeUnit($event); })("hourChanged", function NgxMatTimepickerStandaloneComponent_Template_ngx_mat_timepicker_dial_hourChanged_8_listener($event) { return ctx.onHourChange($event); })("minuteChanged", function NgxMatTimepickerStandaloneComponent_Template_ngx_mat_timepicker_dial_minuteChanged_8_listener($event) { return ctx.onMinuteChange($event); });
        ɵngcc0.ɵɵpipe(9, "async");
        ɵngcc0.ɵɵpipe(10, "async");
        ɵngcc0.ɵɵpipe(11, "async");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(12, "div", 7);
        ɵngcc0.ɵɵelementStart(13, "div", 8);
        ɵngcc0.ɵɵtemplate(14, NgxMatTimepickerStandaloneComponent_div_14_Template, 4, 2, "div", 9);
        ɵngcc0.ɵɵtemplate(15, NgxMatTimepickerStandaloneComponent_ngx_mat_timepicker_minutes_face_15_Template, 4, 14, "ngx-mat-timepicker-minutes-face", 10);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(16, "div", 11);
        ɵngcc0.ɵɵelementStart(17, "div", 12);
        ɵngcc0.ɵɵlistener("click", function NgxMatTimepickerStandaloneComponent_Template_div_click_17_listener() { return ctx.close(); });
        ɵngcc0.ɵɵtemplate(18, NgxMatTimepickerStandaloneComponent_ng_container_18_Template, 1, 0, "ng-container", 13);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(19, "div", 12);
        ɵngcc0.ɵɵlistener("click", function NgxMatTimepickerStandaloneComponent_Template_div_click_19_listener() { return ctx.setTime(); });
        ɵngcc0.ɵɵtemplate(20, NgxMatTimepickerStandaloneComponent_ng_container_20_Template, 1, 0, "ng-container", 13);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        const _r0 = ɵngcc0.ɵɵreference(1);
        const _r2 = ɵngcc0.ɵɵreference(3);
        let tmp_7_0;
        let tmp_8_0;
        ɵngcc0.ɵɵadvance(5);
        ɵngcc0.ɵɵproperty("appendToInput", ctx.data.appendToInput)("inputElement", ctx.data.inputElement)("ngxMatTimepickerTheme", ctx.data.theme);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngClass", ctx.data.timepickerClass);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("color", ctx.color);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("color", ctx.color)("format", ctx.data.format)("hour", (tmp_7_0 = ɵngcc0.ɵɵpipeBind1(9, 22, ctx.selectedHour)) == null ? null : tmp_7_0.time)("minute", (tmp_8_0 = ɵngcc0.ɵɵpipeBind1(10, 24, ctx.selectedMinute)) == null ? null : tmp_8_0.time)("period", ɵngcc0.ɵɵpipeBind1(11, 26, ctx.selectedPeriod))("activeTimeUnit", ctx.activeTimeUnit)("minTime", ctx.data.minTime)("maxTime", ctx.data.maxTime)("isEditable", ctx.data.enableKeyboardInput)("editableHintTmpl", ctx.data.editableHintTmpl)("minutesGap", ctx.data.minutesGap)("hoursOnly", ctx.data.hoursOnly);
        ɵngcc0.ɵɵadvance(5);
        ɵngcc0.ɵɵproperty("ngSwitch", ctx.activeTimeUnit);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", ctx.timeUnit.HOUR);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", ctx.timeUnit.MINUTE);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.data.cancelBtnTmpl ? ctx.data.cancelBtnTmpl : _r0);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.data.confirmBtnTmpl ? ctx.data.confirmBtnTmpl : _r2);
    } }, directives: [ɵngcc13.CdkTrapFocus, NgxMatTimepickerContentComponent, NgxMatTimepickerThemeDirective, ɵngcc1.NgClass, ɵngcc8.MatToolbar, NgxMatTimepickerDialComponent, ɵngcc1.NgSwitch, ɵngcc1.NgSwitchCase, ɵngcc1.NgTemplateOutlet, ɵngcc9.MatButton, ɵngcc1.NgIf, NgxMatTimepicker24HoursFaceComponent, NgxMatTimepicker12HoursFaceComponent, NgxMatTimepickerMinutesFaceComponent], pipes: [ɵngcc1.AsyncPipe], styles: ["ngx-mat-timepicker-standalone{display:block;border-radius:4px;box-shadow:0 0 5px 2px rgba(0,0,0,.25);overflow:hidden}ngx-mat-timepicker-standalone ngx-mat-timepicker-content{display:block}ngx-mat-timepicker-standalone ngx-mat-timepicker-content mat-toolbar.timepicker-header{display:flex;justify-content:center;align-items:center}ngx-mat-timepicker-standalone ngx-mat-timepicker-content .clock-face{margin:16px}ngx-mat-timepicker-standalone .ngx-mat-timepicker-standalone-actions{display:flex;flex-direction:row;justify-content:flex-end;padding:0 16px 16px}"], encapsulation: 2 });
/** @nocollapse */
NgxMatTimepickerStandaloneComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [NGX_MAT_TIMEPICKER_CONFIG,] }] },
    { type: NgxMatTimepickerService },
    { type: NgxMatTimepickerEventService },
    { type: String, decorators: [{ type: Inject, args: [NGX_MAT_TIMEPICKER_LOCALE,] }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxMatTimepickerStandaloneComponent, [{
        type: Component,
        args: [{
                selector: "ngx-mat-timepicker-standalone",
                template: "<ng-template #cancelBtnDefault>\n\t<button mat-button\n\t\t\t[color]=\"color\">CANCEL\n\t</button>\n</ng-template>\n<ng-template #confirmBtnDefault>\n\t<button mat-button\n\t\t\t[color]=\"color\">OK\n\t</button>\n</ng-template>\n<div cdkTrapFocus\n\t cdkTrapFocusAutoCapture>\n\t<ngx-mat-timepicker-content [appendToInput]=\"data.appendToInput\"\n\t\t\t\t\t\t\t\t[inputElement]=\"data.inputElement\"\n\t\t\t\t\t\t\t\t[ngxMatTimepickerTheme]=\"data.theme\">\n\t\t<div class=\"timepicker\"\n\t\t\t [ngClass]=\"data.timepickerClass\">\n\t\t\t<mat-toolbar [color]=\"color\"\n\t\t\t\t\t\t class=\"timepicker-header\">\n\t\t\t\t<ngx-mat-timepicker-dial [color]=\"color\"\n\t\t\t\t\t\t\t\t\t\t [format]=\"data.format\"\n\t\t\t\t\t\t\t\t\t\t [hour]=\"(selectedHour | async)?.time\"\n\t\t\t\t\t\t\t\t\t\t [minute]=\"(selectedMinute | async)?.time\"\n\t\t\t\t\t\t\t\t\t\t [period]=\"selectedPeriod | async\"\n\t\t\t\t\t\t\t\t\t\t [activeTimeUnit]=\"activeTimeUnit\"\n\t\t\t\t\t\t\t\t\t\t [minTime]=\"data.minTime\"\n\t\t\t\t\t\t\t\t\t\t [maxTime]=\"data.maxTime\"\n\t\t\t\t\t\t\t\t\t\t [isEditable]=\"data.enableKeyboardInput\"\n\t\t\t\t\t\t\t\t\t\t [editableHintTmpl]=\"data.editableHintTmpl\"\n\t\t\t\t\t\t\t\t\t\t [minutesGap]=\"data.minutesGap\"\n\t\t\t\t\t\t\t\t\t\t [hoursOnly]=\"data.hoursOnly\"\n\t\t\t\t\t\t\t\t\t\t (periodChanged)=\"changePeriod($event)\"\n\t\t\t\t\t\t\t\t\t\t (timeUnitChanged)=\"changeTimeUnit($event)\"\n\t\t\t\t\t\t\t\t\t\t (hourChanged)=\"onHourChange($event)\"\n\t\t\t\t\t\t\t\t\t\t (minuteChanged)=\"onMinuteChange($event)\">\n\t\t\t\t</ngx-mat-timepicker-dial>\n\t\t\t</mat-toolbar>\n\t\t\t<div class=\"timepicker__main-content\">\n\t\t\t\t<div class=\"timepicker__body\"\n\t\t\t\t\t [ngSwitch]=\"activeTimeUnit\">\n\t\t\t\t\t<div *ngSwitchCase=\"timeUnit.HOUR\">\n\t\t\t\t\t\t<ngx-mat-timepicker-24-hours-face *ngIf=\"data.format === 24;else ampmHours\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  [color]=\"color\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  (hourChange)=\"onHourChange($event)\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  [selectedHour]=\"selectedHour | async\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  [minTime]=\"data.minTime\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  [maxTime]=\"data.maxTime\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  [format]=\"data.format\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  (hourSelected)=\"onHourSelected($event)\"></ngx-mat-timepicker-24-hours-face>\n\t\t\t\t\t\t<ng-template #ampmHours>\n\t\t\t\t\t\t\t<ngx-mat-timepicker-12-hours-face\n\t\t\t\t\t\t\t\t\t[color]=\"color\"\n\t\t\t\t\t\t\t\t\t(hourChange)=\"onHourChange($event)\"\n\t\t\t\t\t\t\t\t\t[selectedHour]=\"selectedHour | async\"\n\t\t\t\t\t\t\t\t\t[period]=\"selectedPeriod | async\"\n\t\t\t\t\t\t\t\t\t[minTime]=\"data.minTime\"\n\t\t\t\t\t\t\t\t\t[maxTime]=\"data.maxTime\"\n\t\t\t\t\t\t\t\t\t(hourSelected)=\"onHourSelected($event)\"></ngx-mat-timepicker-12-hours-face>\n\t\t\t\t\t\t</ng-template>\n\t\t\t\t\t</div>\n\t\t\t\t\t<ngx-mat-timepicker-minutes-face *ngSwitchCase=\"timeUnit.MINUTE\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t [color]=\"color\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t [selectedMinute]=\"selectedMinute | async\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t [selectedHour]=\"(selectedHour | async)?.time\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t [minTime]=\"data.minTime\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t [maxTime]=\"data.maxTime\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t [format]=\"data.format\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t [period]=\"selectedPeriod | async\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t [minutesGap]=\"data.minutesGap\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t (minuteChange)=\"onMinuteChange($event)\"></ngx-mat-timepicker-minutes-face>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t</ngx-mat-timepicker-content>\n\n\t<div class=\"ngx-mat-timepicker-standalone-actions\">\n\t\t<div (click)=\"close()\">\n\t\t\t<ng-container\n\t\t\t\t\t*ngTemplateOutlet=\"data.cancelBtnTmpl ? data.cancelBtnTmpl : cancelBtnDefault\"></ng-container>\n\t\t</div>\n\t\t<div (click)=\"setTime()\">\n\t\t\t<ng-container\n\t\t\t\t\t*ngTemplateOutlet=\"data.confirmBtnTmpl ? data.confirmBtnTmpl : confirmBtnDefault\"></ng-container>\n\t\t</div>\n\t</div>\n</div>\n",
                // tslint:disable-next-line:no-host-metadata-property
                host: {
                    "[class.mat-app-background]": "true"
                },
                encapsulation: ViewEncapsulation.None,
                styles: ["ngx-mat-timepicker-standalone{display:block;border-radius:4px;box-shadow:0 0 5px 2px rgba(0,0,0,.25);overflow:hidden}ngx-mat-timepicker-standalone ngx-mat-timepicker-content{display:block}ngx-mat-timepicker-standalone ngx-mat-timepicker-content mat-toolbar.timepicker-header{display:flex;justify-content:center;align-items:center}ngx-mat-timepicker-standalone ngx-mat-timepicker-content .clock-face{margin:16px}ngx-mat-timepicker-standalone .ngx-mat-timepicker-standalone-actions{display:flex;flex-direction:row;justify-content:flex-end;padding:0 16px 16px}"]
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [NGX_MAT_TIMEPICKER_CONFIG]
            }] }, { type: NgxMatTimepickerService }, { type: NgxMatTimepickerEventService }, { type: String, decorators: [{
                type: Inject,
                args: [NGX_MAT_TIMEPICKER_LOCALE]
            }] }]; }, null); })();

/**
 * @fileoverview added by tsickle
 * Generated from: lib/ngx-mat-timepicker.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxMatTimepickerModule {
    /**
     * @param {?} locale
     * @return {?}
     */
    static setLocale(locale) {
        return {
            ngModule: NgxMatTimepickerModule,
            providers: [
                { provide: NGX_MAT_TIMEPICKER_LOCALE, useValue: locale },
                { provide: NGX_MAT_TIMEPICKER_CONFIG, useValue: undefined },
            ]
        };
    }
}
NgxMatTimepickerModule.ɵfac = function NgxMatTimepickerModule_Factory(t) { return new (t || NgxMatTimepickerModule)(); };
NgxMatTimepickerModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NgxMatTimepickerModule });
NgxMatTimepickerModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[
            CommonModule,
            A11yModule,
            FormsModule,
            MatButtonModule,
            MatFormFieldModule,
            MatDialogModule,
            MatInputModule,
            MatSelectModule,
            MatToolbarModule,
            MatIconModule,
            OverlayModule,
            PortalModule,
            SmpCoreUtilsModule.forRoot()
        ]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxMatTimepickerModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    A11yModule,
                    FormsModule,
                    MatButtonModule,
                    MatFormFieldModule,
                    MatDialogModule,
                    MatInputModule,
                    MatSelectModule,
                    MatToolbarModule,
                    MatIconModule,
                    OverlayModule,
                    PortalModule,
                    SmpCoreUtilsModule.forRoot()
                ],
                exports: [
                    NgxMatTimepickerComponent,
                    NgxMatTimepickerToggleComponent,
                    NgxMatTimepickerFieldComponent,
                    NgxMatTimepickerDirective,
                    NgxMatTimepickerToggleIconDirective
                ],
                declarations: [
                    // Not really used, but needed to use it as abstract class
                    NgxMatTimepickerBaseDirective,
                    NgxMatTimepickerHoursFaceDirective,
                    //
                    NgxMatTimepickerActiveHourPipe,
                    NgxMatTimepickerActiveMinutePipe,
                    NgxMatTimepickerComponent,
                    NgxMatTimepickerDialComponent,
                    NgxMatTimepickerDialControlComponent,
                    NgxMatTimepickerDialogComponent,
                    NgxMatTimepickerDirective,
                    NgxMatTimepickerFaceComponent,
                    NgxMatTimepickerMinutesFaceComponent,
                    NgxMatTimepickerPeriodComponent,
                    NgxMatTimepickerStandaloneComponent,
                    NgxMatTimepickerToggleComponent,
                    NgxMatTimepicker12HoursFaceComponent,
                    NgxMatTimepicker24HoursFaceComponent,
                    NgxMatTimepickerToggleIconDirective,
                    NgxMatTimepickerAutofocusDirective,
                    NgxMatTimepickerMinutesFormatterPipe,
                    NgxMatTimepickerThemeDirective,
                    NgxMatTimepickerFieldComponent,
                    NgxMatTimepickerControlComponent,
                    NgxMatTimepickerParserPipe,
                    NgxMatTimepickerContentComponent,
                    NgxMatTimepickerTimeFormatterPipe,
                    NgxMatTimepickerTimeLocalizerPipe
                ],
                entryComponents: [
                    NgxMatTimepickerDialogComponent,
                    NgxMatTimepickerStandaloneComponent
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgxMatTimepickerModule, { declarations: function () { return [NgxMatTimepickerBaseDirective, NgxMatTimepickerHoursFaceDirective, NgxMatTimepickerActiveHourPipe, NgxMatTimepickerActiveMinutePipe, NgxMatTimepickerComponent, NgxMatTimepickerDialComponent, NgxMatTimepickerDialControlComponent, NgxMatTimepickerDialogComponent, NgxMatTimepickerDirective, NgxMatTimepickerFaceComponent, NgxMatTimepickerMinutesFaceComponent, NgxMatTimepickerPeriodComponent, NgxMatTimepickerStandaloneComponent, NgxMatTimepickerToggleComponent, NgxMatTimepicker12HoursFaceComponent, NgxMatTimepicker24HoursFaceComponent, NgxMatTimepickerToggleIconDirective, NgxMatTimepickerAutofocusDirective, NgxMatTimepickerMinutesFormatterPipe, NgxMatTimepickerThemeDirective, NgxMatTimepickerFieldComponent, NgxMatTimepickerControlComponent, NgxMatTimepickerParserPipe, NgxMatTimepickerContentComponent, NgxMatTimepickerTimeFormatterPipe, NgxMatTimepickerTimeLocalizerPipe]; }, imports: function () { return [CommonModule,
        A11yModule,
        FormsModule,
        MatButtonModule,
        MatFormFieldModule,
        MatDialogModule,
        MatInputModule,
        MatSelectModule,
        MatToolbarModule,
        MatIconModule,
        OverlayModule,
        PortalModule, ɵngcc11.SmpCoreUtilsModule]; }, exports: function () { return [NgxMatTimepickerComponent, NgxMatTimepickerToggleComponent, NgxMatTimepickerFieldComponent, NgxMatTimepickerDirective, NgxMatTimepickerToggleIconDirective]; } }); })();

export { NgxMatTimepickerDirective, NgxMatTimepickerFieldComponent, NgxMatTimepickerModule, NgxMatTimepickerToggleComponent, NgxMatTimepickerToggleIconDirective, NgxMatTimepickerService as ɵa, NGX_MAT_TIMEPICKER_LOCALE as ɵb, NgxMatTimepickerComponent as ɵc, NGX_MAT_TIMEPICKER_CONFIG as ɵd, NgxMatTimepickerEventService as ɵe, NgxMatTimepickerBaseDirective as ɵf, NgxMatTimepickerHoursFaceDirective as ɵg, NgxMatTimepickerActiveHourPipe as ɵh, NgxMatTimepickerActiveMinutePipe as ɵi, NgxMatTimepickerDialComponent as ɵj, NgxMatTimepickerDialControlComponent as ɵk, NgxMatTimepickerParserPipe as ɵl, NgxMatTimepickerDialogComponent as ɵm, NgxMatTimepickerFaceComponent as ɵn, NgxMatTimepickerMinutesFaceComponent as ɵo, NgxMatTimepickerPeriodComponent as ɵp, NgxMatTimepickerStandaloneComponent as ɵq, NgxMatTimepicker12HoursFaceComponent as ɵr, NgxMatTimepicker24HoursFaceComponent as ɵs, NgxMatTimepickerAutofocusDirective as ɵt, NgxMatTimepickerMinutesFormatterPipe as ɵu, NgxMatTimepickerThemeDirective as ɵv, NgxMatTimepickerControlComponent as ɵw, NgxMatTimepickerContentComponent as ɵx, NgxMatTimepickerTimeFormatterPipe as ɵy, NgxMatTimepickerTimeLocalizerPipe as ɵz };

//# sourceMappingURL=ngx-mat-timepicker.js.map