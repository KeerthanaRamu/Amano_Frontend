import { Injectable, ɵɵdefineInjectable, InjectionToken, EventEmitter, Component, ChangeDetectionStrategy, ViewEncapsulation, Inject, Input, Output, Directive, Optional, HostListener, ViewContainerRef, HostBinding, ContentChild, ElementRef, ViewChild, Pipe, NgModule } from '@angular/core';
import { NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';
import { BehaviorSubject, Subject } from 'rxjs';
import { DateTime, Info } from 'ts-luxon';
import { tap, map, distinctUntilChanged, takeUntil, shareReplay } from 'rxjs/operators';
import { Overlay, CdkOverlayOrigin, OverlayModule } from '@angular/cdk/overlay';
import { MAT_DIALOG_DATA, MatDialogRef, MatDialog, MatDialogModule } from '@angular/material/dialog';
import { SmpDomService, SmpCoreUtilsModule } from 'smp-core-utils';
import { MatFormField, MatFormFieldModule } from '@angular/material/form-field';
import { PortalModule } from '@angular/cdk/portal';
import { DOCUMENT, CommonModule } from '@angular/common';
import { A11yModule } from '@angular/cdk/a11y';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatInputModule } from '@angular/material/input';
import { MatSelectModule } from '@angular/material/select';
import { MatToolbarModule } from '@angular/material/toolbar';
import { trigger, transition, style, animate, sequence } from '@angular/animations';

/**
 * @fileoverview added by tsickle
 * Generated from: lib/models/ngx-mat-timepicker-periods.enum.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const NgxMatTimepickerPeriods = {
    AM: "AM",
    PM: "PM",
};

/**
 * @fileoverview added by tsickle
 * Generated from: lib/models/ngx-mat-timepicker-format.enum.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const NgxMatTimepickerFormat = {
    TWELVE: "hh:mm a",
    TWELVE_SHORT: "h:m a",
    TWENTY_FOUR: "HH:mm",
    TWENTY_FOUR_SHORT: "H:m",
};

/**
 * @fileoverview added by tsickle
 * Generated from: lib/services/ngx-mat-timepicker-adapter.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// @dynamic
class NgxMatTimepickerAdapter {
    /**
     *
     *  Format hour according to time format (12 or 24)
     * @param {?} currentHour
     * @param {?} format
     * @param {?} period
     * @return {?}
     */
    static formatHour(currentHour, format, period) {
        if (format === 24) {
            return currentHour;
        }
        /** @type {?} */
        const hour = period === NgxMatTimepickerPeriods.AM ? currentHour : currentHour + 12;
        if (period === NgxMatTimepickerPeriods.AM && hour === 12) {
            return 0;
        }
        else if (period === NgxMatTimepickerPeriods.PM && hour === 24) {
            return 12;
        }
        return hour;
    }
    /**
     * @param {?} time
     * @param {?} opts
     * @return {?}
     */
    static formatTime(time, opts) {
        if (!time) {
            return "Invalid Time";
        }
        const { format } = opts;
        /** @type {?} */
        const parsedTime = NgxMatTimepickerAdapter.parseTime(time, opts).setLocale(NgxMatTimepickerAdapter.defaultLocale);
        if (format !== 24) {
            return parsedTime.toLocaleString(Object.assign(Object.assign({}, DateTime.TIME_SIMPLE), { hour12: format !== 24 })).replace(/\u200E/g, "");
        }
        return parsedTime.toISOTime({
            includeOffset: false,
            suppressMilliseconds: true,
            suppressSeconds: true
        }).replace(/\u200E/g, "");
    }
    /**
     * @param {?} time
     * @param {?} format
     * @return {?}
     */
    static fromDateTimeToString(time, format) {
        /** @type {?} */
        const timeFormat = format === 24 ? NgxMatTimepickerFormat.TWENTY_FOUR : NgxMatTimepickerFormat.TWELVE;
        return time.reconfigure({
            numberingSystem: NgxMatTimepickerAdapter.defaultNumberingSistem,
            locale: NgxMatTimepickerAdapter.defaultLocale
        }).toFormat(timeFormat);
    }
    /**
     * @param {?} time
     * @param {?} before
     * @param {?} after
     * @param {?=} unit
     * @return {?}
     */
    static isBetween(time, before, after, unit = "minutes") {
        if (unit === "hours") {
            return this.isSameOrBefore(time, after, unit) && this.isSameOrAfter(time, before, unit);
        }
        if (unit === "minutes") {
            return this.isSameOrBefore(time, after) && this.isSameOrAfter(time, before);
        }
    }
    /**
     * @param {?} time
     * @param {?} compareWith
     * @param {?=} unit
     * @return {?}
     */
    static isSameOrAfter(time, compareWith, unit = "minutes") {
        if (unit === "hours") {
            return time.hour >= compareWith.hour;
        }
        if (unit === "minutes") {
            return time.hasSame(compareWith, unit) || time.valueOf() > compareWith.valueOf();
        }
    }
    /**
     * @param {?} time
     * @param {?} compareWith
     * @param {?=} unit
     * @return {?}
     */
    static isSameOrBefore(time, compareWith, unit = "minutes") {
        if (unit === "hours") {
            return time.hour <= compareWith.hour;
        }
        if (unit === "minutes") {
            return time.hasSame(compareWith, unit) || time.valueOf() <= compareWith.valueOf();
        }
    }
    /**
     * @param {?} time
     * @param {?=} min
     * @param {?=} max
     * @param {?=} granularity
     * @param {?=} minutesGap
     * @param {?=} format
     * @return {?}
     */
    static isTimeAvailable(time, min, max, granularity, minutesGap, format) {
        if (!time) {
            return;
        }
        /** @type {?} */
        const convertedTime = this.parseTime(time, { format });
        /** @type {?} */
        const minutes = convertedTime.minute;
        if (minutesGap && minutes === minutes && minutes % minutesGap !== 0) {
            throw new Error(`Your minutes - ${minutes} doesn\'t match your minutesGap - ${minutesGap}`);
        }
        /** @type {?} */
        const isAfter = (min && !max)
            && this.isSameOrAfter(convertedTime, min, granularity);
        /** @type {?} */
        const isBefore = (max && !min)
            && this.isSameOrBefore(convertedTime, max, granularity);
        /** @type {?} */
        const between = (min && max)
            && this.isBetween(convertedTime, min, max, granularity);
        /** @type {?} */
        const isAvailable = !min && !max;
        return isAfter || isBefore || between || isAvailable;
    }
    /**
     * @param {?} time
     * @param {?} opts
     * @return {?}
     */
    static parseTime(time, opts) {
        const { numberingSystem, locale } = NgxMatTimepickerAdapter._getLocaleOptionsByTime(time, opts);
        /** @type {?} */
        const isPeriodExist = time.split(" ").length === 2;
        /** @type {?} */
        const timeMask = isPeriodExist ? NgxMatTimepickerFormat.TWELVE_SHORT : NgxMatTimepickerFormat.TWENTY_FOUR_SHORT;
        return DateTime.fromFormat(time, timeMask, { numberingSystem, locale });
    }
    /**
     * @param {?} time
     * @param {?=} opts
     * @return {?}
     */
    static toLocaleTimeString(time, opts = {}) {
        const { format = NgxMatTimepickerAdapter.defaultFormat, locale = NgxMatTimepickerAdapter.defaultLocale } = opts;
        /** @type {?} */
        const hourCycle = format === 24 ? "h23" : "h12";
        /** @type {?} */
        const timeFormat = Object.assign(Object.assign({}, DateTime.TIME_SIMPLE), { hourCycle });
        /** @type {?} */
        const timeMask = (format === 24) ? NgxMatTimepickerFormat.TWENTY_FOUR_SHORT : NgxMatTimepickerFormat.TWELVE_SHORT;
        return DateTime.fromFormat(time, timeMask).setLocale(locale).toLocaleString(timeFormat);
    }
    /**
     * @private
     * @param {?} time
     * @param {?} opts
     * @return {?}
     */
    static _getLocaleOptionsByTime(time, opts) {
        const { numberingSystem, locale } = DateTime.local().setLocale(opts.locale).resolvedLocaleOpts();
        /** @type {?} */
        const localeConfig = {
            numberingSystem: (/** @type {?} */ (numberingSystem)),
            locale
        };
        /** @type {?} */
        const defaultConfig = {
            numberingSystem: NgxMatTimepickerAdapter.defaultNumberingSistem,
            locale: NgxMatTimepickerAdapter.defaultLocale
        };
        return isNaN(parseInt(time, 10)) ? localeConfig : defaultConfig;
    }
}
NgxMatTimepickerAdapter.defaultFormat = 12;
NgxMatTimepickerAdapter.defaultLocale = "en-US";
NgxMatTimepickerAdapter.defaultNumberingSistem = "latn";

/**
 * @fileoverview added by tsickle
 * Generated from: lib/services/ngx-mat-timepicker.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DEFAULT_HOUR = {
    time: 12,
    angle: 360
};
/** @type {?} */
const DEFAULT_MINUTE = {
    time: 0,
    angle: 360
};
class NgxMatTimepickerService {
    constructor() {
        this._hour$ = new BehaviorSubject(DEFAULT_HOUR);
        this._minute$ = new BehaviorSubject(DEFAULT_MINUTE);
        this._period$ = new BehaviorSubject(NgxMatTimepickerPeriods.AM);
    }
    /**
     * @param {?} hour
     * @return {?}
     */
    set hour(hour) {
        this._hour$.next(hour);
    }
    /**
     * @param {?} minute
     * @return {?}
     */
    set minute(minute) {
        this._minute$.next(minute);
    }
    /**
     * @param {?} period
     * @return {?}
     */
    set period(period) {
        /** @type {?} */
        const isPeriodValid = (period === NgxMatTimepickerPeriods.AM) || (period === NgxMatTimepickerPeriods.PM);
        if (isPeriodValid) {
            this._period$.next(period);
        }
    }
    /**
     * @return {?}
     */
    get selectedHour() {
        return this._hour$.asObservable();
    }
    /**
     * @return {?}
     */
    get selectedMinute() {
        return this._minute$.asObservable();
    }
    /**
     * @return {?}
     */
    get selectedPeriod() {
        return this._period$.asObservable();
    }
    /**
     * @param {?} format
     * @return {?}
     */
    getFullTime(format) {
        /** @type {?} */
        const selectedHour = this._hour$.getValue().time;
        /** @type {?} */
        const selectedMinute = this._minute$.getValue().time;
        /** @type {?} */
        const hour = selectedHour != null ? selectedHour : DEFAULT_HOUR.time;
        /** @type {?} */
        const minute = selectedMinute != null ? selectedMinute : DEFAULT_MINUTE.time;
        /** @type {?} */
        const period = format === 12 ? this._period$.getValue() : "";
        /** @type {?} */
        const time = `${hour}:${minute} ${period}`.trim();
        return NgxMatTimepickerAdapter.formatTime(time, { format });
    }
    /**
     * @param {?} time
     * @param {?} min
     * @param {?} max
     * @param {?} format
     * @param {?=} minutesGap
     * @return {?}
     */
    setDefaultTimeIfAvailable(time, min, max, format, minutesGap) {
        /* Workaround to double error message*/
        try {
            if (NgxMatTimepickerAdapter.isTimeAvailable(time, min, max, "minutes", minutesGap)) {
                this._setDefaultTime(time, format);
            }
        }
        catch (e) {
            console.error(e);
        }
    }
    /**
     * @private
     * @return {?}
     */
    _resetTime() {
        this.hour = Object.assign({}, DEFAULT_HOUR);
        this.minute = Object.assign({}, DEFAULT_MINUTE);
        this.period = NgxMatTimepickerPeriods.AM;
    }
    /**
     * @private
     * @param {?} time
     * @param {?} format
     * @return {?}
     */
    _setDefaultTime(time, format) {
        /** @type {?} */
        const defaultTime = NgxMatTimepickerAdapter.parseTime(time, { format }).toJSDate();
        // Check on null, because invalid date will be null
        if (DateTime.fromJSDate(defaultTime) !== null) {
            /** @type {?} */
            const period = time.substr(time.length - 2).toUpperCase();
            /** @type {?} */
            const hour = defaultTime.getHours();
            this.hour = Object.assign(Object.assign({}, DEFAULT_HOUR), { time: formatHourByPeriod(hour, (/** @type {?} */ (period))) });
            this.minute = Object.assign(Object.assign({}, DEFAULT_MINUTE), { time: defaultTime.getMinutes() });
            this.period = (/** @type {?} */ (period));
        }
        else {
            this._resetTime();
        }
    }
}
NgxMatTimepickerService.decorators = [
    { type: Injectable, args: [{
                providedIn: "root"
            },] }
];
/** @nocollapse */ NgxMatTimepickerService.ɵprov = ɵɵdefineInjectable({ factory: function NgxMatTimepickerService_Factory() { return new NgxMatTimepickerService(); }, token: NgxMatTimepickerService, providedIn: "root" });
/**
 *
 *  Format hour in 24hours format to meridian (AM or PM) format
 * @param {?} hour
 * @param {?} period
 * @return {?}
 */
function formatHourByPeriod(hour, period) {
    switch (period) {
        case NgxMatTimepickerPeriods.AM:
            return hour === 0 ? 12 : hour;
        case NgxMatTimepickerPeriods.PM:
            return hour === 12 ? 12 : hour - 12;
        default:
            return hour;
    }
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/models/ngx-mat-timepicker-units.enum.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const NgxMatTimepickerUnits = {
    HOUR: 0,
    MINUTE: 1,
};
NgxMatTimepickerUnits[NgxMatTimepickerUnits.HOUR] = 'HOUR';
NgxMatTimepickerUnits[NgxMatTimepickerUnits.MINUTE] = 'MINUTE';

/**
 * @fileoverview added by tsickle
 * Generated from: lib/tokens/ngx-mat-timepicker-time-locale.token.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const NGX_MAT_TIMEPICKER_LOCALE = new InjectionToken("TimeLocale", {
    providedIn: "root",
    factory: (/**
     * @return {?}
     */
    () => NgxMatTimepickerAdapter.defaultLocale)
});

/**
 * @fileoverview added by tsickle
 * Generated from: lib/utils/ngx-mat-timepicker.utils.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// @dynamic
class NgxMatTimepickerUtils {
    /**
     * @param {?} hours
     * @param {?} config
     * @return {?}
     */
    static disableHours(hours, config) {
        if (config.min || config.max) {
            return hours.map((/**
             * @param {?} value
             * @return {?}
             */
            value => {
                /** @type {?} */
                const hour = config.format === 24 ? value.time : NgxMatTimepickerAdapter.formatHour(value.time, config.format, config.period);
                /** @type {?} */
                const currentTime = DateTime.fromObject({ hour }).toFormat(NgxMatTimepickerFormat.TWELVE);
                return Object.assign(Object.assign({}, value), { disabled: !NgxMatTimepickerAdapter.isTimeAvailable(currentTime, config.min, config.max, "hours") });
            }));
        }
        return hours;
    }
    /**
     * @param {?} minutes
     * @param {?} selectedHour
     * @param {?} config
     * @return {?}
     */
    static disableMinutes(minutes, selectedHour, config) {
        if (config.min || config.max) {
            /** @type {?} */
            const hour = NgxMatTimepickerAdapter.formatHour(selectedHour, config.format, config.period);
            return minutes.map((/**
             * @param {?} value
             * @return {?}
             */
            value => {
                /** @type {?} */
                const currentTime = DateTime.fromObject({
                    hour,
                    minute: value.time
                }).toFormat(NgxMatTimepickerFormat.TWELVE);
                return Object.assign(Object.assign({}, value), { disabled: !NgxMatTimepickerAdapter.isTimeAvailable(currentTime, config.min, config.max, "minutes") });
            }));
        }
        return minutes;
    }
    /**
     * @param {?} format
     * @return {?}
     */
    static getHours(format) {
        return Array(format).fill(1).map((/**
         * @param {?} v
         * @param {?} i
         * @return {?}
         */
        (v, i) => {
            /** @type {?} */
            const angleStep = 30;
            /** @type {?} */
            const time = v + i;
            /** @type {?} */
            const angle = angleStep * time;
            return { time: time === 24 ? 0 : time, angle };
        }));
    }
    /**
     * @param {?=} gap
     * @return {?}
     */
    static getMinutes(gap = 1) {
        /** @type {?} */
        const minutesCount = 60;
        /** @type {?} */
        const angleStep = 360 / minutesCount;
        /** @type {?} */
        const minutes = [];
        for (let i = 0; i < minutesCount; i++) {
            /** @type {?} */
            const angle = angleStep * i;
            if (i % gap === 0) {
                minutes.push({ time: i, angle: angle !== 0 ? angle : 360 });
            }
        }
        return minutes;
    }
    /**
     * @param {?} e
     * @return {?}
     */
    static isDigit(e) {
        // Allow: backspace, delete, tab, escape, enter
        if ([46, 8, 9, 27, 13].some((/**
         * @param {?} n
         * @return {?}
         */
        n => n === e.keyCode)) ||
            // Allow: Ctrl/cmd+A
            (e.keyCode == 65 && (e.ctrlKey === true || e.metaKey === true)) ||
            // Allow: Ctrl/cmd+C
            (e.keyCode == 67 && (e.ctrlKey === true || e.metaKey === true)) ||
            // Allow: Ctrl/cmd+X
            (e.keyCode == 88 && (e.ctrlKey === true || e.metaKey === true)) ||
            // Allow: home, end, left, right, up, down
            (e.keyCode >= 35 && e.keyCode <= 40)) {
            return true;
        }
        return !((e.keyCode < 48 || e.keyCode > 57) && (e.keyCode < 96 || e.keyCode > 105));
    }
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/components/ngx-mat-timepicker-field/ngx-mat-timepicker-field.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxMatTimepickerFieldComponent {
    /**
     * @param {?} _timepickerService
     * @param {?} _locale
     */
    constructor(_timepickerService, _locale) {
        this._timepickerService = _timepickerService;
        this._locale = _locale;
        this.maxHour = 12;
        this.minHour = 1;
        this.period = NgxMatTimepickerPeriods.AM;
        this.periods = [
            NgxMatTimepickerPeriods.AM,
            NgxMatTimepickerPeriods.PM
        ];
        this.timeChanged = new EventEmitter();
        this.timeUnit = NgxMatTimepickerUnits;
        this._color = "primary";
        this._floatLabel = "never";
        this._format = 12;
        this._isFirstTimeChange = true;
        this._subsCtrl$ = new Subject();
        this._onChange = (/**
         * @return {?}
         */
        () => {
        });
    }
    /**
     * @return {?}
     */
    get color() {
        return this._color;
    }
    /**
     * @param {?} newValue
     * @return {?}
     */
    set color(newValue) {
        this._color = newValue;
    }
    /**
     * @return {?}
     */
    get defaultTime() {
        return this._defaultTime;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set defaultTime(val) {
        this._defaultTime = val;
        this._isDefaultTime = !!val;
    }
    /**
     * @return {?}
     */
    get floatLabel() {
        return this._floatLabel;
    }
    /**
     * @param {?} newValue
     * @return {?}
     */
    set floatLabel(newValue) {
        this._floatLabel = newValue;
    }
    /**
     * @return {?}
     */
    get format() {
        return this._format;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set format(value) {
        this._format = value === 24 ? 24 : 12;
        this.minHour = this._format === 12 ? 1 : 0;
        this.maxHour = this._format === 12 ? 12 : 23;
        this.hoursList = NgxMatTimepickerUtils.getHours(this._format);
        /** @type {?} */
        const isDynamicallyChanged = value && (this._previousFormat && this._previousFormat !== this._format);
        if (isDynamicallyChanged) {
            this._updateTime(this.timepickerTime);
        }
        this._previousFormat = this._format;
    }
    /**
     * @return {?}
     */
    get max() {
        return this._max;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set max(value) {
        if (typeof value === "string") {
            this._max = NgxMatTimepickerAdapter.parseTime(value, { locale: this._locale, format: this.format });
            return;
        }
        this._max = value;
    }
    /**
     * @return {?}
     */
    get min() {
        return this._min;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set min(value) {
        if (typeof value === "string") {
            this._min = NgxMatTimepickerAdapter.parseTime(value, { locale: this._locale, format: this.format });
            return;
        }
        this._min = value;
    }
    /**
     * @param {?} hour
     * @return {?}
     */
    changeHour(hour) {
        this._timepickerService.hour = this.hoursList.find((/**
         * @param {?} h
         * @return {?}
         */
        h => h.time === hour));
        this._changeTime();
    }
    /**
     * @param {?} minute
     * @return {?}
     */
    changeMinute(minute) {
        this._timepickerService.minute = this.minutesList.find((/**
         * @param {?} m
         * @return {?}
         */
        m => m.time === minute));
        this._changeTime();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    changePeriod(event) {
        this._timepickerService.period = (/** @type {?} */ (event.value));
        this._changeTime();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._subsCtrl$.next();
        this._subsCtrl$.complete();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._initTime(this.defaultTime);
        this.hoursList = NgxMatTimepickerUtils.getHours(this._format);
        this.minutesList = NgxMatTimepickerUtils.getMinutes();
        this.isTimeRangeSet = !!(this.min || this.max);
        this.hour$ = (/** @type {?} */ (this._timepickerService.selectedHour.pipe(tap((/**
         * @param {?} clockTime
         * @return {?}
         */
        (clockTime) => this._selectedHour = clockTime.time)), map(this._changeDefaultTimeValue.bind(this)), tap((/**
         * @return {?}
         */
        () => this.isTimeRangeSet && this._updateAvailableMinutes())))));
        this.minute$ = (/** @type {?} */ (this._timepickerService.selectedMinute.pipe(map(this._changeDefaultTimeValue.bind(this)), tap((/**
         * @return {?}
         */
        () => this._isFirstTimeChange = false)))));
        if (this.format === 12) {
            this._timepickerService.selectedPeriod.pipe(distinctUntilChanged(), tap((/**
             * @param {?} period
             * @return {?}
             */
            (period) => this.period = period)), tap((/**
             * @param {?} period
             * @return {?}
             */
            period => this.isChangePeriodDisabled = this._isPeriodDisabled(period))), takeUntil(this._subsCtrl$)).subscribe((/**
             * @return {?}
             */
            () => this.isTimeRangeSet && this._updateAvailableTime()));
        }
    }
    /**
     * @param {?} time
     * @return {?}
     */
    onTimeSet(time) {
        this._updateTime(time);
        this._emitLocalTimeChange(time);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this._onChange = fn;
    }
    /**
     * @param {?} _fn_
     * @return {?}
     */
    registerOnTouched(_fn_) {
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    writeValue(val) {
        if (val) {
            this._initTime(val);
        }
        else {
            this._resetTime();
        }
    }
    /**
     * @private
     * @param {?} clockFaceTime
     * @return {?}
     */
    _changeDefaultTimeValue(clockFaceTime) {
        if (!this._isDefaultTime && this._isFirstTimeChange) {
            return Object.assign(Object.assign({}, clockFaceTime), { time: null });
        }
        return clockFaceTime;
    }
    /**
     * @private
     * @return {?}
     */
    _changeTime() {
        /** @type {?} */
        const time = this._timepickerService.getFullTime(this.format);
        this.timepickerTime = time;
        this._emitLocalTimeChange(time);
    }
    /**
     * @private
     * @param {?} time
     * @return {?}
     */
    _emitLocalTimeChange(time) {
        /** @type {?} */
        const localTime = NgxMatTimepickerAdapter.toLocaleTimeString(time, { format: this.format, locale: this._locale });
        this._onChange(localTime);
        this.timeChanged.emit(localTime);
    }
    /**
     * @private
     * @param {?} time
     * @return {?}
     */
    _initTime(time) {
        /** @type {?} */
        const isDefaultTimeAvailable = NgxMatTimepickerAdapter
            .isTimeAvailable(time, (/** @type {?} */ (this.min)), (/** @type {?} */ (this.max)), "minutes", null, this.format);
        if (!isDefaultTimeAvailable) {
            if (this.min) {
                this._updateTime(NgxMatTimepickerAdapter.fromDateTimeToString((/** @type {?} */ (this.min)), this.format));
                return;
            }
            if (this.max) {
                this._updateTime(NgxMatTimepickerAdapter.fromDateTimeToString((/** @type {?} */ (this.max)), this.format));
                return;
            }
        }
        this._updateTime(time);
    }
    /**
     * @private
     * @param {?} period
     * @return {?}
     */
    _isPeriodDisabled(period) {
        return NgxMatTimepickerUtils.disableHours(NgxMatTimepickerUtils.getHours(12), {
            min: (/** @type {?} */ (this.min)),
            max: (/** @type {?} */ (this.max)),
            format: 12,
            period: period === NgxMatTimepickerPeriods.AM ? NgxMatTimepickerPeriods.PM : NgxMatTimepickerPeriods.AM
        }).every((/**
         * @param {?} time
         * @return {?}
         */
        time => time.disabled));
    }
    /**
     * @private
     * @return {?}
     */
    _resetTime() {
        this._timepickerService.hour = { angle: 0, time: null };
        this._timepickerService.minute = { angle: 0, time: null };
    }
    /**
     * @private
     * @return {?}
     */
    _updateAvailableHours() {
        this.hoursList = NgxMatTimepickerUtils.disableHours(this.hoursList, {
            min: (/** @type {?} */ (this.min)),
            max: (/** @type {?} */ (this.max)),
            format: this.format,
            period: this.period
        });
    }
    /**
     * @private
     * @return {?}
     */
    _updateAvailableMinutes() {
        this.minutesList = NgxMatTimepickerUtils.disableMinutes(this.minutesList, this._selectedHour, {
            min: (/** @type {?} */ (this.min)),
            max: (/** @type {?} */ (this.max)),
            format: this.format,
            period: this.period
        });
    }
    /**
     * @private
     * @return {?}
     */
    _updateAvailableTime() {
        this._updateAvailableHours();
        if (this._selectedHour) {
            this._updateAvailableMinutes();
        }
    }
    /**
     * @private
     * @param {?} time
     * @return {?}
     */
    _updateTime(time) {
        if (time) {
            /** @type {?} */
            const formattedTime = NgxMatTimepickerAdapter.formatTime(time, { locale: this._locale, format: this.format });
            this._timepickerService.setDefaultTimeIfAvailable(formattedTime, (/** @type {?} */ (this.min)), (/** @type {?} */ (this.max)), this.format);
            this.timepickerTime = formattedTime;
        }
    }
}
NgxMatTimepickerFieldComponent.decorators = [
    { type: Component, args: [{
                selector: "ngx-mat-timepicker-field",
                template: "<div class=\"ngx-mat-timepicker\"\n     [ngClass]=\"{'ngx-mat-timepicker--disabled': disabled}\">\n    <ngx-mat-timepicker-time-control\n            class=\"ngx-mat-timepicker__control--first\"\n            [color]=\"color\"\n            [floatLabel]=\"floatLabel\"\n            [placeholder]=\"'HH'\"\n            [time]=\"(hour$ | async)?.time\"\n            [min]=\"minHour\"\n            [max]=\"maxHour\"\n            [timeUnit]=\"timeUnit.HOUR\"\n            [disabled]=\"disabled\"\n            [timeList]=\"hoursList\"\n            [preventTyping]=\"isTimeRangeSet\"\n            (timeChanged)=\"changeHour($event)\"></ngx-mat-timepicker-time-control>\n    <span class=\"separator-colon ngx-mat-timepicker__control--second\">:</span>\n    <ngx-mat-timepicker-time-control\n            class=\"ngx-mat-timepicker__control--third\"\n            [color]=\"color\"\n            [floatLabel]=\"floatLabel\"\n            [placeholder]=\"'MM'\"\n            [time]=\"(minute$ | async)?.time\"\n            [min]=\"0\"\n            [max]=\"59\"\n            [timeUnit]=\"timeUnit.MINUTE\"\n            [disabled]=\"disabled\"\n            [timeList]=\"minutesList\"\n            [preventTyping]=\"isTimeRangeSet\"\n            (timeChanged)=\"changeMinute($event)\"></ngx-mat-timepicker-time-control>\n    <mat-form-field class=\"period-select ngx-mat-timepicker__control--forth\"\n                    *ngIf=\"format !== 24\"\n                    [color]=\"color\">\n        <mat-select [disabled]=\"disabled || isChangePeriodDisabled\"\n                    (selectionChange)=\"changePeriod($event)\"\n                    [ngModel]=\"period\">\n            <mat-option *ngFor=\"let option of periods\"\n                        [value]=\"option\">{{option}}</mat-option>\n        </mat-select>\n    </mat-form-field>\n    <ngx-mat-timepicker-toggle\n            class=\"ngx-mat-timepicker__toggle\"\n            *ngIf=\"!controlOnly\"\n            [for]=\"timepicker\"\n            [disabled]=\"disabled\">\n        <span ngxMatTimepickerToggleIcon>\n            <ng-container *ngTemplateOutlet=\"toggleIcon || defaultIcon\"></ng-container>\n        </span>\n    </ngx-mat-timepicker-toggle>\n</div>\n<ngx-mat-timepicker\n        [color]=\"color\"\n        [min]=\"min\"\n        [max]=\"max\"\n        [theme]=\"clockTheme\"\n        [defaultTime]=\"timepickerTime\"\n        [format]=\"format\"\n        [cancelBtnTmpl]=\"cancelBtnTmpl\"\n        [confirmBtnTmpl]=\"confirmBtnTmpl\"\n        (timeSet)=\"onTimeSet($event)\"\n        #timepicker></ngx-mat-timepicker>\n\n<ng-template #defaultIcon>\n    <mat-icon>watch_later</mat-icon>\n</ng-template>\n",
                providers: [
                    NgxMatTimepickerService,
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: NgxMatTimepickerFieldComponent,
                        multi: true
                    }
                ],
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                styles: [".ngx-mat-timepicker{display:flex;align-items:center;height:100%}.ngx-mat-timepicker--disabled{background:rgba(0,0,0,.07);pointer-events:none}.ngx-mat-timepicker .separator-colon{margin-left:5px;margin-right:5px}.ngx-mat-timepicker .period-select{width:60px;min-width:60px;margin-left:8px;text-align:center}.ngx-mat-timepicker__control--first{order:1}.ngx-mat-timepicker__control--second{order:2}.ngx-mat-timepicker__control--third{order:3}.ngx-mat-timepicker__control--forth,.ngx-mat-timepicker__toggle{order:4}"]
            }] }
];
/** @nocollapse */
NgxMatTimepickerFieldComponent.ctorParameters = () => [
    { type: NgxMatTimepickerService },
    { type: String, decorators: [{ type: Inject, args: [NGX_MAT_TIMEPICKER_LOCALE,] }] }
];
NgxMatTimepickerFieldComponent.propDecorators = {
    color: [{ type: Input }],
    defaultTime: [{ type: Input }],
    floatLabel: [{ type: Input }],
    format: [{ type: Input }],
    max: [{ type: Input }],
    min: [{ type: Input }],
    cancelBtnTmpl: [{ type: Input }],
    clockTheme: [{ type: Input }],
    confirmBtnTmpl: [{ type: Input }],
    controlOnly: [{ type: Input }],
    disabled: [{ type: Input }],
    timeChanged: [{ type: Output }],
    toggleIcon: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/ngx-mat-timepicker-toggle-icon.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/* To override a default toggle icon */
class NgxMatTimepickerToggleIconDirective {
}
NgxMatTimepickerToggleIconDirective.decorators = [
    { type: Directive, args: [{ selector: "[ngxMatTimepickerToggleIcon]" },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: lib/services/ngx-mat-timepicker-event.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxMatTimepickerEventService {
    constructor() {
        this._backdropClick$ = new Subject();
        this._keydownEvent$ = new Subject();
    }
    /**
     * @return {?}
     */
    get backdropClick() {
        return this._backdropClick$.asObservable().pipe(shareReplay({ bufferSize: 1, refCount: true }));
    }
    /**
     * @return {?}
     */
    get keydownEvent() {
        return this._keydownEvent$.asObservable().pipe(shareReplay({ bufferSize: 1, refCount: true }));
    }
    /**
     * @param {?} event
     * @return {?}
     */
    dispatchEvent(event) {
        switch (event.type) {
            case "click":
                this._backdropClick$.next((/** @type {?} */ (event)));
                break;
            case "keydown":
                this._keydownEvent$.next((/** @type {?} */ (event)));
                break;
            default:
                throw new Error("no such event type");
        }
    }
}
NgxMatTimepickerEventService.decorators = [
    { type: Injectable, args: [{
                providedIn: "root"
            },] }
];
/** @nocollapse */
NgxMatTimepickerEventService.ctorParameters = () => [];
/** @nocollapse */ NgxMatTimepickerEventService.ɵprov = ɵɵdefineInjectable({ factory: function NgxMatTimepickerEventService_Factory() { return new NgxMatTimepickerEventService(); }, token: NgxMatTimepickerEventService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * Generated from: lib/tokens/ngx-mat-timepicker-config.token.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const NGX_MAT_TIMEPICKER_CONFIG = new InjectionToken("NGX_MAT_TIMEPICKER_CONFIG");

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/ngx-mat-timepicker-base.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxMatTimepickerBaseDirective {
    /**
     * @param {?} _timepickerSrv
     * @param {?} _eventSrv
     * @param {?} _locale
     * @param {?} data
     */
    constructor(_timepickerSrv, _eventSrv, _locale, data) {
        this._timepickerSrv = _timepickerSrv;
        this._eventSrv = _eventSrv;
        this._locale = _locale;
        this.data = data;
        this.activeTimeUnit = NgxMatTimepickerUnits.HOUR;
        this.timeUnit = NgxMatTimepickerUnits;
        this._color = "primary";
        this._subsCtrl$ = new Subject();
        this.color = data.color;
        this.defaultTime = data.defaultTime;
    }
    /**
     * @param {?} newValue
     * @return {?}
     */
    set color(newValue) {
        this._color = newValue;
    }
    /**
     * @return {?}
     */
    get color() {
        return this._color;
    }
    /**
     * @return {?}
     */
    get defaultTime() {
        return this._defaultTime;
    }
    /**
     * @param {?} time
     * @return {?}
     */
    set defaultTime(time) {
        this._defaultTime = time;
        this._setDefaultTime(time);
    }
    /**
     * @param {?} period
     * @return {?}
     */
    changePeriod(period) {
        this._timepickerSrv.period = period;
        this._onTimeChange();
    }
    /**
     * @param {?} unit
     * @return {?}
     */
    changeTimeUnit(unit) {
        this.activeTimeUnit = unit;
    }
    /**
     * @return {?}
     */
    close() {
        this.data.timepickerBaseRef.close();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._subsCtrl$.next();
        this._subsCtrl$.complete();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._defineTime();
        this.selectedHour = this._timepickerSrv.selectedHour
            .pipe(shareReplay({ bufferSize: 1, refCount: true }));
        this.selectedMinute = this._timepickerSrv.selectedMinute
            .pipe(shareReplay({ bufferSize: 1, refCount: true }));
        this.selectedPeriod = this._timepickerSrv.selectedPeriod
            .pipe(shareReplay({ bufferSize: 1, refCount: true }));
        this.data.timepickerBaseRef.timeUpdated.pipe(takeUntil(this._subsCtrl$))
            .subscribe(this._setDefaultTime.bind(this));
    }
    /**
     * @param {?} hour
     * @return {?}
     */
    onHourChange(hour) {
        this._timepickerSrv.hour = hour;
        this._onTimeChange();
    }
    /**
     * @param {?} hour
     * @return {?}
     */
    onHourSelected(hour) {
        if (!this.data.hoursOnly) {
            this.changeTimeUnit(NgxMatTimepickerUnits.MINUTE);
        }
        this.data.timepickerBaseRef.hourSelected.next(hour);
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onKeydown(e) {
        this._eventSrv.dispatchEvent(e);
        e.stopPropagation();
    }
    /**
     * @param {?} minute
     * @return {?}
     */
    onMinuteChange(minute) {
        this._timepickerSrv.minute = minute;
        this._onTimeChange();
    }
    /**
     * @return {?}
     */
    setTime() {
        this.data.timepickerBaseRef.timeSet.next(this._timepickerSrv.getFullTime(this.data.format));
        this.close();
    }
    /**
     * @protected
     * @return {?}
     */
    _defineTime() {
        /** @type {?} */
        const minTime = this.data.minTime;
        if (minTime && (!this.data.time && !this.data.defaultTime)) {
            /** @type {?} */
            const time = NgxMatTimepickerAdapter.fromDateTimeToString(minTime, this.data.format);
            this._setDefaultTime(time);
        }
    }
    /**
     * @protected
     * @return {?}
     */
    _onTimeChange() {
        /** @type {?} */
        const time = NgxMatTimepickerAdapter.toLocaleTimeString(this._timepickerSrv.getFullTime(this.data.format), {
            locale: this._locale,
            format: this.data.format
        });
        this.data.timepickerBaseRef.timeChanged.emit(time);
    }
    /**
     * @protected
     * @param {?} time
     * @return {?}
     */
    _setDefaultTime(time) {
        this._timepickerSrv.setDefaultTimeIfAvailable(time, this.data.minTime, this.data.maxTime, this.data.format, this.data.minutesGap);
    }
}
NgxMatTimepickerBaseDirective.decorators = [
    { type: Directive, args: [{
                selector: "[ngxMatTimepickerBase]"
            },] }
];
/** @nocollapse */
NgxMatTimepickerBaseDirective.ctorParameters = () => [
    { type: NgxMatTimepickerService },
    { type: NgxMatTimepickerEventService },
    { type: String, decorators: [{ type: Inject, args: [NGX_MAT_TIMEPICKER_LOCALE,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [NGX_MAT_TIMEPICKER_CONFIG,] }, { type: Optional }] }
];
NgxMatTimepickerBaseDirective.propDecorators = {
    color: [{ type: Input }],
    defaultTime: [{ type: Input }],
    onKeydown: [{ type: HostListener, args: ["keydown", ["$event"],] }]
};

/**
 * @fileoverview added by tsickle
 * Generated from: lib/components/ngx-mat-timepicker-dialog/ngx-mat-timepicker-dialog.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
//
class NgxMatTimepickerDialogComponent extends NgxMatTimepickerBaseDirective {
    /**
     * @param {?} data
     * @param {?} _dialogRef
     * @param {?} timepickerSrv
     * @param {?} eventSrv
     * @param {?} locale
     */
    constructor(data, _dialogRef, timepickerSrv, eventSrv, locale) {
        super(timepickerSrv, eventSrv, locale, data);
        this.data = data;
        this._dialogRef = _dialogRef;
    }
    /**
     * @return {?}
     */
    close() {
        this._dialogRef.close();
    }
}
NgxMatTimepickerDialogComponent.decorators = [
    { type: Component, args: [{
                selector: "ngx-mat-timepicker-dialog",
                template: "<ng-template #cancelBtnDefault>\n    <button mat-button\n            [color]=\"color\">CANCEL\n    </button>\n</ng-template>\n<ng-template #confirmBtnDefault>\n    <button mat-button\n            [color]=\"color\">OK\n    </button>\n</ng-template>\n<div mat-dialog-content>\n    <ngx-mat-timepicker-content [appendToInput]=\"data.appendToInput\"\n                                [inputElement]=\"data.inputElement\"\n                                [ngxMatTimepickerTheme]=\"data.theme\">\n        <div class=\"timepicker\"\n             [ngClass]=\"data.timepickerClass\">\n            <mat-toolbar [color]=\"color\"\n                         class=\"timepicker-header\">\n                <ngx-mat-timepicker-dial [color]=\"color\"\n                                         [format]=\"data.format\"\n                                         [hour]=\"(selectedHour | async)?.time\"\n                                         [minute]=\"(selectedMinute | async)?.time\"\n                                         [period]=\"selectedPeriod | async\"\n                                         [activeTimeUnit]=\"activeTimeUnit\"\n                                         [minTime]=\"data.minTime\"\n                                         [maxTime]=\"data.maxTime\"\n                                         [isEditable]=\"data.enableKeyboardInput\"\n                                         [editableHintTmpl]=\"data.editableHintTmpl\"\n                                         [minutesGap]=\"data.minutesGap\"\n                                         [hoursOnly]=\"data.hoursOnly\"\n                                         (periodChanged)=\"changePeriod($event)\"\n                                         (timeUnitChanged)=\"changeTimeUnit($event)\"\n                                         (hourChanged)=\"onHourChange($event)\"\n                                         (minuteChanged)=\"onMinuteChange($event)\"\n                ></ngx-mat-timepicker-dial>\n            </mat-toolbar>\n            <div class=\"timepicker__main-content\">\n                <div class=\"timepicker__body\"\n                     [ngSwitch]=\"activeTimeUnit\">\n                    <div *ngSwitchCase=\"timeUnit.HOUR\">\n                        <ngx-mat-timepicker-24-hours-face *ngIf=\"data.format === 24;else ampmHours\"\n                                                          [color]=\"color\"\n                                                          (hourChange)=\"onHourChange($event)\"\n                                                          [selectedHour]=\"selectedHour | async\"\n                                                          [minTime]=\"data.minTime\"\n                                                          [maxTime]=\"data.maxTime\"\n                                                          [format]=\"data.format\"\n                                                          (hourSelected)=\"onHourSelected($event)\"></ngx-mat-timepicker-24-hours-face>\n                        <ng-template #ampmHours>\n                            <ngx-mat-timepicker-12-hours-face\n                                    [color]=\"color\"\n                                    (hourChange)=\"onHourChange($event)\"\n                                    [selectedHour]=\"selectedHour | async\"\n                                    [period]=\"selectedPeriod | async\"\n                                    [minTime]=\"data.minTime\"\n                                    [maxTime]=\"data.maxTime\"\n                                    (hourSelected)=\"onHourSelected($event)\"></ngx-mat-timepicker-12-hours-face>\n                        </ng-template>\n                    </div>\n                    <ngx-mat-timepicker-minutes-face *ngSwitchCase=\"timeUnit.MINUTE\"\n                                                     [color]=\"color\"\n                                                     [selectedMinute]=\"selectedMinute | async\"\n                                                     [selectedHour]=\"(selectedHour | async)?.time\"\n                                                     [minTime]=\"data.minTime\"\n                                                     [maxTime]=\"data.maxTime\"\n                                                     [format]=\"data.format\"\n                                                     [period]=\"selectedPeriod | async\"\n                                                     [minutesGap]=\"data.minutesGap\"\n                                                     (minuteChange)=\"onMinuteChange($event)\"></ngx-mat-timepicker-minutes-face>\n                </div>\n            </div>\n        </div>\n    </ngx-mat-timepicker-content>\n</div>\n<div mat-dialog-actions>\n    <div (click)=\"close()\">\n        <ng-container\n                *ngTemplateOutlet=\"data.cancelBtnTmpl ? data.cancelBtnTmpl : cancelBtnDefault\"></ng-container>\n    </div>\n    <div (click)=\"setTime()\">\n        <ng-container\n                *ngTemplateOutlet=\"data.confirmBtnTmpl ? data.confirmBtnTmpl : confirmBtnDefault\"></ng-container>\n    </div>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                styles: ["div.ngx-mat-timepicker-dialog>mat-dialog-container.mat-dialog-container{padding-top:0}div.ngx-mat-timepicker-dialog>mat-dialog-container.mat-dialog-container .mat-dialog-content{padding:0;max-height:85vh}div.ngx-mat-timepicker-dialog>mat-dialog-container.mat-dialog-container .mat-dialog-content mat-toolbar.timepicker-header{display:flex;justify-content:center;align-items:center}div.ngx-mat-timepicker-dialog>mat-dialog-container.mat-dialog-container .mat-dialog-content .clock-face{margin:16px}div.ngx-mat-timepicker-dialog>mat-dialog-container.mat-dialog-container div[mat-dialog-actions]{justify-content:flex-end;display:flex}"]
            }] }
];
/** @nocollapse */
NgxMatTimepickerDialogComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [MAT_DIALOG_DATA,] }] },
    { type: MatDialogRef },
    { type: NgxMatTimepickerService },
    { type: NgxMatTimepickerEventService },
    { type: String, decorators: [{ type: Inject, args: [NGX_MAT_TIMEPICKER_LOCALE,] }] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: lib/components/ngx-mat-timepicker/ngx-mat-timepicker.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let config;
class NgxMatTimepickerComponent {
    /**
     * @param {?} _vcr
     * @param {?} _eventService
     * @param {?} _dialog
     * @param {?} _overlay
     * @param {?} _domService
     */
    constructor(_vcr, _eventService, _dialog, _overlay, _domService) {
        this._vcr = _vcr;
        this._eventService = _eventService;
        this._dialog = _dialog;
        this._overlay = _overlay;
        this._domService = _domService;
        this.closed = new EventEmitter();
        this.hourSelected = new EventEmitter();
        this.hoursOnly = false;
        this.id = `ngx_mat_timepicker_${++NgxMatTimepickerComponent.nextId}`;
        this.isEsc = !0;
        this.opened = new EventEmitter();
        this.overlayPositions = [
            {
                originX: "center",
                originY: "bottom",
                overlayX: "center",
                overlayY: "top",
                offsetY: 0
            },
            {
                originX: "center",
                originY: "top",
                overlayX: "center",
                overlayY: "bottom",
                offsetY: 0
            }
        ];
        this.showPicker = !1;
        this.timeChanged = new EventEmitter();
        this.timeSet = new EventEmitter();
        this.timeUpdated = new Subject(); // used in the dialog, check if a better approach can be used
        // used in the dialog, check if a better approach can be used
        this._color = "primary";
    }
    /**
     * @param {?} newValue
     * @return {?}
     */
    set color(newValue) {
        this._color = newValue;
    }
    /**
     * @return {?}
     */
    get color() {
        return this._color;
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._timepickerInput && this._timepickerInput.disabled;
    }
    /**
     * @return {?}
     */
    get format() {
        return this._timepickerInput ? this._timepickerInput.format : this._format;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set format(value) {
        this._format = value === 24 ? 24 : 12;
    }
    /**
     * @return {?}
     */
    get inputElement() {
        return this._timepickerInput && this._timepickerInput.element;
    }
    /**
     * @return {?}
     */
    get maxTime() {
        return this._timepickerInput ? ((/** @type {?} */ (this._timepickerInput.max))) : this.max;
    }
    /**
     * @return {?}
     */
    get minTime() {
        return this._timepickerInput ? ((/** @type {?} */ (this._timepickerInput.min))) : this.min;
    }
    /**
     * @return {?}
     */
    get minutesGap() {
        return this._minutesGap;
    }
    /**
     * @param {?} gap
     * @return {?}
     */
    set minutesGap(gap) {
        if (gap == null) {
            return;
        }
        gap = Math.floor(gap);
        this._minutesGap = gap <= 59 ? gap : 1;
    }
    /**
     * @return {?}
     */
    get overlayOrigin() {
        return this._timepickerInput ? this._timepickerInput.cdkOverlayOrigin : void 0;
    }
    /**
     * @return {?}
     */
    get time() {
        return this._timepickerInput && this._timepickerInput.value;
    }
    /**
     * @param {?} newValue
     * @return {?}
     */
    set ngxMatTimepickerTheme(newValue) {
        this._ngxMatTimepickerTheme = newValue;
    }
    /**
     * @return {?}
     */
    close() {
        if (this.appendToInput) {
            this._overlayRef && this._overlayRef.dispose();
        }
        else {
            this._dialogRef && this._dialogRef.close();
        }
        this.showPicker = !1;
        this.closed.emit();
    }
    /**
     * @return {?}
     */
    open() {
        config = {
            timepickerBaseRef: this,
            time: this.time,
            defaultTime: this.defaultTime,
            maxTime: this.maxTime,
            minTime: this.minTime,
            format: this.format,
            minutesGap: this.minutesGap,
            disableAnimation: this.disableAnimation,
            cancelBtnTmpl: this.cancelBtnTmpl,
            confirmBtnTmpl: this.confirmBtnTmpl,
            editableHintTmpl: this.editableHintTmpl,
            disabled: this.disabled,
            enableKeyboardInput: this.enableKeyboardInput,
            preventOverlayClick: this.preventOverlayClick,
            appendToInput: this.appendToInput,
            hoursOnly: this.hoursOnly,
            theme: this.theme || this._ngxMatTimepickerTheme,
            timepickerClass: this.timepickerClass,
            inputElement: this.inputElement,
            color: this.color
        };
        if (this.appendToInput) {
            this.showPicker = !0;
        }
        else {
            this._dialogRef = this._dialog.open(NgxMatTimepickerDialogComponent, {
                panelClass: "ngx-mat-timepicker-dialog",
                data: Object.assign({}, config)
            });
            this._dialogRef
                .afterClosed()
                .subscribe((/**
             * @return {?}
             */
            () => {
                this.closed.emit();
            }));
        }
        this.opened.emit();
    }
    /**
     *
     * Register an input with this timepicker.
     * input - The timepicker input to register with this timepicker
     * @param {?} input
     * @return {?}
     */
    registerInput(input) {
        if (this._timepickerInput) {
            throw Error("A Timepicker can only be associated with a single input.");
        }
        this._timepickerInput = input;
    }
    /**
     * @return {?}
     */
    unregisterInput() {
        this._timepickerInput = void 0;
    }
    /**
     * @param {?} time
     * @return {?}
     */
    updateTime(time) {
        this.timeUpdated.next(time);
    }
}
NgxMatTimepickerComponent.nextId = 0;
NgxMatTimepickerComponent.decorators = [
    { type: Component, args: [{
                selector: "ngx-mat-timepicker",
                template: `
		<ng-template
				cdkConnectedOverlay
				[cdkConnectedOverlayPositions]="overlayPositions"
				[cdkConnectedOverlayHasBackdrop]="!0"
				cdkConnectedOverlayBackdropClass="cdk-overlay-transparent-backdrop"
				(backdropClick)="close()"
				[cdkConnectedOverlayOrigin]="overlayOrigin"
				[cdkConnectedOverlayOpen]="showPicker">
			<ngx-mat-timepicker-standalone></ngx-mat-timepicker-standalone>
		</ng-template>`,
                providers: [
                    {
                        provide: NGX_MAT_TIMEPICKER_CONFIG, /**
                         * @return {?}
                         */
                        useFactory() {
                            return config;
                        }
                    }
                ]
            }] }
];
/** @nocollapse */
NgxMatTimepickerComponent.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: NgxMatTimepickerEventService },
    { type: MatDialog },
    { type: Overlay },
    { type: SmpDomService }
];
NgxMatTimepickerComponent.propDecorators = {
    color: [{ type: Input }],
    format: [{ type: Input }],
    minutesGap: [{ type: Input }],
    appendToInput: [{ type: Input }],
    cancelBtnTmpl: [{ type: Input }],
    closed: [{ type: Output }],
    confirmBtnTmpl: [{ type: Input }],
    defaultTime: [{ type: Input }],
    disableAnimation: [{ type: Input }],
    editableHintTmpl: [{ type: Input }],
    enableKeyboardInput: [{ type: Input }],
    hourSelected: [{ type: Output }],
    hoursOnly: [{ type: Input }],
    id: [{ type: HostBinding, args: ["id",] }],
    isEsc: [{ type: Input }],
    max: [{ type: Input }],
    min: [{ type: Input }],
    opened: [{ type: Output }],
    preventOverlayClick: [{ type: Input }],
    theme: [{ type: Input }],
    timeChanged: [{ type: Output }],
    timepickerClass: [{ type: Input }],
    timeSet: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * Generated from: lib/components/ngx-mat-timepicker-toggle/ngx-mat-timepicker-toggle.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxMatTimepickerToggleComponent {
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled === undefined ? this.timepicker.disabled : this._disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this._disabled = value;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    open(event) {
        if (this.timepicker) {
            this.timepicker.open();
            event.stopPropagation();
        }
    }
}
NgxMatTimepickerToggleComponent.decorators = [
    { type: Component, args: [{
                selector: "ngx-mat-timepicker-toggle",
                template: "<button class=\"ngx-mat-timepicker-toggle mat-elevation-z0\"\n        color=\"\"\n        mat-mini-fab\n        (click)=\"open($event)\"\n        [disabled]=\"disabled\"\n        type=\"button\">\n    <svg xmlns=\"http://www.w3.org/2000/svg\"\n         viewBox=\"0 0 24 24\"\n         width=\"24px\"\n         height=\"24px\"\n         *ngIf=\"!customIcon\">\n        <path d=\"M 12 2 C 6.4889971 2 2 6.4889971 2 12 C 2 17.511003                   6.4889971 22 12 22 C 17.511003 22 22 17.511003 22 12 C 22 6.4889971 17.511003 2 12 2 z M 12 4 C 16.430123 4 20 7.5698774 20 12 C 20 16.430123 16.430123 20 12 20 C 7.5698774 20 4 16.430123 4 12 C 4 7.5698774 7.5698774 4 12 4 z M 11 6 L 11 12.414062 L 15.292969 16.707031 L 16.707031 15.292969 L 13 11.585938 L 13 6 L 11 6 z\" />\n    </svg>\n\n    <ng-content select=\"[ngxMatTimepickerToggleIcon]\"></ng-content>\n</button>\n",
                styles: ["button.ngx-mat-timepicker-toggle{background-color:transparent;text-align:center;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;box-shadow:none}"]
            }] }
];
NgxMatTimepickerToggleComponent.propDecorators = {
    disabled: [{ type: Input }],
    customIcon: [{ type: ContentChild, args: [NgxMatTimepickerToggleIconDirective, { static: true },] }],
    timepicker: [{ type: Input, args: ["for",] }]
};

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/ngx-mat-timepicker.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxMatTimepickerDirective {
    /**
     * @param {?} _elementRef
     * @param {?} _matFormField
     * @param {?} _locale
     */
    constructor(_elementRef, _matFormField, _locale) {
        this._elementRef = _elementRef;
        this._matFormField = _matFormField;
        this._locale = _locale;
        // TODO: IMPROVE DETECTING (INJECT) MAT-FORM-FIELD IF PRESENT
        this.cdkOverlayOrigin = new CdkOverlayOrigin(this._matFormField ? this._matFormField.getConnectedOverlayOrigin() : this._elementRef);
        this._format = 12;
        this._subsCtrl$ = new Subject();
        this._value = "";
        this.onTouched = (/**
         * @return {?}
         */
        () => {
        });
        this._onChange = (/**
         * @return {?}
         */
        () => {
        });
    }
    /**
     * @return {?}
     */
    get element() {
        return this._elementRef && this._elementRef.nativeElement;
    }
    /**
     * @return {?}
     */
    get format() {
        return this._format;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set format(value) {
        this._format = +value === 24 ? 24 : 12;
        /** @type {?} */
        const isDynamicallyChanged = value && (this._previousFormat && this._previousFormat !== this._format);
        if (isDynamicallyChanged) {
            this.value = this._value;
            this._timepicker.updateTime(this._value);
        }
        this._previousFormat = this._format;
    }
    /**
     * @return {?}
     */
    get max() {
        return this._max;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set max(value) {
        if (typeof value === "string") {
            this._max = NgxMatTimepickerAdapter.parseTime(value, { locale: this._locale, format: this.format });
            return;
        }
        this._max = value;
    }
    /**
     * @return {?}
     */
    get min() {
        return this._min;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set min(value) {
        if (typeof value === "string") {
            this._min = NgxMatTimepickerAdapter.parseTime(value, { locale: this._locale, format: this.format });
            return;
        }
        this._min = value;
    }
    /**
     * @param {?} picker
     * @return {?}
     */
    set timepicker(picker) {
        this._registerTimepicker(picker);
    }
    /**
     * @return {?}
     */
    get value() {
        if (!this._value) {
            return "";
        }
        return NgxMatTimepickerAdapter.toLocaleTimeString(this._value, { format: this.format, locale: this._locale });
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set value(value) {
        if (!value) {
            this._value = "";
            this._updateInputValue();
            return;
        }
        /** @type {?} */
        const time = NgxMatTimepickerAdapter.formatTime(value, { locale: this._locale, format: this.format });
        /** @type {?} */
        const isAvailable = NgxMatTimepickerAdapter.isTimeAvailable(time, (/** @type {?} */ (this._min)), (/** @type {?} */ (this._max)), "minutes", this._timepicker.minutesGap, this._format);
        if (isAvailable) {
            this._value = time;
            this._updateInputValue();
            return;
        }
        console.warn("Selected time doesn't match min or max value");
    }
    /**
     * @private
     * @param {?} time
     * @return {?}
     */
    set _defaultTime(time) {
        this._timepicker.defaultTime = NgxMatTimepickerAdapter.formatTime(time, {
            locale: this._locale,
            format: this.format
        });
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.value && changes.value.currentValue) {
            this._defaultTime = changes.value.currentValue;
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._unregisterTimepicker();
        this._subsCtrl$.next();
        this._subsCtrl$.complete();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onClick(event) {
        if (!this.disableClick) {
            this._timepicker.open();
            event.stopPropagation();
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this._onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    updateValue(value) {
        this.value = value;
        this._onChange(value);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.value = value;
        if (value) {
            this._defaultTime = value;
        }
    }
    /**
     * @private
     * @param {?} picker
     * @return {?}
     */
    _registerTimepicker(picker) {
        if (picker) {
            this._timepicker = picker;
            this._timepicker.registerInput(this);
            this._timepicker.timeSet
                .pipe(takeUntil(this._subsCtrl$))
                .subscribe((/**
             * @param {?} time
             * @return {?}
             */
            (time) => {
                this.value = time;
                this._onChange(this.value);
                this.onTouched();
                this._defaultTime = this._value;
            }));
        }
        else {
            throw new Error("NgxMatTimepickerComponent is not defined." +
                " Please make sure you passed the timepicker to ngxMatTimepicker directive");
        }
    }
    /**
     * @private
     * @return {?}
     */
    _unregisterTimepicker() {
        if (this._timepicker) {
            this._timepicker.unregisterInput();
        }
    }
    /**
     * @private
     * @return {?}
     */
    _updateInputValue() {
        this._elementRef.nativeElement.value = this.value;
    }
}
NgxMatTimepickerDirective.decorators = [
    { type: Directive, args: [{
                selector: "[ngxMatTimepicker]",
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: NgxMatTimepickerDirective,
                        multi: true
                    }
                ],
                // tslint:disable-next-line:no-host-metadata-property
                host: {
                    "[disabled]": "disabled",
                    "(blur)": "onTouched()",
                },
            },] }
];
/** @nocollapse */
NgxMatTimepickerDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: MatFormField, decorators: [{ type: Optional }, { type: Inject, args: [MatFormField,] }] },
    { type: String, decorators: [{ type: Inject, args: [NGX_MAT_TIMEPICKER_LOCALE,] }] }
];
NgxMatTimepickerDirective.propDecorators = {
    format: [{ type: Input }],
    max: [{ type: Input }],
    min: [{ type: Input }],
    timepicker: [{ type: Input, args: ["ngxMatTimepicker",] }],
    value: [{ type: Input }],
    cdkOverlayOrigin: [{ type: HostBinding, args: ["attr.cdkOverlayOrigin",] }],
    disableClick: [{ type: Input }],
    disabled: [{ type: Input }],
    onClick: [{ type: HostListener, args: ["click", ["$event"],] }],
    updateValue: [{ type: HostListener, args: ["change", ["$event"],] }]
};

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/ngx-mat-timepicker-theme.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxMatTimepickerThemeDirective {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this._element = elementRef.nativeElement;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this.theme) {
            this.setTheme(this.theme);
        }
    }
    /**
     * @private
     * @param {?} theme
     * @return {?}
     */
    setTheme(theme) {
        for (const val in theme) {
            if (theme.hasOwnProperty(val)) {
                if (typeof theme[val] === "string") {
                    for (const prop in theme) {
                        if (theme.hasOwnProperty(prop)) {
                            this._element.style.setProperty(`--${camelCaseToDash(prop)}`, theme[prop]);
                        }
                    }
                    return;
                }
                this.setTheme(theme[val]);
            }
        }
    }
}
NgxMatTimepickerThemeDirective.decorators = [
    { type: Directive, args: [{ selector: "[ngxMatTimepickerTheme]" },] }
];
/** @nocollapse */
NgxMatTimepickerThemeDirective.ctorParameters = () => [
    { type: ElementRef }
];
NgxMatTimepickerThemeDirective.propDecorators = {
    theme: [{ type: Input, args: ["ngxMatTimepickerTheme",] }]
};
/**
 * @param {?} myStr
 * @return {?}
 */
function camelCaseToDash(myStr) {
    return myStr.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/components/ngx-mat-timepicker-hours-face/ngx-mat-timepicker-hours-face.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxMatTimepickerHoursFaceDirective {
    constructor() {
        this.hourChange = new EventEmitter();
        this.hourSelected = new EventEmitter();
        this.hoursList = [];
        this._color = "primary";
        this._format = 24;
    }
    /**
     * @param {?} newValue
     * @return {?}
     */
    set color(newValue) {
        this._color = newValue;
    }
    /**
     * @return {?}
     */
    get color() {
        return this._color;
    }
    /**
     * @param {?} newValue
     * @return {?}
     */
    set format(newValue) {
        this._format = newValue;
        this.hoursList = NgxMatTimepickerUtils.getHours(this._format);
    }
    /**
     * @return {?}
     */
    get format() {
        return this._format;
    }
    /**
     * @param {?} time
     * @return {?}
     */
    onTimeSelected(time) {
        this.hourSelected.next(time);
    }
}
NgxMatTimepickerHoursFaceDirective.decorators = [
    { type: Directive, args: [{
                selector: "[ngxMatTimepickerHoursFace]"
            },] }
];
/** @nocollapse */
NgxMatTimepickerHoursFaceDirective.ctorParameters = () => [];
NgxMatTimepickerHoursFaceDirective.propDecorators = {
    color: [{ type: Input }],
    format: [{ type: Input }],
    hourChange: [{ type: Output }],
    hourSelected: [{ type: Output }],
    maxTime: [{ type: Input }],
    minTime: [{ type: Input }],
    selectedHour: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * Generated from: lib/components/ngx-mat-timepicker-24-hours-face/ngx-mat-timepicker-24-hours-face.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxMatTimepicker24HoursFaceComponent extends NgxMatTimepickerHoursFaceDirective {
    constructor() {
        super();
        this.format = 24;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.hoursList = NgxMatTimepickerUtils.disableHours(this.hoursList, {
            min: this.minTime,
            max: this.maxTime,
            format: this.format
        });
    }
}
NgxMatTimepicker24HoursFaceComponent.decorators = [
    { type: Component, args: [{
                selector: "ngx-mat-timepicker-24-hours-face",
                template: "<ngx-mat-timepicker-face [color]=\"color\"\n                     [selectedTime]=\"selectedHour\"\n                     [faceTime]=\"hoursList\"\n                     [format]=\"format\"\n                     (timeChange)=\"hourChange.next($event)\"\n                     (timeSelected)=\"onTimeSelected($event)\"></ngx-mat-timepicker-face>\n",
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];
/** @nocollapse */
NgxMatTimepicker24HoursFaceComponent.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * Generated from: lib/components/ngx-mat-timepicker-12-hours-face/ngx-mat-timepicker-12-hours-face.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxMatTimepicker12HoursFaceComponent extends NgxMatTimepickerHoursFaceDirective {
    constructor() {
        super();
        this.format = 12;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.period && changes.period.currentValue) {
            this.hoursList = NgxMatTimepickerUtils.disableHours(this.hoursList, {
                min: this.minTime,
                max: this.maxTime,
                format: this.format,
                period: this.period
            });
        }
    }
}
NgxMatTimepicker12HoursFaceComponent.decorators = [
    { type: Component, args: [{
                selector: "ngx-mat-timepicker-12-hours-face",
                template: "<ngx-mat-timepicker-face [color]=\"color\"\n                     [selectedTime]=\"selectedHour\"\n                     [faceTime]=\"hoursList\"\n                     (timeChange)=\"hourChange.next($event)\"\n                     (timeSelected)=\"onTimeSelected($event)\"></ngx-mat-timepicker-face>\n",
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];
/** @nocollapse */
NgxMatTimepicker12HoursFaceComponent.ctorParameters = () => [];
NgxMatTimepicker12HoursFaceComponent.propDecorators = {
    period: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * Generated from: lib/components/ngx-mat-timepicker-minutes-face/ngx-mat-timepicker-minutes-face.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxMatTimepickerMinutesFaceComponent {
    constructor() {
        this.minuteChange = new EventEmitter();
        this.minutesList = [];
        this.timeUnit = NgxMatTimepickerUnits;
        this._color = "primary";
    }
    /**
     * @param {?} newValue
     * @return {?}
     */
    set color(newValue) {
        this._color = newValue;
    }
    /**
     * @return {?}
     */
    get color() {
        return this._color;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.period && changes.period.currentValue) {
            /** @type {?} */
            const minutes = NgxMatTimepickerUtils.getMinutes(this.minutesGap);
            this.minutesList = NgxMatTimepickerUtils.disableMinutes(minutes, this.selectedHour, {
                min: this.minTime,
                max: this.maxTime,
                format: this.format,
                period: this.period
            });
        }
    }
}
NgxMatTimepickerMinutesFaceComponent.decorators = [
    { type: Component, args: [{
                selector: "ngx-mat-timepicker-minutes-face",
                template: "<ngx-mat-timepicker-face [color]=\"color\"\n                     [faceTime]=\"minutesList\"\n                     [selectedTime]=\"selectedMinute\"\n                     [minutesGap]=\"minutesGap\"\n                     (timeChange)=\"minuteChange.next($event)\"\n                     [unit]=\"timeUnit.MINUTE\"></ngx-mat-timepicker-face>\n"
            }] }
];
/** @nocollapse */
NgxMatTimepickerMinutesFaceComponent.ctorParameters = () => [];
NgxMatTimepickerMinutesFaceComponent.propDecorators = {
    color: [{ type: Input }],
    format: [{ type: Input }],
    maxTime: [{ type: Input }],
    minTime: [{ type: Input }],
    minuteChange: [{ type: Output }],
    minutesGap: [{ type: Input }],
    period: [{ type: Input }],
    selectedHour: [{ type: Input }],
    selectedMinute: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * Generated from: lib/components/ngx-mat-timepicker-face/ngx-mat-timepicker-face.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} angle
 * @param {?} step
 * @return {?}
 */
function roundAngle(angle, step) {
    return Math.round(angle / step) * step;
}
/**
 * @param {?} x0
 * @param {?} y0
 * @param {?} x
 * @param {?} y
 * @param {?} currentAngle
 * @return {?}
 */
function countAngleByCords(x0, y0, x, y, currentAngle) {
    if (y > y0 && x >= x0) { // II quarter
        return 180 - currentAngle;
    }
    else if (y > y0 && x < x0) { // III quarter
        return 180 + currentAngle;
    }
    else if (y < y0 && x < x0) { // IV quarter
        return 360 - currentAngle;
    }
    else { // I quarter
        return currentAngle;
    }
}
/** @type {?} */
const CLOCK_HAND_STYLES = {
    small: {
        height: "75px",
        top: "calc(50% - 75px)"
    },
    large: {
        height: "103px",
        top: "calc(50% - 103px)"
    }
};
class NgxMatTimepickerFaceComponent {
    constructor() {
        this.color = "primary";
        this.innerClockFaceSize = 85;
        this.timeChange = new EventEmitter();
        this.timeSelected = new EventEmitter();
        this.timeUnit = NgxMatTimepickerUnits;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this._setClockHandPosition();
        this._addTouchEvents();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const faceTimeChanges = changes.faceTime;
        /** @type {?} */
        const selectedTimeChanges = changes.selectedTime;
        if ((faceTimeChanges && faceTimeChanges.currentValue)
            && (selectedTimeChanges && selectedTimeChanges.currentValue)) {
            /* Set time according to passed an input value */
            this.selectedTime = this.faceTime.find((/**
             * @param {?} time
             * @return {?}
             */
            time => time.time === this.selectedTime.time));
        }
        if (selectedTimeChanges && selectedTimeChanges.currentValue) {
            this._setClockHandPosition();
        }
        if (faceTimeChanges && faceTimeChanges.currentValue) {
            // To avoid an error ExpressionChangedAfterItHasBeenCheckedError
            setTimeout((/**
             * @return {?}
             */
            () => this._selectAvailableTime()));
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._removeTouchEvents();
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onMousedown(e) {
        e.preventDefault();
        this._isStarted = true;
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onMouseup(e) {
        e.preventDefault();
        this._isStarted = false;
    }
    /**
     * @param {?} e
     * @return {?}
     */
    selectTime(e) {
        if (!this._isStarted && (e instanceof MouseEvent && e.type !== "click")) {
            return;
        }
        /** @type {?} */
        const clockFaceCords = this.clockFace.nativeElement.getBoundingClientRect();
        /* Get x0 and y0 of the circle */
        /** @type {?} */
        const centerX = clockFaceCords.left + clockFaceCords.width / 2;
        /** @type {?} */
        const centerY = clockFaceCords.top + clockFaceCords.height / 2;
        /* Counting the arctangent and convert it to from radian to deg */
        /** @type {?} */
        const arctangent = Math.atan(Math.abs(e.clientX - centerX) / Math.abs(e.clientY - centerY)) * 180 / Math.PI;
        /* Get angle according to quadrant */
        /** @type {?} */
        const circleAngle = countAngleByCords(centerX, centerY, e.clientX, e.clientY, arctangent);
        /* Check if selected time from the inner clock face (24 hours format only) */
        /** @type {?} */
        const isInnerClockChosen = this.format && this._isInnerClockFace(centerX, centerY, e.clientX, e.clientY);
        /* Round angle according to angle step */
        /** @type {?} */
        const angleStep = this.unit === NgxMatTimepickerUnits.MINUTE ? (6 * (this.minutesGap || 1)) : 30;
        /** @type {?} */
        const roundedAngle = roundAngle(circleAngle, angleStep);
        /** @type {?} */
        const angle = (roundedAngle || 360) + (isInnerClockChosen ? 360 : 0);
        /** @type {?} */
        const selectedTime = this.faceTime.find((/**
         * @param {?} val
         * @return {?}
         */
        val => val.angle === angle));
        if (selectedTime && !selectedTime.disabled) {
            this.timeChange.next(selectedTime);
            /* To let know whether user ended interaction with clock face */
            if (!this._isStarted) {
                this.timeSelected.next(selectedTime.time);
            }
        }
    }
    /**
     * @param {?} _item_
     * @param {?} time
     * @return {?}
     */
    trackByTime(_item_, time) {
        return time.time;
    }
    /**
     * @private
     * @return {?}
     */
    _addTouchEvents() {
        this._touchStartHandler = this.onMousedown.bind(this);
        this._touchEndHandler = this.onMouseup.bind(this);
        this.clockFace.nativeElement.addEventListener("touchstart", this._touchStartHandler);
        this.clockFace.nativeElement.addEventListener("touchend", this._touchEndHandler);
    }
    /**
     * @private
     * @return {?}
     */
    _decreaseClockHand() {
        this.clockHand.nativeElement.style.height = CLOCK_HAND_STYLES.small.height;
        this.clockHand.nativeElement.style.top = CLOCK_HAND_STYLES.small.top;
    }
    /**
     * @private
     * @return {?}
     */
    _increaseClockHand() {
        this.clockHand.nativeElement.style.height = CLOCK_HAND_STYLES.large.height;
        this.clockHand.nativeElement.style.top = CLOCK_HAND_STYLES.large.top;
    }
    /**
     * @private
     * @param {?} x0
     * @param {?} y0
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    _isInnerClockFace(x0, y0, x, y) {
        /* Detect whether time from the inner clock face or not (24 format only) */
        return Math.sqrt(Math.pow(x - x0, 2) + Math.pow(y - y0, 2)) < this.innerClockFaceSize;
    }
    /**
     * @private
     * @return {?}
     */
    _removeTouchEvents() {
        this.clockFace.nativeElement.removeEventListener("touchstart", this._touchStartHandler);
        this.clockFace.nativeElement.removeEventListener("touchend", this._touchEndHandler);
    }
    /**
     * @private
     * @return {?}
     */
    _selectAvailableTime() {
        /** @type {?} */
        const currentTime = this.faceTime.find((/**
         * @param {?} time
         * @return {?}
         */
        time => this.selectedTime.time === time.time));
        this.isClockFaceDisabled = this.faceTime.every((/**
         * @param {?} time
         * @return {?}
         */
        time => time.disabled));
        if ((currentTime && currentTime.disabled) && !this.isClockFaceDisabled) {
            /** @type {?} */
            const availableTime = this.faceTime.find((/**
             * @param {?} time
             * @return {?}
             */
            time => !time.disabled));
            this.timeChange.next(availableTime);
        }
    }
    /**
     * @private
     * @return {?}
     */
    _setClockHandPosition() {
        if (this.format === 24) {
            if (this.selectedTime.time > 12 || this.selectedTime.time === 0) {
                this._decreaseClockHand();
            }
            else {
                this._increaseClockHand();
            }
        }
        this.clockHand.nativeElement.style.transform = `rotate(${this.selectedTime.angle}deg)`;
    }
}
NgxMatTimepickerFaceComponent.decorators = [
    { type: Component, args: [{
                selector: "ngx-mat-timepicker-face",
                template: "<ng-template #hourButton\n             let-time>\n    <button mat-mini-fab\n            class=\"mat-elevation-z0\"\n            [color]=\"(time.time | activeHour: selectedTime?.time : isClockFaceDisabled) ? color : undefined\"\n            [ngStyle]=\"{'transform': 'rotateZ(-'+ time.angle +'deg)'}\"\n            [disabled]=\"time.disabled\">\n        {{time.time | timeLocalizer: timeUnit.HOUR}}\n    </button>\n</ng-template>\n<div class=\"clock-face\"\n     #clockFace>\n    <div *ngIf=\"unit !== timeUnit.MINUTE;else minutesFace\"\n         class=\"clock-face__container\">\n        <div class=\"clock-face__number clock-face__number--outer\"\n             [ngStyle]=\"{'transform': 'rotateZ('+ time.angle +'deg)'}\"\n             *ngFor=\"let time of faceTime | slice: 0 : 12; trackBy: trackByTime\">\n            <ng-content *ngTemplateOutlet=\"hourButton; context: {$implicit: time}\"></ng-content>\n        </div>\n        <div class=\"clock-face__inner\"\n             *ngIf=\"faceTime.length > 12\">\n            <div class=\"clock-face__number clock-face__number--inner\"\n                 [style.top]=\"'calc(50% - ' + innerClockFaceSize + 'px)'\"\n                 [ngStyle]=\"{'transform': 'rotateZ('+ time.angle +'deg)'}\"\n                 [style.height.px]=\"innerClockFaceSize\"\n                 *ngFor=\"let time of faceTime | slice: 12 : 24; trackBy: trackByTime\">\n                <ng-content *ngTemplateOutlet=\"hourButton; context: {$implicit: time}\"></ng-content>\n            </div>\n        </div>\n    </div>\n    <mat-toolbar class=\"clock-face__clock-hand\"\n                 [color]=\"color\"\n                 [ngClass]=\"{'clock-face__clock-hand_minute': unit === timeUnit.MINUTE}\"\n                 #clockHand\n                 [hidden]=\"isClockFaceDisabled\">\n        <button mat-mini-fab\n                *ngIf=\"unit === timeUnit.MINUTE\"\n                [color]=\"color\">\n            <span class=\"clock-face__clock-hand_minute_dot\"></span>\n        </button>\n    </mat-toolbar>\n    <mat-toolbar class=\"clock-face__center\"\n                 [color]=\"color\"></mat-toolbar>\n</div>\n<ng-template #minutesFace>\n    <div class=\"clock-face__container\">\n        <div class=\"clock-face__number clock-face__number--outer\"\n             [ngStyle]=\"{'transform': 'rotateZ('+ time.angle +'deg)'}\"\n             *ngFor=\"let time of faceTime; trackBy: trackByTime\">\n            <button mat-mini-fab\n                    class=\"mat-elevation-z0\"\n                    [disableRipple]=\"time.time % minutesGap !== 0\"\n                    [color]=\"(time.time | activeMinute: selectedTime?.time:minutesGap:isClockFaceDisabled) ? color : undefined\"\n                    [ngStyle]=\"{'transform': 'rotateZ(-'+ time.angle +'deg)'}\">\n                {{time.time | minutesFormatter: minutesGap | timeLocalizer: timeUnit.MINUTE}}\n            </button>\n        </div>\n    </div>\n</ng-template>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".clock-face{width:290px;height:290px;border-radius:50%;position:relative;display:flex;justify-content:center;box-sizing:border-box;background-color:rgba(200,200,200,.5)!important}.clock-face__inner{position:absolute;top:0;left:0;width:100%;height:100%}.clock-face [mat-mini-fab]{box-shadow:none}.clock-face [mat-mini-fab]:not(.mat-primary):not(.mat-accent):not(.mat-warn){background:0 0}.clock-face__container{margin-left:-2px}.clock-face__number{position:absolute;transform-origin:25px 100%;width:50px;text-align:center;z-index:2;top:calc(50% - 125px);left:calc(50% - 25px)}.clock-face__number--outer{height:calc(290px / 2 - 20px)}.clock-face__number--outer>span{font-size:16px}.clock-face__number--inner>span{font-size:14px}.clock-face__clock-hand{height:103px;width:2px;padding:0;transform-origin:1px 100%;position:absolute;top:calc(50% - 103px);z-index:1}.clock-face__center{width:8px;height:8px;padding:0;position:absolute;border-radius:50%;top:50%;left:50%;margin:-4px}.clock-face__clock-hand_minute>button{position:absolute;top:-22px;left:calc(50% - 20px);box-sizing:content-box;display:flex;justify-content:center;align-items:center}.clock-face__clock-hand_minute>button .clock-face__clock-hand_minute_dot{display:block;width:4px;height:4px;background:#fff;border-radius:50%}@media (max-device-width:1023px) and (orientation:landscape){.clock-face{width:250px;height:250px}}@media screen and (max-width:360px){.clock-face{width:250px;height:250px}}"]
            }] }
];
NgxMatTimepickerFaceComponent.propDecorators = {
    clockFace: [{ type: ViewChild, args: ["clockFace", { static: true },] }],
    clockHand: [{ type: ViewChild, args: ["clockHand", { static: true, read: ElementRef },] }],
    color: [{ type: Input }],
    faceTime: [{ type: Input }],
    format: [{ type: Input }],
    minutesGap: [{ type: Input }],
    selectedTime: [{ type: Input }],
    timeChange: [{ type: Output }],
    timeSelected: [{ type: Output }],
    unit: [{ type: Input }],
    onMousedown: [{ type: HostListener, args: ["mousedown", ["$event"],] }],
    onMouseup: [{ type: HostListener, args: ["mouseup", ["$event"],] }],
    selectTime: [{ type: HostListener, args: ["click", ["$event"],] }, { type: HostListener, args: ["touchmove", ["$event.changedTouches[0]"],] }, { type: HostListener, args: ["touchend", ["$event.changedTouches[0]"],] }, { type: HostListener, args: ["mousemove", ["$event"],] }]
};

/**
 * @fileoverview added by tsickle
 * Generated from: lib/components/ngx-mat-timepicker-dial/ngx-mat-timepicker-dial.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxMatTimepickerDialComponent {
    /**
     * @param {?} _locale
     */
    constructor(_locale) {
        this._locale = _locale;
        this.hourChanged = new EventEmitter();
        this.meridiems = Info.meridiems({ locale: this._locale });
        this.minuteChanged = new EventEmitter();
        this.periodChanged = new EventEmitter();
        this.timeUnit = NgxMatTimepickerUnits;
        this.timeUnitChanged = new EventEmitter();
        this._color = "primary";
    }
    /**
     * @param {?} newValue
     * @return {?}
     */
    set color(newValue) {
        this._color = newValue;
    }
    /**
     * @return {?}
     */
    get color() {
        return this._color;
    }
    /**
     * @param {?} hour
     * @return {?}
     */
    changeHour(hour) {
        this.hourChanged.next(hour);
    }
    /**
     * @param {?} minute
     * @return {?}
     */
    changeMinute(minute) {
        this.minuteChanged.next(minute);
    }
    /**
     * @param {?} period
     * @return {?}
     */
    changePeriod(period) {
        this.periodChanged.next(period);
    }
    /**
     * @param {?} unit
     * @return {?}
     */
    changeTimeUnit(unit) {
        this.timeUnitChanged.next(unit);
    }
    /**
     * @return {?}
     */
    hideHint() {
        this.isHintVisible = false;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const periodChanged = changes.period && changes.period.currentValue;
        if (periodChanged || changes.format && changes.format.currentValue) {
            /** @type {?} */
            const hours = NgxMatTimepickerUtils.getHours(this.format);
            this.hours = NgxMatTimepickerUtils.disableHours(hours, {
                min: this.minTime,
                max: this.maxTime,
                format: this.format,
                period: this.period
            });
        }
        if (periodChanged || changes.hour && changes.hour.currentValue) {
            /** @type {?} */
            const minutes = NgxMatTimepickerUtils.getMinutes(this.minutesGap);
            this.minutes = NgxMatTimepickerUtils.disableMinutes(minutes, +this.hour, {
                min: this.minTime,
                max: this.maxTime,
                format: this.format,
                period: this.period
            });
        }
    }
    /**
     * @return {?}
     */
    showHint() {
        this.isHintVisible = true;
    }
}
NgxMatTimepickerDialComponent.decorators = [
    { type: Component, args: [{
                selector: "ngx-mat-timepicker-dial",
                template: "<div class=\"timepicker-dial\">\n    <div class=\"timepicker-dial__container\">\n        <div class=\"timepicker-dial__time\">\n            <ngx-mat-timepicker-dial-control [timeList]=\"hours\"\n                                         [time]=\"hour\"\n                                         [timeUnit]=\"timeUnit.HOUR\"\n                                         [isActive]=\"activeTimeUnit === timeUnit.HOUR\"\n                                         [isEditable]=\"isEditable\"\n                                         (timeUnitChanged)=\"changeTimeUnit($event)\"\n                                         (timeChanged)=\"changeHour($event)\"\n                                         (focused)=\"showHint()\"\n                                         (unfocused)=\"hideHint()\">\n\n            </ngx-mat-timepicker-dial-control>\n            <span>:</span>\n            <ngx-mat-timepicker-dial-control [timeList]=\"minutes\"\n                                         [time]=\"minute\"\n                                         [timeUnit]=\"timeUnit.MINUTE\"\n                                         [isActive]=\"activeTimeUnit === timeUnit.MINUTE\"\n                                         [isEditable]=\"isEditable\"\n                                         [minutesGap]=\"minutesGap\"\n                                         [disabled]=\"hoursOnly\"\n                                         (timeUnitChanged)=\"changeTimeUnit($event)\"\n                                         (timeChanged)=\"changeMinute($event)\"\n                                         (focused)=\"showHint()\"\n                                         (unfocused)=\"hideHint()\">\n\n            </ngx-mat-timepicker-dial-control>\n        </div>\n        <ngx-mat-timepicker-period class=\"timepicker-dial__period\"\n                                   *ngIf=\"format !== 24\"\n                                   [selectedPeriod]=\"period\"\n                                   [activeTimeUnit]=\"activeTimeUnit\"\n                                   [maxTime]=\"maxTime\"\n                                   [minTime]=\"minTime\"\n                                   [format]=\"format\"\n                                   [hours]=\"hours\"\n                                   [minutes]=\"minutes\"\n                                   [selectedHour]=\"hour\"\n                                   [meridiems]=\"meridiems\"\n                                   (periodChanged)=\"changePeriod($event)\"></ngx-mat-timepicker-period>\n    </div>\n    <div *ngIf=\"isEditable || editableHintTmpl\"\n         [ngClass]=\"{'timepicker-dial__hint-container--hidden': !isHintVisible}\">\n        <ng-container *ngTemplateOutlet=\"editableHintTmpl ? editableHintTmpl : editableHintDefault\"></ng-container>\n        <ng-template #editableHintDefault>\n            <small class=\"timepicker-dial__hint\"> * use arrows (<span>&#8645;</span>) to change the time</small>\n        </ng-template>\n    </div>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".timepicker-dial{text-align:center}.timepicker-dial__container{display:flex;align-items:center;justify-content:center;-webkit-tap-highlight-color:transparent}.timepicker-dial__time{display:flex;align-items:baseline;line-height:normal;font-size:50px}.timepicker-dial__period{display:block;margin-left:10px}.timepicker-dial__hint-container--hidden{visibility:hidden}.timepicker-dial__hint{display:inline-block;font-size:10px}.timepicker-dial__hint span{font-size:14px}"]
            }] }
];
/** @nocollapse */
NgxMatTimepickerDialComponent.ctorParameters = () => [
    { type: String, decorators: [{ type: Inject, args: [NGX_MAT_TIMEPICKER_LOCALE,] }] }
];
NgxMatTimepickerDialComponent.propDecorators = {
    activeTimeUnit: [{ type: Input }],
    color: [{ type: Input }],
    editableHintTmpl: [{ type: Input }],
    format: [{ type: Input }],
    hour: [{ type: Input }],
    hourChanged: [{ type: Output }],
    hoursOnly: [{ type: Input }],
    isEditable: [{ type: Input }],
    maxTime: [{ type: Input }],
    minTime: [{ type: Input }],
    minute: [{ type: Input }],
    minuteChanged: [{ type: Output }],
    minutesGap: [{ type: Input }],
    period: [{ type: Input }],
    periodChanged: [{ type: Output }],
    timeUnitChanged: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * Generated from: lib/models/ngx-mat-timepicker-measures.enum.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const NgxMatTimepickerMeasure = {
    hour: "hour",
    minute: "minute",
};

/**
 * @fileoverview added by tsickle
 * Generated from: lib/pipes/ngx-mat-timepicker-parser.pipe.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxMatTimepickerParserPipe {
    /**
     * @param {?} _locale
     */
    constructor(_locale) {
        this._locale = _locale;
        this._numberingSystem = (/** @type {?} */ (DateTime.local().setLocale(this._locale).resolvedLocaleOpts().numberingSystem));
    }
    /**
     * @param {?} time
     * @param {?=} timeUnit
     * @return {?}
     */
    transform(time, timeUnit = NgxMatTimepickerUnits.HOUR) {
        if (time == null || time === "") {
            return "";
        }
        if (!isNaN(+time)) {
            return `${time}`;
        }
        if (timeUnit === NgxMatTimepickerUnits.MINUTE) {
            return this._parseTime(time, "mm", NgxMatTimepickerMeasure.minute).toString();
        }
        return this._parseTime(time, "HH", NgxMatTimepickerMeasure.hour).toString();
    }
    /**
     * @private
     * @param {?} time
     * @param {?} format
     * @param {?} timeMeasure
     * @return {?}
     */
    _parseTime(time, format, timeMeasure) {
        /** @type {?} */
        const parsedTime = DateTime.fromFormat(String(time), format, { numberingSystem: this._numberingSystem })[timeMeasure];
        if (!isNaN(parsedTime)) {
            return parsedTime;
        }
        throw new Error(`Cannot parse time - ${time}`);
    }
}
NgxMatTimepickerParserPipe.decorators = [
    { type: Pipe, args: [{
                name: "ngxMatTimepickerParser"
            },] },
    { type: Injectable }
];
/** @nocollapse */
NgxMatTimepickerParserPipe.ctorParameters = () => [
    { type: String, decorators: [{ type: Inject, args: [NGX_MAT_TIMEPICKER_LOCALE,] }] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: lib/components/ngx-mat-timepicker-dial-control/ngx-mat-timepicker-dial-control.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function retainSelection() {
    this.selectionStart = this.selectionEnd;
}
class NgxMatTimepickerDialControlComponent {
    /**
     * @param {?} _elRef
     * @param {?} _timeParserPipe
     */
    constructor(_elRef, _timeParserPipe) {
        this._elRef = _elRef;
        this._timeParserPipe = _timeParserPipe;
        this.focused = new EventEmitter();
        this.timeChanged = new EventEmitter();
        this.timeUnitChanged = new EventEmitter();
        this.unfocused = new EventEmitter();
    }
    /**
     * @private
     * @return {?}
     */
    get _selectedTime() {
        if (!!this.time) {
            return this.timeList.find((/**
             * @param {?} t
             * @return {?}
             */
            t => t.time === +this.time));
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    changeTimeByKeyboard(e) {
        /** @type {?} */
        const char = String.fromCharCode(e.keyCode);
        if (isTimeDisabledToChange(this.time, char, this.timeList)) {
            e.preventDefault();
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this._elRef.nativeElement.querySelector("input").addEventListener("select", retainSelection, false);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._elRef.nativeElement.querySelector("input").removeEventListener("select", retainSelection);
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onKeydown(e) {
        if (!NgxMatTimepickerUtils.isDigit(e)) {
            e.preventDefault();
        }
        else {
            this._changeTimeByArrow(e.keyCode);
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    onModelChange(value) {
        this.time = this._timeParserPipe.transform(value, this.timeUnit);
    }
    /**
     * @param {?} event
     * @param {?} unit
     * @return {?}
     */
    saveTimeAndChangeTimeUnit(event, unit) {
        event.preventDefault();
        this.previousTime = this.time;
        this.timeUnitChanged.next(unit);
        this.focused.next();
    }
    /**
     * @return {?}
     */
    updateTime() {
        if (this._selectedTime) {
            this.timeChanged.next(this._selectedTime);
            this.previousTime = this._selectedTime.time;
        }
    }
    /**
     * @private
     * @param {?} amount
     * @return {?}
     */
    _addTime(amount) {
        return `0${+this.time + amount}`.substr(-2);
    }
    /**
     * @private
     * @param {?} keyCode
     * @return {?}
     */
    _changeTimeByArrow(keyCode) {
        /** @type {?} */
        let time;
        // arrow up
        if (keyCode === 38) {
            time = this._addTime(this.minutesGap || 1);
        }
        // arrow down
        else if (keyCode === 40) {
            time = this._addTime(-1 * (this.minutesGap || 1));
        }
        if (!isTimeUnavailable(time, this.timeList)) {
            this.time = time;
            this.updateTime();
        }
    }
}
NgxMatTimepickerDialControlComponent.decorators = [
    { type: Component, args: [{
                selector: "ngx-mat-timepicker-dial-control",
                template: "<input class=\"timepicker-dial__control timepicker-dial__item\"\n       [ngClass]=\"{'active': isActive}\"\n       [ngModel]=\"time | timeLocalizer: timeUnit: true\"\n       (ngModelChange)=\"time = $event\"\n       [disabled]=\"disabled\"\n       (input)=\"updateTime()\"\n       (focus)=\"saveTimeAndChangeTimeUnit($event, timeUnit)\"\n       readonly\n       [ngxMatTimepickerAutofocus]=\"isActive\"\n       *ngIf=\"!isEditable;else editableTemplate\">\n\n<ng-template #editableTemplate>\n    <input class=\"timepicker-dial__control timepicker-dial__item timepicker-dial__control_editable\"\n           [ngClass]=\"{'active': isActive}\"\n           [ngModel]=\"time | ngxMatTimepickerParser: timeUnit | timeLocalizer: timeUnit : true\"\n           (ngModelChange)=\"onModelChange($event)\"\n           [disabled]=\"disabled\"\n           (input)=\"updateTime()\"\n           (focus)=\"saveTimeAndChangeTimeUnit($event, timeUnit)\"\n           [ngxMatTimepickerAutofocus]=\"isActive\"\n           (keydown)=\"onKeydown($event)\"\n           (keypress)=\"changeTimeByKeyboard($event)\">\n</ng-template>\n",
                providers: [NgxMatTimepickerParserPipe],
                styles: [".timepicker-dial__control{border:none;background-color:transparent;font-size:50px;width:60px;padding:0;border-radius:3px;text-align:center;color:inherit}.timepicker-dial__control:focus{outline:0;background-color:rgba(0,0,0,.1)}.timepicker-dial__control:disabled{cursor:default}"]
            }] }
];
/** @nocollapse */
NgxMatTimepickerDialControlComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: NgxMatTimepickerParserPipe }
];
NgxMatTimepickerDialControlComponent.propDecorators = {
    disabled: [{ type: Input }],
    focused: [{ type: Output }],
    isActive: [{ type: Input }],
    isEditable: [{ type: Input }],
    minutesGap: [{ type: Input }],
    time: [{ type: Input }],
    timeChanged: [{ type: Output }],
    timeList: [{ type: Input }],
    timeUnit: [{ type: Input }],
    timeUnitChanged: [{ type: Output }],
    unfocused: [{ type: Output }]
};
/**
 * @param {?} currentTime
 * @param {?} nextTime
 * @param {?} timeList
 * @return {?}
 */
function isTimeDisabledToChange(currentTime, nextTime, timeList) {
    /** @type {?} */
    const isNumber = /\d/.test(nextTime);
    if (isNumber) {
        /** @type {?} */
        const time = currentTime + nextTime;
        return isTimeUnavailable(time, timeList);
    }
}
/**
 * @param {?} time
 * @param {?} timeList
 * @return {?}
 */
function isTimeUnavailable(time, timeList) {
    /** @type {?} */
    const selectedTime = timeList.find((/**
     * @param {?} value
     * @return {?}
     */
    value => value.time === +time));
    return !selectedTime || (selectedTime && selectedTime.disabled);
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/components/ngx-mat-timepicker-period/ngx-mat-timepicker-period.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxMatTimepickerPeriodComponent {
    constructor() {
        this.isPeriodAvailable = true;
        this.periodChanged = new EventEmitter();
        this.timePeriod = NgxMatTimepickerPeriods;
    }
    /**
     * @return {?}
     */
    animationDone() {
        this.isPeriodAvailable = true;
    }
    /**
     * @param {?} period
     * @return {?}
     */
    changePeriod(period) {
        this.isPeriodAvailable = this._isSwitchPeriodAvailable(period);
        if (this.isPeriodAvailable) {
            this.periodChanged.next(period);
        }
    }
    /**
     * @private
     * @param {?} period
     * @return {?}
     */
    _getDisabledTimeByPeriod(period) {
        switch (this.activeTimeUnit) {
            case NgxMatTimepickerUnits.HOUR:
                return NgxMatTimepickerUtils.disableHours(this.hours, {
                    min: this.minTime,
                    max: this.maxTime,
                    format: this.format,
                    period
                });
            case NgxMatTimepickerUnits.MINUTE:
                return NgxMatTimepickerUtils.disableMinutes(this.minutes, +this.selectedHour, {
                    min: this.minTime,
                    max: this.maxTime,
                    format: this.format,
                    period
                });
            default:
                throw new Error("no such NgxMatTimepickerUnits");
        }
    }
    /**
     * @private
     * @param {?} period
     * @return {?}
     */
    _isSwitchPeriodAvailable(period) {
        /** @type {?} */
        const time = this._getDisabledTimeByPeriod(period);
        return !time.every((/**
         * @param {?} t
         * @return {?}
         */
        t => t.disabled));
    }
}
NgxMatTimepickerPeriodComponent.decorators = [
    { type: Component, args: [{
                selector: "ngx-mat-timepicker-period",
                template: "<div class=\"timepicker-period\">\n    <button class=\"timepicker-dial__item timepicker-period__btn\"\n            [ngClass]=\"{'active': selectedPeriod === timePeriod.AM}\"\n            (click)=\"changePeriod(timePeriod.AM)\"\n            type=\"button\">{{meridiems[0]}}</button>\n    <button class=\"timepicker-dial__item timepicker-period__btn\"\n            [ngClass]=\"{'active': selectedPeriod === timePeriod.PM}\"\n            (click)=\"changePeriod(timePeriod.PM)\"\n            type=\"button\">{{meridiems[1]}}</button>\n    <div class=\"timepicker-period__warning\"\n         [@scaleInOut]\n         (@scaleInOut.done)=\"animationDone()\"\n         *ngIf=\"!isPeriodAvailable\">\n        <p>Current time would be invalid in this period.</p>\n    </div>\n</div>\n",
                animations: [
                    trigger("scaleInOut", [
                        transition(":enter", [
                            style({ transform: "scale(0)" }),
                            animate(".2s", style({ transform: "scale(1)" })),
                            sequence([
                                animate("3s", style({ opacity: 1 })),
                                animate(".3s", style({ opacity: 0 }))
                            ])
                        ])
                    ])
                ],
                styles: [".timepicker-period{display:flex;flex-direction:column;position:relative}.timepicker-period__btn{opacity:.5;padding:1px 3px;border:0;background-color:transparent;font-size:18px;font-weight:500;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;outline:0;border-radius:3px;transition:background-color .5s;color:inherit}.timepicker-period__btn.active{opacity:1}.timepicker-period__btn:focus{background-color:rgba(0,0,0,.07)}.timepicker-period__warning{padding:5px 10px;border-radius:3px;background-color:rgba(0,0,0,.55);position:absolute;width:200px;left:-20px;top:40px}.timepicker-period__warning>p{margin:0;font-size:12px}"]
            }] }
];
NgxMatTimepickerPeriodComponent.propDecorators = {
    activeTimeUnit: [{ type: Input }],
    format: [{ type: Input }],
    hours: [{ type: Input }],
    maxTime: [{ type: Input }],
    meridiems: [{ type: Input }],
    minTime: [{ type: Input }],
    minutes: [{ type: Input }],
    periodChanged: [{ type: Output }],
    selectedHour: [{ type: Input }],
    selectedPeriod: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * Generated from: lib/pipes/ngx-mat-timepicker-time-formatter.pipe.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxMatTimepickerTimeFormatterPipe {
    /**
     * @param {?} time
     * @param {?} timeUnit
     * @return {?}
     */
    transform(time, timeUnit) {
        if (time == null || time === '') {
            return time;
        }
        switch (timeUnit) {
            case NgxMatTimepickerUnits.HOUR:
                return DateTime.fromObject({ hour: +time }).toFormat("HH");
            case NgxMatTimepickerUnits.MINUTE:
                return DateTime.fromObject({ minute: +time }).toFormat("mm");
            default:
                throw new Error("no such time unit");
        }
    }
}
NgxMatTimepickerTimeFormatterPipe.decorators = [
    { type: Pipe, args: [{
                name: "timeFormatter"
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: lib/pipes/ngx-mat-timepicker-minutes-formatter.pipe.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxMatTimepickerMinutesFormatterPipe {
    /**
     * @param {?} minute
     * @param {?=} gap
     * @return {?}
     */
    transform(minute, gap = 5) {
        if (!minute) {
            return minute;
        }
        return minute % gap === 0 ? minute : '';
    }
}
NgxMatTimepickerMinutesFormatterPipe.decorators = [
    { type: Pipe, args: [{
                name: 'minutesFormatter'
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/ngx-mat-timepicker-autofocus.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxMatTimepickerAutofocusDirective {
    /**
     * @param {?} _element
     * @param {?} document
     */
    constructor(_element, document) {
        this._element = _element;
        this.document = document;
        this._activeElement = this.document.activeElement;
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        if (this.isFocusActive) {
            // To avoid ExpressionChangedAfterItHasBeenCheckedError;
            setTimeout((/**
             * @return {?}
             */
            () => this._element.nativeElement.focus({ preventScroll: true })));
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        // To avoid ExpressionChangedAfterItHasBeenCheckedError;
        setTimeout((/**
         * @return {?}
         */
        () => this._activeElement.focus({ preventScroll: true })));
    }
}
NgxMatTimepickerAutofocusDirective.decorators = [
    { type: Directive, args: [{
                selector: "[ngxMatTimepickerAutofocus]"
            },] }
];
/** @nocollapse */
NgxMatTimepickerAutofocusDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] }
];
NgxMatTimepickerAutofocusDirective.propDecorators = {
    isFocusActive: [{ type: Input, args: ["ngxMatTimepickerAutofocus",] }]
};

/**
 * @fileoverview added by tsickle
 * Generated from: lib/components/ngx-mat-timepicker-field/ngx-mat-timepicker-control/ngx-mat-timepicker-control.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} currentTime
 * @param {?} nextTime
 * @return {?}
 */
function concatTime(currentTime, nextTime) {
    /** @type {?} */
    const isNumber = /\d/.test(nextTime);
    if (isNumber) {
        /** @type {?} */
        const time = currentTime + nextTime;
        return +time;
    }
}
class NgxMatTimepickerControlComponent {
    /**
     * @param {?} _timeParser
     */
    constructor(_timeParser) {
        this._timeParser = _timeParser;
        this.id = NgxMatTimepickerControlComponent.nextId++;
        this.timeChanged = new EventEmitter();
        this._color = "primary";
        this._floatLabel = "never";
    }
    /**
     * @param {?} newValue
     * @return {?}
     */
    set color(newValue) {
        this._color = newValue;
    }
    /**
     * @return {?}
     */
    get color() {
        return this._color;
    }
    /**
     * @param {?} newValue
     * @return {?}
     */
    set floatLabel(newValue) {
        this._floatLabel = newValue;
    }
    /**
     * @return {?}
     */
    get floatLabel() {
        return this._floatLabel;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    changeTime(event) {
        event.stopPropagation();
        /** @type {?} */
        const char = String.fromCharCode(event.keyCode);
        /** @type {?} */
        const time = concatTime(String(this.time), char);
        this._changeTimeIfValid(time);
    }
    /**
     * @return {?}
     */
    decrease() {
        if (!this.disabled) {
            /** @type {?} */
            let previousTime = +this.time - 1;
            if (previousTime < this.min) {
                previousTime = this.max;
            }
            if (this._isSelectedTimeDisabled(previousTime)) {
                previousTime = this._getAvailableTime(previousTime, this._getPrevAvailableTime.bind(this));
            }
            if (previousTime !== this.time) {
                this.timeChanged.emit(previousTime);
            }
        }
    }
    /**
     * @return {?}
     */
    increase() {
        if (!this.disabled) {
            /** @type {?} */
            let nextTime = +this.time + 1;
            if (nextTime > this.max) {
                nextTime = this.min;
            }
            if (this._isSelectedTimeDisabled(nextTime)) {
                nextTime = this._getAvailableTime(nextTime, this._getNextAvailableTime.bind(this));
            }
            if (nextTime !== this.time) {
                this.timeChanged.emit(nextTime);
            }
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.timeList && this.time != null) {
            if (this._isSelectedTimeDisabled(this.time)) {
                this._setAvailableTime();
            }
        }
    }
    /**
     * @return {?}
     */
    onBlur() {
        this.isFocused = false;
        if (this._previousTime !== this.time) {
            this._changeTimeIfValid(+this.time);
        }
    }
    /**
     * @return {?}
     */
    onFocus() {
        this.isFocused = true;
        this._previousTime = this.time;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onKeydown(event) {
        event.stopPropagation();
        if (!NgxMatTimepickerUtils.isDigit(event)) {
            event.preventDefault();
        }
        switch (event.key) {
            case "ArrowUp":
                this.increase();
                break;
            case "ArrowDown":
                this.decrease();
                break;
        }
        if (this.preventTyping && event.key !== "Tab") {
            event.preventDefault();
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    onModelChange(value) {
        this.time = +this._timeParser.transform(value, this.timeUnit);
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    _changeTimeIfValid(value) {
        if (!isNaN(value)) {
            this.time = value;
            if (this.time > this.max) {
                /** @type {?} */
                const timeString = String(value);
                this.time = +timeString[timeString.length - 1];
            }
            if (this.time < this.min) {
                this.time = this.min;
            }
            this.timeChanged.emit(this.time);
        }
    }
    /**
     * @private
     * @param {?} currentTime
     * @param {?} fn
     * @return {?}
     */
    _getAvailableTime(currentTime, fn) {
        /** @type {?} */
        const currentTimeIndex = this.timeList.findIndex((/**
         * @param {?} time
         * @return {?}
         */
        time => time.time === currentTime));
        /** @type {?} */
        const availableTime = fn(currentTimeIndex);
        return availableTime != null ? availableTime : this.time;
    }
    /**
     * @private
     * @param {?} index
     * @return {?}
     */
    _getNextAvailableTime(index) {
        /** @type {?} */
        const timeCollection = this.timeList;
        /** @type {?} */
        const maxValue = timeCollection.length;
        for (let i = index + 1; i < maxValue; i++) {
            /** @type {?} */
            const time = timeCollection[i];
            if (!time.disabled) {
                return time.time;
            }
        }
    }
    /**
     * @private
     * @param {?} index
     * @return {?}
     */
    _getPrevAvailableTime(index) {
        for (let i = index; i >= 0; i--) {
            /** @type {?} */
            const time = this.timeList[i];
            if (!time.disabled) {
                return time.time;
            }
        }
    }
    /**
     * @private
     * @param {?} time
     * @return {?}
     */
    _isSelectedTimeDisabled(time) {
        return this.timeList.find((/**
         * @param {?} faceTime
         * @return {?}
         */
        (faceTime) => faceTime.time === time)).disabled;
    }
    /**
     * @private
     * @return {?}
     */
    _setAvailableTime() {
        this.time = this.timeList.find((/**
         * @param {?} t
         * @return {?}
         */
        t => !t.disabled)).time;
        this.timeChanged.emit(this.time);
    }
}
NgxMatTimepickerControlComponent.nextId = 0;
NgxMatTimepickerControlComponent.decorators = [
    { type: Component, args: [{
                selector: "ngx-mat-timepicker-time-control",
                template: "<mat-form-field [color]=\"color\"\n                [floatLabel]=\"floatLabel\"\n                [ngClass]=\"{'active': isFocused}\"\n                class=\"ngx-mat-timepicker-control\">\n    <input id=\"ngx_mat_timepicker_field_{{id}}\"\n           name=\"ngx_mat_timepicker_field_{{id}}\"\n           matInput\n           maxlength=\"2\"\n           [ngModel]=\"time | ngxMatTimepickerParser: timeUnit | timeLocalizer: timeUnit : true\"\n           (ngModelChange)=\"onModelChange($event)\"\n           [placeholder]=\"placeholder\"\n           [disabled]=\"disabled\"\n           (keydown)=\"onKeydown($event)\"\n           (keypress)=\"changeTime($event)\"\n           (focus)=\"onFocus()\"\n           (blur)=\"onBlur()\" />\n    <div class=\"arrows-wrap\"\n         matSuffix>\n        <span class=\"arrow\"\n              role=\"button\"\n              (click)=\"increase()\">\n            <svg xmlns=\"http://www.w3.org/2000/svg\"\n                 height=\"18\"\n                 viewBox=\"0 0 24 24\"\n                 width=\"18\">\n                <path d=\"M0 0h24v24H0z\"\n                      fill=\"none\" />\n                <path d=\"M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z\" />\n            </svg>\n        </span>\n        <span class=\"arrow\"\n              role=\"button\"\n              (click)=\"decrease()\">\n            <svg xmlns=\"http://www.w3.org/2000/svg\"\n                 height=\"18\"\n                 viewBox=\"0 0 24 24\"\n                 width=\"18\">\n                <path d=\"M0 0h24v24H0V0z\"\n                      fill=\"none\" />\n                <path d=\"M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z\" />\n            </svg>\n        </span>\n    </div>\n</mat-form-field>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [NgxMatTimepickerParserPipe],
                styles: [".ngx-mat-timepicker-control{width:60px;min-width:60px}.ngx-mat-timepicker-control input{text-align:center}.ngx-mat-timepicker-control .arrows-wrap{position:absolute;right:0;bottom:-8px;display:flex;flex-direction:column}.ngx-mat-timepicker-control .arrows-wrap>.arrow{text-align:center;opacity:.5;height:15px;cursor:pointer;transition:opacity .2s;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.ngx-mat-timepicker-control .arrows-wrap>.arrow:hover{opacity:1}"]
            }] }
];
/** @nocollapse */
NgxMatTimepickerControlComponent.ctorParameters = () => [
    { type: NgxMatTimepickerParserPipe }
];
NgxMatTimepickerControlComponent.propDecorators = {
    color: [{ type: Input }],
    disabled: [{ type: Input }],
    floatLabel: [{ type: Input }],
    max: [{ type: Input }],
    min: [{ type: Input }],
    placeholder: [{ type: Input }],
    preventTyping: [{ type: Input }],
    time: [{ type: Input }],
    timeChanged: [{ type: Output }],
    timeList: [{ type: Input }],
    timeUnit: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * Generated from: lib/pipes/ngx-mat-timepicker-time-localizer.pipe.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxMatTimepickerTimeLocalizerPipe {
    /**
     * @param {?} _locale
     */
    constructor(_locale) {
        this._locale = _locale;
    }
    /**
     * @param {?} time
     * @param {?} timeUnit
     * @param {?=} isKeyboardEnabled
     * @return {?}
     */
    transform(time, timeUnit, isKeyboardEnabled = false) {
        if (time == null || time === "") {
            return "";
        }
        switch (timeUnit) {
            case NgxMatTimepickerUnits.HOUR: {
                /** @type {?} */
                const format = (time === 0 || isKeyboardEnabled) ? "HH" : "H";
                return this._formatTime(NgxMatTimepickerMeasure.hour, time, format);
            }
            case NgxMatTimepickerUnits.MINUTE:
                return this._formatTime(NgxMatTimepickerMeasure.minute, time, "mm");
            default:
                throw new Error(`There is no Time Unit with type ${timeUnit}`);
        }
    }
    /**
     * @private
     * @param {?} timeMeasure
     * @param {?} time
     * @param {?} format
     * @return {?}
     */
    _formatTime(timeMeasure, time, format) {
        try {
            return DateTime.fromObject({ [timeMeasure]: +time }).setLocale(this._locale).toFormat(format);
        }
        catch (_a) {
            throw new Error(`Cannot format provided time - ${time} to locale - ${this._locale}`);
        }
    }
}
NgxMatTimepickerTimeLocalizerPipe.decorators = [
    { type: Pipe, args: [{
                name: "timeLocalizer"
            },] }
];
/** @nocollapse */
NgxMatTimepickerTimeLocalizerPipe.ctorParameters = () => [
    { type: String, decorators: [{ type: Inject, args: [NGX_MAT_TIMEPICKER_LOCALE,] }] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: lib/pipes/ngx-mat-timepicker-active-hour.pipe.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxMatTimepickerActiveHourPipe {
    /**
     * @param {?} hour
     * @param {?} currentHour
     * @param {?} isClockFaceDisabled
     * @return {?}
     */
    transform(hour, currentHour, isClockFaceDisabled) {
        if (hour == null || isClockFaceDisabled) {
            return false;
        }
        return hour === currentHour;
    }
}
NgxMatTimepickerActiveHourPipe.decorators = [
    { type: Pipe, args: [{
                name: 'activeHour'
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: lib/pipes/ngx-mat-timepicker-active-minute.pipe.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxMatTimepickerActiveMinutePipe {
    /**
     * @param {?} minute
     * @param {?} currentMinute
     * @param {?} gap
     * @param {?} isClockFaceDisabled
     * @return {?}
     */
    transform(minute, currentMinute, gap, isClockFaceDisabled) {
        if (minute == null || isClockFaceDisabled) {
            return false;
        }
        /** @type {?} */
        const defaultGap = 5;
        return ((currentMinute === minute) && (minute % (gap || defaultGap) === 0));
    }
}
NgxMatTimepickerActiveMinutePipe.decorators = [
    { type: Pipe, args: [{
                name: 'activeMinute'
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: lib/components/ngx-mat-timepicker-content/ngx-mat-timepicker-content.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxMatTimepickerContentComponent {
}
NgxMatTimepickerContentComponent.decorators = [
    { type: Component, args: [{
                selector: "ngx-mat-timepicker-content",
                template: "<div *ngIf=\"appendToInput;else timepickerModal\">\n\t<ng-container *ngTemplateOutlet=\"timepickerOutlet\"></ng-container>\n</div>\n<ng-template #timepickerModal>\n\t<ng-container *ngTemplateOutlet=\"timepickerOutlet\"></ng-container>\n</ng-template>\n<ng-template #timepickerOutlet>\n\t<ng-content></ng-content>\n</ng-template>\n"
            }] }
];
NgxMatTimepickerContentComponent.propDecorators = {
    appendToInput: [{ type: Input }],
    inputElement: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * Generated from: lib/components/ngx-mat-timepicker-standalone/ngx-mat-timepicker-standalone.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxMatTimepickerStandaloneComponent extends NgxMatTimepickerBaseDirective {
    /**
     * @param {?} data
     * @param {?} timepickerSrv
     * @param {?} eventSrv
     * @param {?} locale
     */
    constructor(data, timepickerSrv, eventSrv, locale) {
        super(timepickerSrv, eventSrv, locale, data);
        this.data = data;
    }
    /**
     * @return {?}
     */
    close() {
        this.data.timepickerBaseRef.close();
    }
}
NgxMatTimepickerStandaloneComponent.decorators = [
    { type: Component, args: [{
                selector: "ngx-mat-timepicker-standalone",
                template: "<ng-template #cancelBtnDefault>\n\t<button mat-button\n\t\t\t[color]=\"color\">CANCEL\n\t</button>\n</ng-template>\n<ng-template #confirmBtnDefault>\n\t<button mat-button\n\t\t\t[color]=\"color\">OK\n\t</button>\n</ng-template>\n<div cdkTrapFocus\n\t cdkTrapFocusAutoCapture>\n\t<ngx-mat-timepicker-content [appendToInput]=\"data.appendToInput\"\n\t\t\t\t\t\t\t\t[inputElement]=\"data.inputElement\"\n\t\t\t\t\t\t\t\t[ngxMatTimepickerTheme]=\"data.theme\">\n\t\t<div class=\"timepicker\"\n\t\t\t [ngClass]=\"data.timepickerClass\">\n\t\t\t<mat-toolbar [color]=\"color\"\n\t\t\t\t\t\t class=\"timepicker-header\">\n\t\t\t\t<ngx-mat-timepicker-dial [color]=\"color\"\n\t\t\t\t\t\t\t\t\t\t [format]=\"data.format\"\n\t\t\t\t\t\t\t\t\t\t [hour]=\"(selectedHour | async)?.time\"\n\t\t\t\t\t\t\t\t\t\t [minute]=\"(selectedMinute | async)?.time\"\n\t\t\t\t\t\t\t\t\t\t [period]=\"selectedPeriod | async\"\n\t\t\t\t\t\t\t\t\t\t [activeTimeUnit]=\"activeTimeUnit\"\n\t\t\t\t\t\t\t\t\t\t [minTime]=\"data.minTime\"\n\t\t\t\t\t\t\t\t\t\t [maxTime]=\"data.maxTime\"\n\t\t\t\t\t\t\t\t\t\t [isEditable]=\"data.enableKeyboardInput\"\n\t\t\t\t\t\t\t\t\t\t [editableHintTmpl]=\"data.editableHintTmpl\"\n\t\t\t\t\t\t\t\t\t\t [minutesGap]=\"data.minutesGap\"\n\t\t\t\t\t\t\t\t\t\t [hoursOnly]=\"data.hoursOnly\"\n\t\t\t\t\t\t\t\t\t\t (periodChanged)=\"changePeriod($event)\"\n\t\t\t\t\t\t\t\t\t\t (timeUnitChanged)=\"changeTimeUnit($event)\"\n\t\t\t\t\t\t\t\t\t\t (hourChanged)=\"onHourChange($event)\"\n\t\t\t\t\t\t\t\t\t\t (minuteChanged)=\"onMinuteChange($event)\">\n\t\t\t\t</ngx-mat-timepicker-dial>\n\t\t\t</mat-toolbar>\n\t\t\t<div class=\"timepicker__main-content\">\n\t\t\t\t<div class=\"timepicker__body\"\n\t\t\t\t\t [ngSwitch]=\"activeTimeUnit\">\n\t\t\t\t\t<div *ngSwitchCase=\"timeUnit.HOUR\">\n\t\t\t\t\t\t<ngx-mat-timepicker-24-hours-face *ngIf=\"data.format === 24;else ampmHours\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  [color]=\"color\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  (hourChange)=\"onHourChange($event)\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  [selectedHour]=\"selectedHour | async\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  [minTime]=\"data.minTime\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  [maxTime]=\"data.maxTime\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  [format]=\"data.format\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  (hourSelected)=\"onHourSelected($event)\"></ngx-mat-timepicker-24-hours-face>\n\t\t\t\t\t\t<ng-template #ampmHours>\n\t\t\t\t\t\t\t<ngx-mat-timepicker-12-hours-face\n\t\t\t\t\t\t\t\t\t[color]=\"color\"\n\t\t\t\t\t\t\t\t\t(hourChange)=\"onHourChange($event)\"\n\t\t\t\t\t\t\t\t\t[selectedHour]=\"selectedHour | async\"\n\t\t\t\t\t\t\t\t\t[period]=\"selectedPeriod | async\"\n\t\t\t\t\t\t\t\t\t[minTime]=\"data.minTime\"\n\t\t\t\t\t\t\t\t\t[maxTime]=\"data.maxTime\"\n\t\t\t\t\t\t\t\t\t(hourSelected)=\"onHourSelected($event)\"></ngx-mat-timepicker-12-hours-face>\n\t\t\t\t\t\t</ng-template>\n\t\t\t\t\t</div>\n\t\t\t\t\t<ngx-mat-timepicker-minutes-face *ngSwitchCase=\"timeUnit.MINUTE\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t [color]=\"color\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t [selectedMinute]=\"selectedMinute | async\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t [selectedHour]=\"(selectedHour | async)?.time\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t [minTime]=\"data.minTime\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t [maxTime]=\"data.maxTime\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t [format]=\"data.format\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t [period]=\"selectedPeriod | async\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t [minutesGap]=\"data.minutesGap\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t (minuteChange)=\"onMinuteChange($event)\"></ngx-mat-timepicker-minutes-face>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t</ngx-mat-timepicker-content>\n\n\t<div class=\"ngx-mat-timepicker-standalone-actions\">\n\t\t<div (click)=\"close()\">\n\t\t\t<ng-container\n\t\t\t\t\t*ngTemplateOutlet=\"data.cancelBtnTmpl ? data.cancelBtnTmpl : cancelBtnDefault\"></ng-container>\n\t\t</div>\n\t\t<div (click)=\"setTime()\">\n\t\t\t<ng-container\n\t\t\t\t\t*ngTemplateOutlet=\"data.confirmBtnTmpl ? data.confirmBtnTmpl : confirmBtnDefault\"></ng-container>\n\t\t</div>\n\t</div>\n</div>\n",
                // tslint:disable-next-line:no-host-metadata-property
                host: {
                    "[class.mat-app-background]": "true"
                },
                encapsulation: ViewEncapsulation.None,
                styles: ["ngx-mat-timepicker-standalone{display:block;border-radius:4px;box-shadow:0 0 5px 2px rgba(0,0,0,.25);overflow:hidden}ngx-mat-timepicker-standalone ngx-mat-timepicker-content{display:block}ngx-mat-timepicker-standalone ngx-mat-timepicker-content mat-toolbar.timepicker-header{display:flex;justify-content:center;align-items:center}ngx-mat-timepicker-standalone ngx-mat-timepicker-content .clock-face{margin:16px}ngx-mat-timepicker-standalone .ngx-mat-timepicker-standalone-actions{display:flex;flex-direction:row;justify-content:flex-end;padding:0 16px 16px}"]
            }] }
];
/** @nocollapse */
NgxMatTimepickerStandaloneComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [NGX_MAT_TIMEPICKER_CONFIG,] }] },
    { type: NgxMatTimepickerService },
    { type: NgxMatTimepickerEventService },
    { type: String, decorators: [{ type: Inject, args: [NGX_MAT_TIMEPICKER_LOCALE,] }] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: lib/ngx-mat-timepicker.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxMatTimepickerModule {
    /**
     * @param {?} locale
     * @return {?}
     */
    static setLocale(locale) {
        return {
            ngModule: NgxMatTimepickerModule,
            providers: [
                { provide: NGX_MAT_TIMEPICKER_LOCALE, useValue: locale },
                { provide: NGX_MAT_TIMEPICKER_CONFIG, useValue: undefined },
            ]
        };
    }
}
NgxMatTimepickerModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    A11yModule,
                    FormsModule,
                    MatButtonModule,
                    MatFormFieldModule,
                    MatDialogModule,
                    MatInputModule,
                    MatSelectModule,
                    MatToolbarModule,
                    MatIconModule,
                    OverlayModule,
                    PortalModule,
                    SmpCoreUtilsModule.forRoot()
                ],
                exports: [
                    NgxMatTimepickerComponent,
                    NgxMatTimepickerToggleComponent,
                    NgxMatTimepickerFieldComponent,
                    NgxMatTimepickerDirective,
                    NgxMatTimepickerToggleIconDirective
                ],
                declarations: [
                    // Not really used, but needed to use it as abstract class
                    NgxMatTimepickerBaseDirective,
                    NgxMatTimepickerHoursFaceDirective,
                    //
                    NgxMatTimepickerActiveHourPipe,
                    NgxMatTimepickerActiveMinutePipe,
                    NgxMatTimepickerComponent,
                    NgxMatTimepickerDialComponent,
                    NgxMatTimepickerDialControlComponent,
                    NgxMatTimepickerDialogComponent,
                    NgxMatTimepickerDirective,
                    NgxMatTimepickerFaceComponent,
                    NgxMatTimepickerMinutesFaceComponent,
                    NgxMatTimepickerPeriodComponent,
                    NgxMatTimepickerStandaloneComponent,
                    NgxMatTimepickerToggleComponent,
                    NgxMatTimepicker12HoursFaceComponent,
                    NgxMatTimepicker24HoursFaceComponent,
                    NgxMatTimepickerToggleIconDirective,
                    NgxMatTimepickerAutofocusDirective,
                    NgxMatTimepickerMinutesFormatterPipe,
                    NgxMatTimepickerThemeDirective,
                    NgxMatTimepickerFieldComponent,
                    NgxMatTimepickerControlComponent,
                    NgxMatTimepickerParserPipe,
                    NgxMatTimepickerContentComponent,
                    NgxMatTimepickerTimeFormatterPipe,
                    NgxMatTimepickerTimeLocalizerPipe
                ],
                entryComponents: [
                    NgxMatTimepickerDialogComponent,
                    NgxMatTimepickerStandaloneComponent
                ]
            },] }
];

export { NgxMatTimepickerDirective, NgxMatTimepickerFieldComponent, NgxMatTimepickerModule, NgxMatTimepickerToggleComponent, NgxMatTimepickerToggleIconDirective, NgxMatTimepickerService as ɵa, NGX_MAT_TIMEPICKER_LOCALE as ɵb, NgxMatTimepickerComponent as ɵc, NGX_MAT_TIMEPICKER_CONFIG as ɵd, NgxMatTimepickerEventService as ɵe, NgxMatTimepickerBaseDirective as ɵf, NgxMatTimepickerHoursFaceDirective as ɵg, NgxMatTimepickerActiveHourPipe as ɵh, NgxMatTimepickerActiveMinutePipe as ɵi, NgxMatTimepickerDialComponent as ɵj, NgxMatTimepickerDialControlComponent as ɵk, NgxMatTimepickerParserPipe as ɵl, NgxMatTimepickerDialogComponent as ɵm, NgxMatTimepickerFaceComponent as ɵn, NgxMatTimepickerMinutesFaceComponent as ɵo, NgxMatTimepickerPeriodComponent as ɵp, NgxMatTimepickerStandaloneComponent as ɵq, NgxMatTimepicker12HoursFaceComponent as ɵr, NgxMatTimepicker24HoursFaceComponent as ɵs, NgxMatTimepickerAutofocusDirective as ɵt, NgxMatTimepickerMinutesFormatterPipe as ɵu, NgxMatTimepickerThemeDirective as ɵv, NgxMatTimepickerControlComponent as ɵw, NgxMatTimepickerContentComponent as ɵx, NgxMatTimepickerTimeFormatterPipe as ɵy, NgxMatTimepickerTimeLocalizerPipe as ɵz };
//# sourceMappingURL=ngx-mat-timepicker.js.map
