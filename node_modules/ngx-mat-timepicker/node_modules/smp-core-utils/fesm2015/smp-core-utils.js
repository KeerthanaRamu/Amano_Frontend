import { Injectable, ElementRef, Injector, ComponentFactoryResolver, ApplicationRef, NgModule } from '@angular/core';
import { NativeDateAdapter } from '@angular/material/core';
import { includes } from 'lodash';
import { timer } from 'rxjs';

const smpSep = "/";
const smpDay = "d";
const smpDayDoubled = "dd";
const smpMonth = "M";
const smpMonthDoubled = "MM";
const smpYear = "yyyy";
const smpCurrentYear = new Date().getFullYear();
const smpCentury = Math.round(smpCurrentYear / 100);
const SMP_LOCALE_IT_IT = "it-IT";
const SMP_LOCALE_EN_GB = "en-GB";
const SMP_LOCALE_EN_US = "en-US";
const SMP_FORMATS = {
    "it-IT": `${smpDayDoubled}${smpSep}${smpMonthDoubled}${smpSep}${smpYear}`,
    "en-GB": `${smpDayDoubled}${smpSep}${smpMonthDoubled}${smpSep}${smpYear}`,
    "en-US": `${smpMonth}${smpSep}${smpDay}${smpSep}${smpYear}`,
};
const SMP_DATE_FORMATS_IT = {
    parse: {
        dateInput: { month: "numeric", year: "numeric", day: "numeric" }
    },
    display: {
        dateInput: SMP_FORMATS[SMP_LOCALE_IT_IT],
        monthYearLabel: `${smpMonthDoubled}${smpSep}${smpYear}`,
        dateA11yLabel: SMP_FORMATS[SMP_LOCALE_IT_IT],
        monthYearA11yLabel: `${smpMonthDoubled}${smpSep}${smpYear}`
    }
};
const SMP_DATE_FORMATS_EN_GB = {
    parse: {
        dateInput: { month: "numeric", year: "numeric", day: "numeric" }
    },
    display: {
        dateInput: SMP_FORMATS[SMP_LOCALE_EN_GB],
        monthYearLabel: `${smpMonthDoubled}${smpSep}${smpYear}`,
        dateA11yLabel: SMP_FORMATS[SMP_LOCALE_EN_GB],
        monthYearA11yLabel: `${smpMonthDoubled}${smpSep}${smpYear}`
    }
};
const SMP_DATE_FORMATS_EN_US = {
    parse: {
        dateInput: { month: "numeric", year: "numeric", day: "numeric" }
    },
    display: {
        dateInput: SMP_FORMATS[SMP_LOCALE_EN_US],
        monthYearLabel: `${smpMonth}${smpSep}${smpYear}`,
        dateA11yLabel: SMP_FORMATS[SMP_LOCALE_EN_US],
        monthYearA11yLabel: `${smpMonth}${smpSep}${smpYear}`
    }
};
class SmpMatDateLocale extends NativeDateAdapter {
    constructor() {
        super(...arguments);
        this.display = SMP_DATE_FORMATS_EN_GB.display;
    }
    get currentLocale() {
        return this.locale;
    }
    format(date, _displayFormat_) {
        const day = date.getDate();
        const month = date.getMonth() + 1;
        const year = date.getFullYear();
        switch (this.display.dateInput) {
            case SMP_DATE_FORMATS_IT.display.dateInput:
                return this._addLeadingZeroes(day) + smpSep + this._addLeadingZeroes(month) + smpSep + year;
            case SMP_DATE_FORMATS_EN_GB.display.dateInput:
                return this._addLeadingZeroes(day) + smpSep + this._addLeadingZeroes(month) + smpSep + year;
            case SMP_DATE_FORMATS_EN_US.display.dateInput:
                return month + smpSep + day + smpSep + year;
            default:
                let formattedDate = "";
                try {
                    formattedDate = date.toLocaleDateString(SMP_LOCALE_EN_GB);
                }
                catch (e) {
                    console.warn("Catched error while printing ", e);
                    formattedDate = date.toDateString();
                }
                return formattedDate;
        }
    }
    parse(value) {
        if (includes([SMP_DATE_FORMATS_IT.display.dateInput, SMP_DATE_FORMATS_EN_GB.display.dateInput], this.display.dateInput)) {
            if (typeof value === typeof "" && value.length > 0) {
                const str = value.split(smpSep);
                if (str.length < 3) {
                    return new Date("smp");
                }
                if (str[2].length < 4) {
                    str[2] = smpCentury + str[2];
                }
                if (str[2].length !== 4) {
                    return new Date("smp");
                }
                const year = +str[2];
                const month = +str[1] - 1;
                const day = +str[0];
                return new Date(year, month, day);
            }
            return null;
        }
        else if (this.display.dateInput === SMP_DATE_FORMATS_EN_US.display.dateInput) {
            if (typeof value === typeof "" && value.length > 0) {
                const str = value.split(smpSep);
                if (str.length < 3) {
                    return new Date("smp");
                }
                if (str[2].length < 4) {
                    str[2] = smpCentury + str[2];
                }
                if (str[2].length !== 4) {
                    return new Date("smp");
                }
                const year = +str[2];
                const month = +str[0] - 1;
                const day = +str[1];
                return new Date(year, month, day);
            }
            return null;
        }
        else {
            console.warn("Date input format not valid." +
                " Be sure to use SMP_DATE_FORMATS" +
                " or extend this class with your own 'parser' and format 'methods'");
            console.info("For a complete guide visit github.com/tonysamperi/ngx-mat-lib");
            return null;
        }
    }
    setLocale(locale) {
        switch (locale) {
            case SMP_LOCALE_IT_IT:
                this.display = SMP_DATE_FORMATS_IT.display;
                break;
            case SMP_LOCALE_EN_GB:
                this.display = SMP_DATE_FORMATS_EN_GB.display;
                break;
            case SMP_LOCALE_EN_US:
                this.display = SMP_DATE_FORMATS_EN_US.display;
                break;
            default:
                this.display = SMP_DATE_FORMATS_EN_GB.display;
                break;
        }
        super.setLocale(locale);
    }
    _addLeadingZeroes(n) {
        return ("0" + n).slice(-2);
    }
}
SmpMatDateLocale.decorators = [
    { type: Injectable }
];

class SmpDomService {
    constructor(_componentFactoryResolver, _appRef, _injector) {
        this._componentFactoryResolver = _componentFactoryResolver;
        this._appRef = _appRef;
        this._injector = _injector;
        this._refs = {};
    }
    appendComp(component, key, target = "body", injector = this._injector, waiter = timer()) {
        const componentRef = this._componentFactoryResolver
            .resolveComponentFactory(component)
            .create(injector);
        this._appRef.attachView(componentRef.hostView);
        const domElem = componentRef.hostView
            .rootNodes[0];
        if (!!key) {
            !!this._refs[key] && console.warn("A ref with this key already exists and will be overwritten");
            this._refs[key] = componentRef;
        }
        else {
            console.warn("Component appended, but key wasn't provided. It won't be possible to remove it from the DOM automagically");
        }
        waiter.subscribe(() => {
            const targetEl = (typeof target === typeof ""
                ? document.querySelector(target)
                : target instanceof ElementRef ? target.nativeElement : target) || document.body;
            targetEl.appendChild(domElem);
        });
        return componentRef;
    }
    appendComps(compsData, injector, waiter) {
        compsData.forEach((compData) => this.appendComp(compData.comp, compData.key, compData.target, injector, waiter));
    }
    createInjector(token, value, viewContainerRef) {
        const providers = [
            { provide: token, useValue: value }
        ];
        return Injector.create({
            parent: viewContainerRef ? viewContainerRef.injector : this._injector,
            providers
        });
    }
    removeComp(key) {
        if (!!this._refs[key]) {
            const componentRef = this._refs[key];
            this._appRef.detachView(componentRef.hostView);
            componentRef.destroy();
            return !0;
        }
        else {
            console.warn(`No ref found with key ${key}`);
            return !1;
        }
    }
}
SmpDomService.decorators = [
    { type: Injectable }
];
SmpDomService.ctorParameters = () => [
    { type: ComponentFactoryResolver },
    { type: ApplicationRef },
    { type: Injector }
];

class SmpCoreUtilsModule {
    static forRoot() {
        return {
            ngModule: SmpCoreUtilsModule,
            providers: [
                SmpDomService
            ]
        };
    }
}
SmpCoreUtilsModule.decorators = [
    { type: NgModule, args: [{},] }
];

export { SMP_DATE_FORMATS_EN_GB, SMP_DATE_FORMATS_EN_US, SMP_DATE_FORMATS_IT, SMP_FORMATS, SMP_LOCALE_EN_GB, SMP_LOCALE_EN_US, SMP_LOCALE_IT_IT, SmpCoreUtilsModule, SmpDomService, SmpMatDateLocale };
//# sourceMappingURL=smp-core-utils.js.map
